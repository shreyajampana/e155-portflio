[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Post #1\n\n\nPersonal goals for E155\n\n\n\n\n\nAug 29, 2025\n\n\nShreya Jampana\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "project/proposal.html",
    "href": "project/proposal.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "We propose to design and implement an autotuning microphone. The system will record a user’s singing voice using a microphone, which is captured using a button to indicate the end of recording. The system will then detect its pitch and shift it toward the nearest note using FPGA-based audio processing.\n\n\n\n\nThe system captures microphone input through the MCU’s ADC at a sample rate of 48 kHz.\n\nThe system uses an external DAC to output processed audio from the FPGA.\nAudio data is transferred between the MCU and FPGA using the SPI protocol with no dropped samples.\nThe FPGA performs pitch detection and correction.\nThe autotune output is within ±1% of the target pitch frequency.\nThe output of the system starts playing one second after the user is finished speaking.\n\n\n\n\nThe riskiest element of this project is the analog input, or receive chain. This is challenging because it is highly dependent on the test environment—even if the system receives the same analog input, receiving this in a quiet lab will produce a different output as compared to receiving it in a bustling lab with lots of background noise. This is because background noise in the lab will add unwanted peaks and troughs in the frequency spectrum, and since the FFT analyzes all the sound captured by the microphone, the results could include inaccurate amplitude readings for the actual signal’s frequency components. In order to debug our system itself, we could include an audio jack before entering the preamp, which would allow us to step around the microphone and provide another input to test the system functionality.\n\n\n\nTo implement the design on the UPduino FPGA, we’ll create a system in SystemVerilog that processes a stream of audio data. Incoming audio samples received via SPI, processed, then fed into a buffer that’ll allow us to process the next chunk of data while the previous is outputted. An STFT will grab chunks of the sample data, apply a Hanning window in order to account for discontinuities, then perform an FFT and utilize HPS (Harmonic Product Spectrum) to find the fundamental frequency. The pitch will be corrected via the phase vocoder method, an inverse FFT (iFFT) will be performed to bring the data back into the time domain, and the overlap-add (OLA) method will be used in order to reconstruct the final signal. The final signal will be sent to the external DAC, which will then send the signal to the audio amplifier and eventually be outputted.\nIn this design, we will make use of the FPGA’s dedicated DSP multipliers, which is an FPGA functionality previously not covered in labs. This will be done to efficiently perform fixed-point arithmetic operations and is required for the FFT, windowing, and overlap-add steps. Using these DSP resources allows us to offload intensive multiply–accumulate operations from general logic, enabling higher throughput, lower latency, and better utilization of the FPGA fabric for real-time digital signal processing.\n\n\n\nThe microcontroller serves as the interface between the analog audio and the FPGA’s digital signal processing. It will perform the ADC conversion by sampling the incoming microphone data at 48 kHz. The MCU will also manage the data transfer with the FPGA over an SPI protocol. The audio samples captured by the ADC are saved in SRAM buffers before being transferred to the FPGA. This should be continuous and synchronized audio steaming.\n\n\n\nThe piece of nontrivial external hardware we will be using is a DAC60501MDGSR, which is a single channel 12-bit DAC. It is SPI compatible up to 50 MHz. We will be communicating with the DAC over SPI to convert the digital output signal from the FPGA to an analog input for the audio amplifier and speaker. Other external hardware we are using is a microphone preamplifier with automatic gain control (AGC) and low-noise microphone bias. It amplifies the signal from the microphone to a level the STM32 can digitize reliably. The device provides three selectable gain settings of 40 dB, 50 dB, or 60 dB, with the AGC circuitry automatically adjusting gain to prevent clipping on loud inputs while keeping softer inputs audible. The chip also provides a built-in 2 V bias to power the microphone, which reduces extra components and helps keep the signal clean for accurate pitch detection.\n\n\n\n\n\n\nCalculations\n\n\n\n\n\nCalculations\n\n\n\n\n\n\n\n\nBlock Diagram\n\n\n\n\n\nTo create a work breakdown for this project, we created this Gantt Chart, which details the steps needed to be done for all components of the system. These steps are broken down to all the team members and are also divided to cover the remaining four weeks of the course.\n\n\n\nThis BOM contains all the parts needed for this project, including the part number, datasheet, quantity, and price, ensuring that we are staying below the maximum $50 budget for this project."
  },
  {
    "objectID": "project/proposal.html#project-proposal",
    "href": "project/proposal.html#project-proposal",
    "title": "E155 Portfolio",
    "section": "",
    "text": "We propose to design and implement an autotuning microphone. The system will record a user’s singing voice using a microphone, which is captured using a button to indicate the end of recording. The system will then detect its pitch and shift it toward the nearest note using FPGA-based audio processing.\n\n\n\n\nThe system captures microphone input through the MCU’s ADC at a sample rate of 48 kHz.\n\nThe system uses an external DAC to output processed audio from the FPGA.\nAudio data is transferred between the MCU and FPGA using the SPI protocol with no dropped samples.\nThe FPGA performs pitch detection and correction.\nThe autotune output is within ±1% of the target pitch frequency.\nThe output of the system starts playing one second after the user is finished speaking.\n\n\n\n\nThe riskiest element of this project is the analog input, or receive chain. This is challenging because it is highly dependent on the test environment—even if the system receives the same analog input, receiving this in a quiet lab will produce a different output as compared to receiving it in a bustling lab with lots of background noise. This is because background noise in the lab will add unwanted peaks and troughs in the frequency spectrum, and since the FFT analyzes all the sound captured by the microphone, the results could include inaccurate amplitude readings for the actual signal’s frequency components. In order to debug our system itself, we could include an audio jack before entering the preamp, which would allow us to step around the microphone and provide another input to test the system functionality.\n\n\n\nTo implement the design on the UPduino FPGA, we’ll create a system in SystemVerilog that processes a stream of audio data. Incoming audio samples received via SPI, processed, then fed into a buffer that’ll allow us to process the next chunk of data while the previous is outputted. An STFT will grab chunks of the sample data, apply a Hanning window in order to account for discontinuities, then perform an FFT and utilize HPS (Harmonic Product Spectrum) to find the fundamental frequency. The pitch will be corrected via the phase vocoder method, an inverse FFT (iFFT) will be performed to bring the data back into the time domain, and the overlap-add (OLA) method will be used in order to reconstruct the final signal. The final signal will be sent to the external DAC, which will then send the signal to the audio amplifier and eventually be outputted.\nIn this design, we will make use of the FPGA’s dedicated DSP multipliers, which is an FPGA functionality previously not covered in labs. This will be done to efficiently perform fixed-point arithmetic operations and is required for the FFT, windowing, and overlap-add steps. Using these DSP resources allows us to offload intensive multiply–accumulate operations from general logic, enabling higher throughput, lower latency, and better utilization of the FPGA fabric for real-time digital signal processing.\n\n\n\nThe microcontroller serves as the interface between the analog audio and the FPGA’s digital signal processing. It will perform the ADC conversion by sampling the incoming microphone data at 48 kHz. The MCU will also manage the data transfer with the FPGA over an SPI protocol. The audio samples captured by the ADC are saved in SRAM buffers before being transferred to the FPGA. This should be continuous and synchronized audio steaming.\n\n\n\nThe piece of nontrivial external hardware we will be using is a DAC60501MDGSR, which is a single channel 12-bit DAC. It is SPI compatible up to 50 MHz. We will be communicating with the DAC over SPI to convert the digital output signal from the FPGA to an analog input for the audio amplifier and speaker. Other external hardware we are using is a microphone preamplifier with automatic gain control (AGC) and low-noise microphone bias. It amplifies the signal from the microphone to a level the STM32 can digitize reliably. The device provides three selectable gain settings of 40 dB, 50 dB, or 60 dB, with the AGC circuitry automatically adjusting gain to prevent clipping on loud inputs while keeping softer inputs audible. The chip also provides a built-in 2 V bias to power the microphone, which reduces extra components and helps keep the signal clean for accurate pitch detection.\n\n\n\n\n\n\nCalculations\n\n\n\n\n\nCalculations\n\n\n\n\n\n\n\n\nBlock Diagram\n\n\n\n\n\nTo create a work breakdown for this project, we created this Gantt Chart, which details the steps needed to be done for all components of the system. These steps are broken down to all the team members and are also divided to cover the remaining four weeks of the course.\n\n\n\nThis BOM contains all the parts needed for this project, including the part number, datasheet, quantity, and price, ensuring that we are staying below the maximum $50 budget for this project."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Post #1",
    "section": "",
    "text": "This semester, my personal goal in E-155 is to bridge a gap in my skill set: while I’ve always been drawn to analog circuitry and PCB design, I want to grow more confident in the digital side of hardware. I’m excited by the wide applications of embedded systems, from everyday devices to specialized applications in medicine and beyond, and I see this class as a chance to reframe how I think about hardware and software working together. I also want to get better at debugging with discipline rather than just trial and error. Another goal is to practice designing at the system level, balancing elegance with practicality, and then clearly communicating those decisions in reports and documentation. More broadly, I want to get comfortable with iteration and failure as part of the process, and to use the labs and project to experiment creatively and push myself beyond the bare minimum. After the labs and by the end of the semester, I hope to feel fluent enough in digital design to integrate it with my analog interests, and to carry that confidence into a really cool final project and beyond!"
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, we learned how to use the FPGA to scan inputs from a 4x4 keypad. The multiplexed display from lab 2 was combined with a keypad to display user inputs. A scanning system was designed to read the inputs from keypad scanner, and a method for switch debouncing was also implemented. This lab required carefuly, thought-outTsynchronous sequential design\n\n\n\nOne of the biggest design considerations was the scanner FSM. I went through many iterations, but in order to meet all of the specifications of the lab, ended up going with the following design:\n\n\n\nFigure 1. Scanner FSM\n\n\nAs shown in figure 1, the scanner FSM has one state for each column, and one for each row within each column. Given a row input, the FSM should transition from the column state to the state corresponding to the row input. If no rows are pressed, you transition to the next column and repeat the process. My FSM was originally simpler, but in order to account for edge cases in button pressing, I decided to make each row a distinct state.\nThe next big design consideration was debouncer FSM. One important consideration when working with the keypad matrix is switch bouncing. When a button is pressed, the input may take some time to settle. In order to not register the “bouncing” as multiple presses, a method for switch debouncing has to be implemented. I did this using another FSM, which interacts with my scanner FSM and the rest of my modules.\n\n\n\nFigure 2. Debouncer FSM\n\n\nAs shown in figure 2, the debouncer module has four states. The first state is idle, and as soon as a row press is detected, you transition to the second state, which is where debouncing happens. I implemented the debouncing using a counter. I chose an arbitrary debounce time of 50 ms, as I believed the key would stabilitize after that time. Since the debouncer operates on the slow clock (at 183 Hz), I determined the number of cycles the counter needed to iterate by multiplying the clock frequency by the debouncing time, which gave me a number of ~10. Therefore, as soon as the counter reaches 10, you transition to the next stage, in which a pulse is sent out. You turn the pulse off in the final stage, and go back to the idle state. This pulse allows for regulation of decoding, maintaining it to only happen after the debouncing is complete.\nAfter designing the FSMs and all the interacting modules (explained in block diagram section below), I wired up the keypad. Seeing as our design was active high, I used pull down resistors for the rows. The picture of the wired circuit is shown below in figure 3.\n\n\n\nFigure 3. Physical Circuit and Setup\n\n\nIn order to test the system, I wrote some test benches for the more crucial modules and tested the keypad physically for all edge cases.\n\n\n\nThe source code for the project can be found in the associated Github repository.\n\n\nThe block diagram for my system is shown below in figure 4.\n\n\n\nFigure 4. System block diagram\n\n\nThe high speed oscillator lives in the top level module, and a slowClock module after it divides the high speed 48MHz clock into a slower 183Hz clock, which is used by the rest of the system. Following this, a scanner module takes in the row input and powers the column. It also sends out the 8-bit keyValue, which contains information about the row and column pressed. This module also outputs whether or not a row is pressed, which is used by the debouncer to debounce the press. The debouncer module outputs a pulse once debouncing is complete. Once the segDriver module receives a pulse, it takes the keyValue and decodes it into a four bit input. This module also shifts the old digit to the left, and puts the new digit on the right. These are sent to the switcher, which sends power to the seven segment (using enables) at the same frequency. The seven segment module then dipays the numbers.\n\n\n\nThe schematic for the system is shown below in figure 5. It includes the FPGA, the dual seven segment, and the keypad.\n\n\n\nFigure 5. System Schematic\n\n\n\n\n\n\nThe design meets all of the proficiency specs. It registers key presses, and moves old key presses to the left and puts new key presses on the right. All the LEDs are equally bright. The design also doesn’t lock up when multiple keys are pressed.\nThroughout the lab, there were multiple bugs I resolved. I spent a long time finalizing the design of the FSMs and figuring out how to implement the debouncing logic. After quickly writing up the System Verilog, I uploaded my code and noticed that there were two 0s being displayed but no presses were being registered. This was the biggest bug, and was solved with a lot of simulation, checking the code to decode keyValue, and dealing with clock issues.\nI originally had a smaller FSM, but changed it to account for every row case so that when one key is pressed, and a second is also pressed in the same column at the same time, when you let go of the original key, the second key registers. I still have some issues that I am debugging. For example, for the two rightmost columns, when I press one key and press another, it registers the press even though the other is held down. This only happens for the two rightmost columns. I also was not able to implement a synchronizer successfully.\n\n\n\nDespite the small issues discussed above, my FPGA design was successfully able to scan inputs from a 4x4 keypad and debounce all the keys. In total, I spent about 60 hours on this lab.\n\n\n\nFor this week’s AI prototype, I tested two prompts. Here was prompt A:\nTarget device: Lattice iCE40 UP5K FPGA with internal high-speed oscillator (~20 MHz).\nWrite synthesizable SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7‑segment display. Implement: A clock divider that derives a scan clock on the order of 100–200 Hz from the internal oscillator. A keypad scanning controller that iterates one active‑low column at a time and samples active‑low rows, registering at most one key per press (debounce‑by‑design), ignoring additional presses while any key is held, and allowing a new registration only after release. A top level that updates two hex digits (older and most recent) when a new key is registered and drives a time‑multiplexed two‑digit 7‑segment display without visible flicker and with balanced brightness. Use idiomatic SystemVerilog (e.g., logic, always_ff, enumerated states for FSMs). Provide clean module boundaries and keep all state synchronous. Include brief comments explaining the design choices.\nHere was the code it produced:\nCode:\n// Generates a single-cycle tick at a programmable rate from a faster clk.\n// Example: With 20 MHz clk, DIV=100_000 -&gt; 200 Hz tick.\nmodule clock_divider_tick #(\n    parameter int unsigned DIV = 100_000  // cycles per tick\n) (\n    input  logic clk,\n    input  logic reset_n,   // active-low synchronous reset\n    output logic tick       // 1-cycle pulse every DIV cycles\n);\n    localparam int W = $clog2(DIV);\n    logic [W-1:0] cnt;\n\n    always_ff @(posedge clk) begin\n        if (!reset_n) begin\n            cnt  &lt;= '0;\n            tick &lt;= 1'b0;\n        end else begin\n            if (cnt == DIV-1) begin\n                cnt  &lt;= '0;\n                tick &lt;= 1'b1;\n            end else begin\n                cnt  &lt;= cnt + 1'b1;\n                tick &lt;= 1'b0;\n            end\n        end\n    end\nendmodule\n\n\n// Two-flop synchronizer (vector-capable)\nmodule sync2 #(\n    parameter int W = 1\n) (\n    input  logic        clk,\n    input  logic        reset_n,\n    input  logic [W-1:0] d_async,\n    output logic [W-1:0] q_sync\n);\n    logic [W-1:0] s1;\n\n    always_ff @(posedge clk) begin\n        if (!reset_n) begin\n            s1     &lt;= '1;     // rows are pulled-up; safe default high (no key)\n            q_sync &lt;= '1;\n        end else begin\n            s1     &lt;= d_async;\n            q_sync &lt;= s1;\n        end\n    end\nendmodule\n\n\n// 4x4 matrix scanner (active-LOW rows/cols).\n// Debounce-by-design: registers at most one key per press. While any key\n// is held (across scan frames), further presses are ignored until release.\nmodule keypad_scanner_4x4 #(\n    // If your hardware uses different polarities, adjust here.\n    parameter bit ROW_ACTIVE_LOW = 1,\n    parameter bit COL_ACTIVE_LOW = 1\n) (\n    input  logic       clk,          // system clock (~20 MHz)\n    input  logic       reset_n,      // active-low sync reset\n    input  logic       scan_tick,    // ~100–200 Hz\n    input  logic [3:0] rows_in_sync, // synchronized rows\n    output logic [3:0] cols_out,     // driven to select 1 col at a time\n    output logic [3:0] key_code,     // hex 0..F per keypad mapping\n    output logic       key_pulse     // 1-cycle pulse when a new key is registered\n);\n    // FSM cycles columns; on each scan_tick select next column and sample rows.\n    typedef enum logic [1:0] {S_COL0, S_COL1, S_COL2, S_COL3} col_state_e;\n    col_state_e state, state_n;\n\n    logic [3:0] col_sel;   // one-hot (bit=1 means \"selected\" column)\n    logic [3:0] rows_smpl; // sampled (normalized active-high \"pressed\")\n    logic       any_pressed;\n    logic       latched_busy; // set after registering a key, cleared on full release\n\n    // Column drive: one column active at a time\n    always_comb begin\n        unique case (state)\n            S_COL0: col_sel = 4'b0001;\n            S_COL1: col_sel = 4'b0010;\n            S_COL2: col_sel = 4'b0100;\n            default: col_sel = 4'b1000;\n        endcase\n    end\n\n    // Active-LOW/active-HIGH drive for columns\n    always_comb begin\n        if (COL_ACTIVE_LOW) begin\n            // Selected column driven LOW (0), others HIGH (1)\n            cols_out = ~col_sel;\n        end else begin\n            cols_out = col_sel;\n        end\n    end\n\n    // Normalize rows: rows_norm=1 means \"pressed in current column\"\n    logic [3:0] rows_norm;\n    always_comb begin\n        if (ROW_ACTIVE_LOW) rows_norm = ~rows_in_sync;\n        else                rows_norm =  rows_in_sync;\n    end\n\n    // Sample rows on each scan tick (after column has been stable a full frame)\n    always_ff @(posedge clk) begin\n        if (!reset_n) rows_smpl &lt;= '0;\n        else if (scan_tick)     rows_smpl &lt;= rows_norm;\n    end\n    assign any_pressed = |rows_smpl;\n\n    // Next column on scan_tick\n    always_comb begin\n        state_n = state;\n        if (scan_tick) begin\n            unique case (state)\n                S_COL0: state_n = S_COL1;\n                S_COL1: state_n = S_COL2;\n                S_COL2: state_n = S_COL3;\n                default: state_n = S_COL0;\n            endcase\n        end\n    end\n    always_ff @(posedge clk) begin\n        if (!reset_n) state &lt;= S_COL0;\n        else          state &lt;= state_n;\n    end\n\n    // Register at most one key per continuous press:\n    // When not busy and exactly one row asserted, emit key_pulse and capture code.\n    function automatic logic is_onehot4(input logic [3:0] v);\n        return (v != 4'b0000) && ((v & (v - 1'b1)) == 4'b0000);\n    endfunction\n\n    // Encode row/col to hex (0..F). Mapping below is typical calculator style:\n    //   Col0   Col1   Col2   Col3\n    // R0  1      2      3      A\n    // R1  4      5      6      B\n    // R2  7      8      9      C\n    // R3  E      0      F      D\n    function automatic logic [3:0] encode_hex(\n        input logic [3:0] row_onehot,\n        input logic [3:0] col_onehot\n    );\n        int r, c;\n        begin\n            // onehot -&gt; index\n            r = (row_onehot[0]) ? 0 :\n                (row_onehot[1]) ? 1 :\n                (row_onehot[2]) ? 2 : 3;\n            c = (col_onehot[0]) ? 0 :\n                (col_onehot[1]) ? 1 :\n                (col_onehot[2]) ? 2 : 3;\n            // lookup\n            unique case ({r[1:0], c[1:0]})\n                4'(0),4'(0): encode_hex = 4'h1; // r0 c0\n                default: begin end\n            endcase\n        end\n    endfunction\n\n    // The above would be clunky—use a compact LUT instead:\n    // Index = {row_idx[1:0], col_idx[1:0]}\n    function automatic logic [3:0] lut_hex(input int r, input int c);\n        logic [3:0] table [0:15];\n        begin\n            // Fill table\n            // r=0: 1,2,3,A\n            table[ 0] = 4'h1; table[ 1] = 4'h2; table[ 2] = 4'h3; table[ 3] = 4'hA;\n            // r=1: 4,5,6,B\n            table[ 4] = 4'h4; table[ 5] = 4'h5; table[ 6] = 4'h6; table[ 7] = 4'hB;\n            // r=2: 7,8,9,C\n            table[ 8] = 4'h7; table[ 9] = 4'h8; table[10] = 4'h9; table[11] = 4'hC;\n            // r=3: E,0,F,D\n            table[12] = 4'hE; table[13] = 4'h0; table[14] = 4'hF; table[15] = 4'hD;\n            lut_hex = table[(r&lt;&lt;2)|c];\n        end\n    endfunction\n\n    function automatic int onehot_to_idx(input logic [3:0] v);\n        begin\n            case (1'b1)\n                v[0]: onehot_to_idx = 0;\n                v[1]: onehot_to_idx = 1;\n                v[2]: onehot_to_idx = 2;\n                default: onehot_to_idx = 3;\n            endcase\n        end\n    endfunction\n\n    // Busy latch and key pulse generation\n    always_ff @(posedge clk) begin\n        if (!reset_n) begin\n            latched_busy &lt;= 1'b0;\n            key_pulse    &lt;= 1'b0;\n            key_code     &lt;= 4'h0;\n        end else begin\n            key_pulse &lt;= 1'b0; // default\n\n            if (!latched_busy) begin\n                // Only accept a new key when exactly one row is asserted\n                if (scan_tick && is_onehot4(rows_smpl)) begin\n                    int r = onehot_to_idx(rows_smpl);\n                    int c = onehot_to_idx(col_sel);\n                    key_code  &lt;= lut_hex(r, c);\n                    key_pulse &lt;= 1'b1;   // one-cycle pulse on system clk\n                    latched_busy &lt;= 1'b1;\n                end\n            end else begin\n                // Wait for full release (no rows asserted across columns)\n                if (!any_pressed) begin\n                    // Note: any_pressed reflects sampled rows for the current column;\n                    // With a frame-by-frame scan at ~200 Hz, \"release observed\" is sufficient.\n                    latched_busy &lt;= 1'b0;\n                end\n            end\n        end\n    end\nendmodule\n\n// Hex nibble to 7-seg segments (a..g), active-LOW output by default.\nmodule hex7seg #(\n    parameter bit ACTIVE_LOW_SEG = 1\n) (\n    input  logic [3:0] hex,\n    output logic [6:0] seg  // {a,b,c,d,e,f,g}\n);\n    logic [6:0] seg_h; // active-high internal truth table\n\n    always_comb begin\n        unique case (hex)\n            4'h0: seg_h = 7'b1111110;\n            4'h1: seg_h = 7'b0110000;\n            4'h2: seg_h = 7'b1101101;\n            4'h3: seg_h = 7'b1111001;\n            4'h4: seg_h = 7'b0110011;\n            4'h5: seg_h = 7'b1011011;\n            4'h6: seg_h = 7'b1011111;\n            4'h7: seg_h = 7'b1110000;\n            4'h8: seg_h = 7'b1111111;\n            4'h9: seg_h = 7'b1111011;\n            4'hA: seg_h = 7'b1110111;\n            4'hB: seg_h = 7'b0011111; // lower-case b\n            4'hC: seg_h = 7'b1001110;\n            4'hD: seg_h = 7'b0111101; // lower-case d\n            4'hE: seg_h = 7'b1001111;\n            default: seg_h = 7'b1000111; // F\n        endcase\n        seg = (ACTIVE_LOW_SEG) ? ~seg_h : seg_h;\n    end\nendmodule\n\n\n// Two-digit 7-seg time-multiplexer with balanced brightness.\n// refresh_tick should be ~2 kHz (so each digit ~1 kHz).\nmodule sevenseg_mux2 #(\n    parameter bit ACTIVE_LOW_SEG = 1,\n    parameter bit ACTIVE_LOW_DIG = 1\n) (\n    input  logic       clk,\n    input  logic       reset_n,\n    input  logic       refresh_tick,    // toggles active digit\n    input  logic [3:0] hex0,            // right (least recent) or \"newest\"\n    input  logic [3:0] hex1,            // left (older)\n    output logic [6:0] seg,             // a..g (dp omitted; add if needed)\n    output logic [1:0] dig_en           // [1]=left, [0]=right\n);\n    logic sel; // 0: show right, 1: show left\n    logic [3:0] nibble;\n    logic [6:0] seg_int;\n    logic [1:0] dig_h;  // active-high internal enables\n\n    always_ff @(posedge clk) begin\n        if (!reset_n) sel &lt;= 1'b0;\n        else if (refresh_tick) sel &lt;= ~sel;\n    end\n\n    always_comb begin\n        nibble = (sel) ? hex1 : hex0;\n        dig_h  = (sel) ? 2'b10 : 2'b01; // sel=1 -&gt; left on; sel=0 -&gt; right on\n    end\n\n    hex7seg #(.ACTIVE_LOW_SEG(ACTIVE_LOW_SEG)) u_hex (\n        .hex (nibble),\n        .seg (seg_int)\n    );\n\n    // Outputs with desired polarities\n    always_comb begin\n        seg   = seg_int;\n        dig_en = (ACTIVE_LOW_DIG) ? ~dig_h : dig_h;\n    end\nendmodule\n\n\n// Top-level: scans keypad and shows last two hex keys (hex1=older, hex0=most recent)\n// on a dual 7-seg display with time-multiplexing.\nmodule top_keypad_7seg #(\n    // Clocking (assume ~20 MHz HSOSC)\n    parameter int unsigned F_CLK_HZ     = 20_000_000,\n    parameter int unsigned SCAN_HZ      = 200,     // keypad scan frame rate\n    parameter int unsigned REFRESH_HZ   = 2_000,   // 2 kHz digit toggle (~1 kHz per digit)\n    // IO polarity\n    parameter bit ROW_ACTIVE_LOW = 1,\n    parameter bit COL_ACTIVE_LOW = 1,\n    parameter bit SEG_ACTIVE_LOW = 1,\n    parameter bit DIG_ACTIVE_LOW = 1\n) (\n    input  logic        clk,           // connect to HSOSC (~20 MHz)\n    input  logic        reset_n,       // active-low synchronous reset\n    // Keypad IO\n    input  logic [3:0]  rows_in,       // keypad rows (with external pull-ups or IO pull-ups)\n    output logic [3:0]  cols_out,      // keypad cols\n    // 7-seg IO\n    output logic [6:0]  seg,           // segments a..g (dp omitted)\n    output logic [1:0]  dig_en         // digit enables [1]=left, [0]=right\n);\n    // --- Ticks ---\n    localparam int unsigned DIV_SCAN    = (F_CLK_HZ / SCAN_HZ);\n    localparam int unsigned DIV_REFRESH = (F_CLK_HZ / REFRESH_HZ);\n\n    logic tick_scan, tick_refresh;\n\n    clock_divider_tick #(.DIV(DIV_SCAN)) u_div_scan (\n        .clk     (clk),\n        .reset_n (reset_n),\n        .tick    (tick_scan)\n    );\n\n    clock_divider_tick #(.DIV(DIV_REFRESH)) u_div_ref (\n        .clk     (clk),\n        .reset_n (reset_n),\n        .tick    (tick_refresh)\n    );\n\n    // --- Synchronize keypad rows ---\n    logic [3:0] rows_sync;\n    sync2 #(.W(4)) u_sync_rows (\n        .clk     (clk),\n        .reset_n (reset_n),\n        .d_async (rows_in),\n        .q_sync  (rows_sync)\n    );\n\n    // --- Scanner ---\n    logic [3:0] key_nibble;\n    logic       key_pulse;\n\n    keypad_scanner_4x4 #(\n        .ROW_ACTIVE_LOW (ROW_ACTIVE_LOW),\n        .COL_ACTIVE_LOW (COL_ACTIVE_LOW)\n    ) u_scan (\n        .clk         (clk),\n        .reset_n     (reset_n),\n        .scan_tick   (tick_scan),\n        .rows_in_sync(rows_sync),\n        .cols_out    (cols_out),\n        .key_code    (key_nibble),\n        .key_pulse   (key_pulse)\n    );\n\n    // --- Last two keys history ---\n    // hex0 = most recent, hex1 = older\n    logic [3:0] hex0, hex1;\n\n    always_ff @(posedge clk) begin\n        if (!reset_n) begin\n            hex0 &lt;= 4'h0;\n            hex1 &lt;= 4'h0;\n        end else if (key_pulse) begin\n            hex1 &lt;= hex0;\n            hex0 &lt;= key_nibble;\n        end\n    end\n\n    // --- 7-seg MUX ---\n    sevenseg_mux2 #(\n        .ACTIVE_LOW_SEG (SEG_ACTIVE_LOW),\n        .ACTIVE_LOW_DIG (DIG_ACTIVE_LOW)\n    ) u_mux (\n        .clk          (clk),\n        .reset_n      (reset_n),\n        .refresh_tick (tick_refresh),\n        .hex0         (hex0),  // show most recent on right\n        .hex1         (hex1),  // older on left\n        .seg          (seg),\n        .dig_en       (dig_en)\n    );\nendmodule\nThis is the code AI generated. It gave me a syntax error, and when I tried to give the error to AI, it told me that I have to declare the return type differently. I didn’t fully understand the error or the code, because it used high-level functions.\nPrompt B had three modular prompts: one for the one-shot registration (to debounce by design), one for keypad scanner controller, and one for integrate and display. Here is the code it produced:\n\n//------------------------------------------------------------------------------\n// Key One-Shot Registrar for 4x4 Keypad Scanners\n// - Assert new_key_pulse for 1 clk when a *new, debounced* press is detected\n// - Latch key_code_out at that instant\n// - Block further registrations until *full, debounced* release\n// - Debounce windows expressed in \"samples\" (e.g., column-scan ticks)\n//------------------------------------------------------------------------------\nmodule key_one_shot #(\n    // Number of *consecutive* samples required to confirm a press/release.\n    // Choose small integers given a scan rate of ~100–600 Hz.\n    parameter int PRESS_STABLE_SAMPLES   = 2,\n    parameter int RELEASE_STABLE_SAMPLES = 2\n)(\n    input  logic       clk,\n    input  logic       rst,           // synchronous active-high reset\n\n    // Drive this with your keypad scanner's sampling cadence\n    // (e.g., once per full matrix read or per-column step).\n    input  logic       sample_tick,\n\n    // Current instantaneous keypad state (already synchronized to clk):\n    input  logic       key_down,      // 1 if *any* key is presently detected\n    input  logic [3:0] key_code_in,   // code for the currently-detected key\n\n    // Registration outputs:\n    output logic       new_key_pulse, // 1 clk pulse on *new* debounced press\n    output logic [3:0] key_code_out,  // latched code for that new press\n    output logic       busy           // 1 while a key is debounced/held\n);\n\n    // ============================ State machine =============================\n    typedef enum logic [1:0] {\n        S_IDLE            = 2'd0,  // no key; waiting for a candidate press\n        S_DEBOUNCE_PRESS  = 2'd1,  // verifying stable press of one code\n        S_HELD            = 2'd2,  // press registered; ignore until release\n        S_DEBOUNCE_RELEASE= 2'd3   // verifying stable release (no key)\n    } state_e;\n\n    state_e state, state_n;\n\n    // Candidate key being evaluated during press debounce\n    logic [3:0] cand_code, cand_code_n;\n\n    // Counters for press / release stability (count sample_tick edges)\n    localparam int PW = (PRESS_STABLE_SAMPLES   &gt; 1) ? $clog2(PRESS_STABLE_SAMPLES  ) : 1;\n    localparam int RW = (RELEASE_STABLE_SAMPLES &gt; 1) ? $clog2(RELEASE_STABLE_SAMPLES) : 1;\n\n    logic [PW-1:0] press_cnt,   press_cnt_n;\n    logic [RW-1:0] release_cnt, release_cnt_n;\n\n    // Outputs (registered)\n    logic       new_key_pulse_n;\n    logic [3:0] key_code_out_n;\n    logic       busy_n;\n\n    // ============================== Next-state ==============================\n    always_comb begin\n        // Defaults: hold state/regs, clear pulse\n        state_n         = state;\n        cand_code_n     = cand_code;\n        press_cnt_n     = press_cnt;\n        release_cnt_n   = release_cnt;\n        new_key_pulse_n = 1'b0;\n        key_code_out_n  = key_code_out;\n        busy_n          = 1'b0;\n\n        unique case (state)\n            // -------- No key; watch for a candidate press --------\n            S_IDLE: begin\n                if (key_down && sample_tick) begin\n                    // Start debouncing a specific code\n                    cand_code_n = key_code_in;\n                    press_cnt_n = (PRESS_STABLE_SAMPLES &gt; 1) ? '0 : press_cnt; // not used if 1\n                    state_n     = (PRESS_STABLE_SAMPLES &gt; 1) ? S_DEBOUNCE_PRESS : S_HELD;\n                    if (PRESS_STABLE_SAMPLES == 1) begin\n                        // Immediate registration (edge users may set this)\n                        new_key_pulse_n = 1'b1;\n                        key_code_out_n  = key_code_in;\n                    end\n                end\n            end\n\n            // -------- Require N consecutive samples of same code --------\n            S_DEBOUNCE_PRESS: begin\n                busy_n = 1'b1;\n                if (sample_tick) begin\n                    if (!key_down) begin\n                        // Bounce back to idle if key vanished\n                        state_n     = S_IDLE;\n                        press_cnt_n = '0;\n                    end else if (key_code_in != cand_code) begin\n                        // Different code appeared during debounce -&gt; restart with new candidate\n                        cand_code_n = key_code_in;\n                        press_cnt_n = '0;\n                    end else begin\n                        // Same code still present -&gt; advance count\n                        if (press_cnt == PRESS_STABLE_SAMPLES-1) begin\n                            // Confirmed: register once and move to HELD\n                            new_key_pulse_n = 1'b1;\n                            key_code_out_n  = cand_code;\n                            state_n         = S_HELD;\n                        end else begin\n                            press_cnt_n = press_cnt + 1'b1;\n                        end\n                    end\n                end\n            end\n\n            // -------- Key is considered down; ignore further presses --------\n            S_HELD: begin\n                busy_n = 1'b1;\n                if (sample_tick && !key_down) begin\n                    // Start verifying stable release\n                    release_cnt_n = (RELEASE_STABLE_SAMPLES &gt; 1) ? '0 : release_cnt;\n                    state_n       = (RELEASE_STABLE_SAMPLES &gt; 1) ? S_DEBOUNCE_RELEASE : S_IDLE;\n                end\n            end\n\n            // -------- Require N consecutive samples of \"no key\" --------\n            S_DEBOUNCE_RELEASE: begin\n                busy_n = 1'b1;\n                if (sample_tick) begin\n                    if (key_down) begin\n                        // Key returned (bounce) -&gt; still held\n                        state_n       = S_HELD;\n                        release_cnt_n = '0;\n                    end else begin\n                        if (release_cnt == RELEASE_STABLE_SAMPLES-1) begin\n                            state_n       = S_IDLE;\n                            release_cnt_n = '0;\n                        end else begin\n                            release_cnt_n = release_cnt + 1'b1;\n                        end\n                    end\n                end\n            end\n\n            default: begin\n                state_n = S_IDLE;\n            end\n        endcase\n    end\n\n    // =============================== Registers ==============================\n    always_ff @(posedge clk) begin\n        if (rst) begin\n            state         &lt;= S_IDLE;\n            cand_code     &lt;= '0;\n            press_cnt     &lt;= '0;\n            release_cnt   &lt;= '0;\n            new_key_pulse &lt;= 1'b0;\n            key_code_out  &lt;= '0;\n            busy          &lt;= 1'b0;\n        end else begin\n            state         &lt;= state_n;\n            cand_code     &lt;= cand_code_n;\n            press_cnt     &lt;= press_cnt_n;\n            release_cnt   &lt;= release_cnt_n;\n            new_key_pulse &lt;= new_key_pulse_n; // 1-cycle pulse\n            key_code_out  &lt;= key_code_out_n;\n            busy          &lt;= busy_n;\n        end\n    end\n\nendmodule\n\n\n\n//------------------------------------------------------------------------------\n// 4x4 Keypad Column Scanner (active-low columns, active-low rows)\n// - Cycles columns using a provided scan_tick (derived from a divided clock).\n// - Samples rows after driving a column (DRIVE -&gt; SAMPLE).\n// - Debounces both press and release, reports ONE stable key while held.\n// - key_code_out remains constant and key_down=1 while the held key stays pressed.\n//------------------------------------------------------------------------------\nmodule keypad_scan_4x4 #(\n    // Debounce intervals expressed in *column visits* (samples).\n    // Choose small values with a scan_tick ~100–600 Hz (per column).\n    parameter int PRESS_STABLE_SAMPLES   = 2,\n    parameter int RELEASE_STABLE_SAMPLES = 2\n)(\n    input  logic       clk,\n    input  logic       rst,          // synchronous active-high reset\n\n    // Advance the scanner one micro-step (DRIVE -&gt; SAMPLE -&gt; next column -&gt; ...).\n    // Typical: scan_tick at ~150–600 Hz (per column).\n    input  logic       scan_tick,\n\n    // Matrix I/O (active-low)\n    input  logic [3:0] rows_n,       // from keypad rows (external pull-ups recommended)\n    output logic [3:0] cols_n,       // to keypad columns (drive ONE low at a time)\n\n    // Outputs\n    output logic       key_down,     // 1 while a debounced key is held\n    output logic [3:0] key_code_out  // stable hex code for the held key\n);\n\n    // ----------------------------- Utilities ------------------------------\n    // Encode the first active-low row (priority 0&gt;1&gt;2&gt;3)\n    function automatic logic [1:0] encode_row(input logic [3:0] r_n);\n        if (!r_n[0])      return 2'd0;\n        else if (!r_n[1]) return 2'd1;\n        else if (!r_n[2]) return 2'd2;\n        else              return 2'd3;\n    endfunction\n\n    // LUT: (row, col) -&gt; hex (1..D, with *→E, 0→0, #→F)\n    function automatic logic [3:0] lut_hex(input logic [1:0] r, input logic [1:0] c);\n        unique case ({r,c})\n            // row 0\n            {2'd0,2'd0}: return 4'h1; {2'd0,2'd1}: return 4'h2; {2'd0,2'd2}: return 4'h3; {2'd0,2'd3}: return 4'hA;\n            // row 1\n            {2'd1,2'd0}: return 4'h4; {2'd1,2'd1}: return 4'h5; {2'd1,2'd2}: return 4'h6; {2'd1,2'd3}: return 4'hB;\n            // row 2\n            {2'd2,2'd0}: return 4'h7; {2'd2,2'd1}: return 4'h8; {2'd2,2'd2}: return 4'h9; {2'd2,2'd3}: return 4'hC;\n            // row 3\n            {2'd3,2'd0}: return 4'hE; // '*'\n            {2'd3,2'd1}: return 4'h0; // '0'\n            {2'd3,2'd2}: return 4'hF; // '#'\n            {2'd3,2'd3}: return 4'hD; // 'D'\n            default:                  return 4'h0;\n        endcase\n    endfunction\n\n    // --------------------- Row synchronizers (active-low) ------------------\n    logic [3:0] rows_meta, rows_sync_n;\n    always_ff @(posedge clk) begin\n        rows_meta   &lt;= rows_n;\n        rows_sync_n &lt;= rows_meta;\n    end\n\n    // ------------------------- Column sequencer ---------------------------\n    typedef enum logic [1:0] { PH_DRIVE=2'd0, PH_SAMPLE=2'd1 } phase_e;\n    phase_e phase, phase_n;\n\n    logic [1:0] col_idx, col_idx_n;\n\n    // Drive exactly one column low (others high)\n    always_comb begin\n        cols_n = 4'b1111;\n        cols_n[col_idx] = 1'b0;\n    end\n\n    // ----------------------------- Scanner FSM ----------------------------\n    typedef enum logic [1:0] {\n        S_IDLE = 2'd0,          // no key held; searching\n        S_DEB_PRESS = 2'd1,     // verifying stable press of candidate (row,col)\n        S_HELD = 2'd2           // key held; verify release\n    } state_e;\n    state_e state, state_n;\n\n    // Candidate / held key (row/col indices)\n    logic [1:0] cand_row, cand_col, cand_row_n, cand_col_n;\n    logic [1:0] held_row, held_col, held_row_n, held_col_n;\n\n    // Debounce counters (count column visits when relevant)\n    localparam int PW = (PRESS_STABLE_SAMPLES   &gt; 1) ? $clog2(PRESS_STABLE_SAMPLES  ) : 1;\n    localparam int RW = (RELEASE_STABLE_SAMPLES &gt; 1) ? $clog2(RELEASE_STABLE_SAMPLES) : 1;\n\n    logic [PW-1:0] press_cnt,   press_cnt_n;\n    logic [RW-1:0] release_cnt, release_cnt_n;\n\n    // Registered outputs\n    logic       key_down_n;\n    logic [3:0] key_code_out_n;\n\n    // Helper: any row active during SAMPLE\n    logic any_row_active;\n    assign any_row_active = (rows_sync_n != 4'b1111);\n\n    // ---------------------------- Next-state ------------------------------\n    always_comb begin\n        // Hold defaults\n        phase_n        = phase;\n        col_idx_n      = col_idx;\n\n        state_n        = state;\n        cand_row_n     = cand_row;\n        cand_col_n     = cand_col;\n        held_row_n     = held_row;\n        held_col_n     = held_col;\n\n        press_cnt_n    = press_cnt;\n        release_cnt_n  = release_cnt;\n\n        key_down_n     = key_down;\n        key_code_out_n = key_code_out;\n\n        // Phase machine: DRIVE -&gt; SAMPLE on tick; after SAMPLE, advance column.\n        if (scan_tick) begin\n            unique case (phase)\n                PH_DRIVE:  phase_n = PH_SAMPLE;\n                PH_SAMPLE: begin\n                    phase_n   = PH_DRIVE;\n                    col_idx_n = col_idx + 2'd1;\n                end\n                default: phase_n = PH_DRIVE;\n            endcase\n        end\n\n        // Scanner behavior only acts in SAMPLE phase (rows valid after DRIVE)\n        unique case (state)\n            // ------------------------- No key held -------------------------\n            S_IDLE: begin\n                key_down_n = 1'b0;\n                if (phase == PH_SAMPLE && scan_tick) begin\n                    if (any_row_active) begin\n                        cand_row_n  = encode_row(rows_sync_n);\n                        cand_col_n  = col_idx;\n                        press_cnt_n = (PRESS_STABLE_SAMPLES &gt; 1) ? '0 : press_cnt;\n\n                        if (PRESS_STABLE_SAMPLES == 1) begin\n                            // Immediate acceptance\n                            held_row_n     = cand_row_n;\n                            held_col_n     = cand_col_n;\n                            key_code_out_n = lut_hex(cand_row_n, cand_col_n);\n                            key_down_n     = 1'b1;\n                            state_n        = S_HELD;\n                        end else begin\n                            state_n = S_DEB_PRESS;\n                        end\n                    end\n                end\n            end\n\n            // --------- Require N visits to the SAME (row,col) candidate ----\n            S_DEB_PRESS: begin\n                key_down_n = 1'b0;\n                if (phase == PH_SAMPLE && scan_tick) begin\n                    if (!any_row_active) begin\n                        // Key disappeared -&gt; abandon\n                        press_cnt_n = '0;\n                        state_n     = S_IDLE;\n                    end else begin\n                        logic [1:0] this_row = encode_row(rows_sync_n);\n                        if (this_row == cand_row && col_idx == cand_col) begin\n                            // Same candidate observed again\n                            if (press_cnt == PRESS_STABLE_SAMPLES-1) begin\n                                held_row_n     = cand_row;\n                                held_col_n     = cand_col;\n                                key_code_out_n = lut_hex(cand_row, cand_col);\n                                key_down_n     = 1'b1;\n                                state_n        = S_HELD;\n                            end else begin\n                                press_cnt_n = press_cnt + 1'b1;\n                            end\n                        end else begin\n                            // Different key (or different column) -&gt; restart candidate\n                            cand_row_n  = this_row;\n                            cand_col_n  = col_idx;\n                            press_cnt_n = '0;\n                        end\n                    end\n                end\n            end\n\n            // ------------------------ Key is held --------------------------\n            S_HELD: begin\n                key_down_n = 1'b1;\n                if (phase == PH_SAMPLE && scan_tick) begin\n                    // Only evaluate release when we are sampling the held column\n                    if (col_idx == held_col) begin\n                        if (rows_sync_n[held_row] == 1'b1) begin\n                            // The held row is HIGH (inactive) on its column -&gt; count release\n                            if (RELEASE_STABLE_SAMPLES == 1) begin\n                                key_down_n    = 1'b0;\n                                release_cnt_n = '0;\n                                state_n       = S_IDLE;\n                            end else if (release_cnt == RELEASE_STABLE_SAMPLES-1) {\n                                key_down_n    = 1'b0;\n                                release_cnt_n = '0;\n                                state_n       = S_IDLE;\n                            end else begin\n                                release_cnt_n = release_cnt + 1'b1;\n                            end\n                        end else begin\n                            // Still pressed\n                            release_cnt_n = '0;\n                        end\n                    end\n                end\n            end\n\n            default: state_n = S_IDLE;\n        endcase\n    end\n\n    // ------------------------------ Registers -----------------------------\n    always_ff @(posedge clk) begin\n        if (rst) begin\n            phase         &lt;= PH_DRIVE;\n            col_idx       &lt;= 2'd0;\n\n            state         &lt;= S_IDLE;\n            cand_row      &lt;= '0;\n            cand_col      &lt;= '0;\n            held_row      &lt;= '0;\n            held_col      &lt;= '0;\n\n            press_cnt     &lt;= '0;\n            release_cnt   &lt;= '0;\n\n            key_down      &lt;= 1'b0;\n            key_code_out  &lt;= 4'h0;\n        end else begin\n            phase         &lt;= phase_n;\n            col_idx       &lt;= col_idx_n;\n\n            state         &lt;= state_n;\n            cand_row      &lt;= cand_row_n;\n            cand_col      &lt;= cand_col_n;\n            held_row      &lt;= held_row_n;\n            held_col      &lt;= held_col_n;\n\n            press_cnt     &lt;= press_cnt_n;\n            release_cnt   &lt;= release_cnt_n;\n\n            key_down      &lt;= key_down_n;\n            key_code_out  &lt;= key_code_out_n;\n        end\n    end\n\nendmodule\n\n//------------------------------------------------------------------------------\n// Top: 4x4 Keypad -&gt; Dual 7-seg (last two keys)\n// Target: Lattice iCE40 UP5K (internal HFOSC as root clock)\n//------------------------------------------------------------------------------\n\n// ------------------------------ Tick Divider -------------------------------\nmodule ce_divider #(\n    parameter int DIVISOR = 20_000  // Fclk / DIVISOR = enable rate (Hz if Fclk in Hz)\n) (\n    input  logic clk,\n    input  logic rst,     // synchronous active-high\n    output logic ce       // 1-cycle clock-enable pulse\n);\n    localparam int W = (DIVISOR &lt;= 1) ? 1 : $clog2(DIVISOR);\n    logic [W-1:0] cnt;\n\n    always_ff @(posedge clk) begin\n        if (rst) begin\n            cnt &lt;= '0;\n            ce  &lt;= 1'b0;\n        end else begin\n            if (cnt == DIVISOR-1) begin\n                cnt &lt;= '0;\n                ce  &lt;= 1'b1;\n            end else begin\n                cnt &lt;= cnt + 1'b1;\n                ce  &lt;= 1'b0;\n            end\n        end\n    end\nendmodule\n\n// ------------------------------ Top-level ----------------------------------\nmodule top_keypad_two7seg #(\n    // Nominal HFOSC frequency (adjust if you measure differently)\n    parameter int F_HZ                 = 20_000_000,\n\n    // Display timing: 2 kHz total refresh -&gt; 1 kHz per digit (no flicker)\n    parameter int REFRESH_HZ_TOTAL     = 2_000,\n\n    // Keypad scan: column step rate (per column). 200 Hz is safe/balanced.\n    parameter int SCAN_HZ_PER_COLUMN   = 200,\n\n    // Display polarity (set to 0 if your board is active-high)\n    parameter bit SEG_ACTIVE_LOW       = 1,  // segments a..g\n    parameter bit DIGIT_ACTIVE_LOW     = 1   // digit enables [left,right]\n) (\n    input  logic       rst_n,         // active-low reset\n    // Keypad matrix (active-low)\n    input  logic [3:0] rows_n,        // from keypad (pull-ups recommended)\n    output logic [3:0] cols_n,        // to keypad (one low at a time)\n    // 7-segment outputs\n    output logic [6:0] seg,           // a..g\n    output logic [1:0] dig_en         // [0]=left, [1]=right\n);\n    // ----------------------- Clock: iCE40 HFOSC -----------------------\n    logic clk;\n    SB_HFOSC #(.CLKHF_DIV(\"0b00\")) u_hfosc (  // see note below on freq\n        .CLKHFEN(1'b1),\n        .CLKHFPU(1'b1),\n        .CLKHF  (clk)\n    );\n    logic rst = ~rst_n;\n\n    // NOTE: HFOSC exact frequency depends on CLKHF_DIV; if your build yields\n    // ~24/48 MHz, set F_HZ accordingly or tweak divisors below.\n\n    // ------------------------ Clock-Enable ticks -----------------------\n    localparam int REFRESH_DIV  = (F_HZ / REFRESH_HZ_TOTAL);\n    localparam int SCAN_DIV     = (F_HZ / SCAN_HZ_PER_COLUMN);\n\n    logic refresh_tick, scan_tick;\n    ce_divider #(.DIVISOR(REFRESH_DIV)) u_refdiv (.clk(clk), .rst(rst), .ce(refresh_tick));\n    ce_divider #(.DIVISOR(SCAN_DIV   )) u_scndiv (.clk(clk), .rst(rst), .ce(scan_tick));\n\n    // --------------------- Keypad scan + one-shot ----------------------\n    logic       scan_key_down;\n    logic [3:0] scan_key_code;\n\n    // Scanner: cycles columns on scan_tick, debounces/holds one key\n    keypad_scan_4x4 #(\n        .PRESS_STABLE_SAMPLES  (2),\n        .RELEASE_STABLE_SAMPLES(2)\n    ) u_scan (\n        .clk         (clk),\n        .rst         (rst),\n        .scan_tick   (scan_tick),\n        .rows_n      (rows_n),\n        .cols_n      (cols_n),\n        .key_down    (scan_key_down),\n        .key_code_out(scan_key_code)\n    );\n\n    // One-shot: generate 1-cycle pulse when a new key is registered\n    // Scanner already debounces, so set samples=1 here (edge detect on held state)\n    logic       new_key_pulse;\n    logic [3:0] new_key_code;\n\n    key_one_shot #(\n        .PRESS_STABLE_SAMPLES  (1),\n        .RELEASE_STABLE_SAMPLES(1)\n    ) u_oneshot (\n        .clk          (clk),\n        .rst          (rst),\n        .sample_tick  (scan_tick),     // align with scanner cadence\n        .key_down     (scan_key_down),\n        .key_code_in  (scan_key_code),\n        .new_key_pulse(new_key_pulse),\n        .key_code_out (new_key_code),\n        .busy         (/* unused */)\n    );\n\n    // --------------------- Two-digit key history -----------------------\n    // Shift only on *new* key registration:\n    //   left  &lt;- previous right (older)\n    //   right &lt;- new key       (most recent)\n    logic [3:0] hex_left, hex_right;\n\n    always_ff @(posedge clk) begin\n        if (rst) begin\n            hex_left  &lt;= 4'h0;\n            hex_right &lt;= 4'h0;\n        end else if (new_key_pulse) begin\n            hex_left  &lt;= hex_right;\n            hex_right &lt;= new_key_code;\n        end\n    end\n\n    // --------------------- 7-seg decode (assumed provided) --------------\n    // sevenSegment: hex[3:0] -&gt; seg[6:0] (a..g). Assume active-low segments.\n    logic [6:0] seg_left, seg_right;\n    sevenSegment u_dec_left  (.hex(hex_left ), .seg(seg_left ));\n    sevenSegment u_dec_right (.hex(hex_right), .seg(seg_right));\n\n    // --------------------- Time-multiplex display -----------------------\n    // Toggle selected digit at REFRESH_HZ_TOTAL -&gt; 1 kHz per digit\n    logic sel; // 0 = left, 1 = right\n\n    always_ff @(posedge clk) begin\n        if (rst) sel &lt;= 1'b0;\n        else if (refresh_tick) sel &lt;= ~sel;\n    end\n\n    // Segment mux\n    logic [6:0] seg_mux = (sel == 1'b0) ? seg_left : seg_right;\n\n    // Apply polarities (segments and digit enables)\n    always_comb begin\n        // segments\n        seg = SEG_ACTIVE_LOW ? seg_mux : ~seg_mux;\n\n        // digit enables: one on, one off\n        logic [1:0] en_raw;\n        // Active-low encoding for common-anode:\n        // sel=0 -&gt; left on (0), right off (1) =&gt; 2'b10 (dig_en[0]=left, [1]=right)\n        // sel=1 -&gt; left off (1), right on (0) =&gt; 2'b01\n        en_raw = (sel == 1'b0) ? 2'b10 : 2'b01;\n\n        dig_en = DIGIT_ACTIVE_LOW ? en_raw : ~en_raw;\n    end\n\nendmodule\nThe second prompt also had syntax errors, which when I fed back into AI, it told me what could possible cause them. The descriptions were good, but it was still a bit hard to parse through because I didn’t understand the a lot of the syntax used in the AI code. Still, it was interesting (and a little dishreatening) to see it generate all the code and logic which took me many hours to come up with."
  },
  {
    "objectID": "labs/lab3/lab3.html#lab-3-keypad-scanner",
    "href": "labs/lab3/lab3.html#lab-3-keypad-scanner",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, we learned how to use the FPGA to scan inputs from a 4x4 keypad. The multiplexed display from lab 2 was combined with a keypad to display user inputs. A scanning system was designed to read the inputs from keypad scanner, and a method for switch debouncing was also implemented. This lab required carefuly, thought-outTsynchronous sequential design\n\n\n\nOne of the biggest design considerations was the scanner FSM. I went through many iterations, but in order to meet all of the specifications of the lab, ended up going with the following design:\n\n\n\nFigure 1. Scanner FSM\n\n\nAs shown in figure 1, the scanner FSM has one state for each column, and one for each row within each column. Given a row input, the FSM should transition from the column state to the state corresponding to the row input. If no rows are pressed, you transition to the next column and repeat the process. My FSM was originally simpler, but in order to account for edge cases in button pressing, I decided to make each row a distinct state.\nThe next big design consideration was debouncer FSM. One important consideration when working with the keypad matrix is switch bouncing. When a button is pressed, the input may take some time to settle. In order to not register the “bouncing” as multiple presses, a method for switch debouncing has to be implemented. I did this using another FSM, which interacts with my scanner FSM and the rest of my modules.\n\n\n\nFigure 2. Debouncer FSM\n\n\nAs shown in figure 2, the debouncer module has four states. The first state is idle, and as soon as a row press is detected, you transition to the second state, which is where debouncing happens. I implemented the debouncing using a counter. I chose an arbitrary debounce time of 50 ms, as I believed the key would stabilitize after that time. Since the debouncer operates on the slow clock (at 183 Hz), I determined the number of cycles the counter needed to iterate by multiplying the clock frequency by the debouncing time, which gave me a number of ~10. Therefore, as soon as the counter reaches 10, you transition to the next stage, in which a pulse is sent out. You turn the pulse off in the final stage, and go back to the idle state. This pulse allows for regulation of decoding, maintaining it to only happen after the debouncing is complete.\nAfter designing the FSMs and all the interacting modules (explained in block diagram section below), I wired up the keypad. Seeing as our design was active high, I used pull down resistors for the rows. The picture of the wired circuit is shown below in figure 3.\n\n\n\nFigure 3. Physical Circuit and Setup\n\n\nIn order to test the system, I wrote some test benches for the more crucial modules and tested the keypad physically for all edge cases.\n\n\n\nThe source code for the project can be found in the associated Github repository.\n\n\nThe block diagram for my system is shown below in figure 4.\n\n\n\nFigure 4. System block diagram\n\n\nThe high speed oscillator lives in the top level module, and a slowClock module after it divides the high speed 48MHz clock into a slower 183Hz clock, which is used by the rest of the system. Following this, a scanner module takes in the row input and powers the column. It also sends out the 8-bit keyValue, which contains information about the row and column pressed. This module also outputs whether or not a row is pressed, which is used by the debouncer to debounce the press. The debouncer module outputs a pulse once debouncing is complete. Once the segDriver module receives a pulse, it takes the keyValue and decodes it into a four bit input. This module also shifts the old digit to the left, and puts the new digit on the right. These are sent to the switcher, which sends power to the seven segment (using enables) at the same frequency. The seven segment module then dipays the numbers.\n\n\n\nThe schematic for the system is shown below in figure 5. It includes the FPGA, the dual seven segment, and the keypad.\n\n\n\nFigure 5. System Schematic\n\n\n\n\n\n\nThe design meets all of the proficiency specs. It registers key presses, and moves old key presses to the left and puts new key presses on the right. All the LEDs are equally bright. The design also doesn’t lock up when multiple keys are pressed.\nThroughout the lab, there were multiple bugs I resolved. I spent a long time finalizing the design of the FSMs and figuring out how to implement the debouncing logic. After quickly writing up the System Verilog, I uploaded my code and noticed that there were two 0s being displayed but no presses were being registered. This was the biggest bug, and was solved with a lot of simulation, checking the code to decode keyValue, and dealing with clock issues.\nI originally had a smaller FSM, but changed it to account for every row case so that when one key is pressed, and a second is also pressed in the same column at the same time, when you let go of the original key, the second key registers. I still have some issues that I am debugging. For example, for the two rightmost columns, when I press one key and press another, it registers the press even though the other is held down. This only happens for the two rightmost columns. I also was not able to implement a synchronizer successfully.\n\n\n\nDespite the small issues discussed above, my FPGA design was successfully able to scan inputs from a 4x4 keypad and debounce all the keys. In total, I spent about 60 hours on this lab.\n\n\n\nFor this week’s AI prototype, I tested two prompts. Here was prompt A:\nTarget device: Lattice iCE40 UP5K FPGA with internal high-speed oscillator (~20 MHz).\nWrite synthesizable SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7‑segment display. Implement: A clock divider that derives a scan clock on the order of 100–200 Hz from the internal oscillator. A keypad scanning controller that iterates one active‑low column at a time and samples active‑low rows, registering at most one key per press (debounce‑by‑design), ignoring additional presses while any key is held, and allowing a new registration only after release. A top level that updates two hex digits (older and most recent) when a new key is registered and drives a time‑multiplexed two‑digit 7‑segment display without visible flicker and with balanced brightness. Use idiomatic SystemVerilog (e.g., logic, always_ff, enumerated states for FSMs). Provide clean module boundaries and keep all state synchronous. Include brief comments explaining the design choices.\nHere was the code it produced:\nCode:\n// Generates a single-cycle tick at a programmable rate from a faster clk.\n// Example: With 20 MHz clk, DIV=100_000 -&gt; 200 Hz tick.\nmodule clock_divider_tick #(\n    parameter int unsigned DIV = 100_000  // cycles per tick\n) (\n    input  logic clk,\n    input  logic reset_n,   // active-low synchronous reset\n    output logic tick       // 1-cycle pulse every DIV cycles\n);\n    localparam int W = $clog2(DIV);\n    logic [W-1:0] cnt;\n\n    always_ff @(posedge clk) begin\n        if (!reset_n) begin\n            cnt  &lt;= '0;\n            tick &lt;= 1'b0;\n        end else begin\n            if (cnt == DIV-1) begin\n                cnt  &lt;= '0;\n                tick &lt;= 1'b1;\n            end else begin\n                cnt  &lt;= cnt + 1'b1;\n                tick &lt;= 1'b0;\n            end\n        end\n    end\nendmodule\n\n\n// Two-flop synchronizer (vector-capable)\nmodule sync2 #(\n    parameter int W = 1\n) (\n    input  logic        clk,\n    input  logic        reset_n,\n    input  logic [W-1:0] d_async,\n    output logic [W-1:0] q_sync\n);\n    logic [W-1:0] s1;\n\n    always_ff @(posedge clk) begin\n        if (!reset_n) begin\n            s1     &lt;= '1;     // rows are pulled-up; safe default high (no key)\n            q_sync &lt;= '1;\n        end else begin\n            s1     &lt;= d_async;\n            q_sync &lt;= s1;\n        end\n    end\nendmodule\n\n\n// 4x4 matrix scanner (active-LOW rows/cols).\n// Debounce-by-design: registers at most one key per press. While any key\n// is held (across scan frames), further presses are ignored until release.\nmodule keypad_scanner_4x4 #(\n    // If your hardware uses different polarities, adjust here.\n    parameter bit ROW_ACTIVE_LOW = 1,\n    parameter bit COL_ACTIVE_LOW = 1\n) (\n    input  logic       clk,          // system clock (~20 MHz)\n    input  logic       reset_n,      // active-low sync reset\n    input  logic       scan_tick,    // ~100–200 Hz\n    input  logic [3:0] rows_in_sync, // synchronized rows\n    output logic [3:0] cols_out,     // driven to select 1 col at a time\n    output logic [3:0] key_code,     // hex 0..F per keypad mapping\n    output logic       key_pulse     // 1-cycle pulse when a new key is registered\n);\n    // FSM cycles columns; on each scan_tick select next column and sample rows.\n    typedef enum logic [1:0] {S_COL0, S_COL1, S_COL2, S_COL3} col_state_e;\n    col_state_e state, state_n;\n\n    logic [3:0] col_sel;   // one-hot (bit=1 means \"selected\" column)\n    logic [3:0] rows_smpl; // sampled (normalized active-high \"pressed\")\n    logic       any_pressed;\n    logic       latched_busy; // set after registering a key, cleared on full release\n\n    // Column drive: one column active at a time\n    always_comb begin\n        unique case (state)\n            S_COL0: col_sel = 4'b0001;\n            S_COL1: col_sel = 4'b0010;\n            S_COL2: col_sel = 4'b0100;\n            default: col_sel = 4'b1000;\n        endcase\n    end\n\n    // Active-LOW/active-HIGH drive for columns\n    always_comb begin\n        if (COL_ACTIVE_LOW) begin\n            // Selected column driven LOW (0), others HIGH (1)\n            cols_out = ~col_sel;\n        end else begin\n            cols_out = col_sel;\n        end\n    end\n\n    // Normalize rows: rows_norm=1 means \"pressed in current column\"\n    logic [3:0] rows_norm;\n    always_comb begin\n        if (ROW_ACTIVE_LOW) rows_norm = ~rows_in_sync;\n        else                rows_norm =  rows_in_sync;\n    end\n\n    // Sample rows on each scan tick (after column has been stable a full frame)\n    always_ff @(posedge clk) begin\n        if (!reset_n) rows_smpl &lt;= '0;\n        else if (scan_tick)     rows_smpl &lt;= rows_norm;\n    end\n    assign any_pressed = |rows_smpl;\n\n    // Next column on scan_tick\n    always_comb begin\n        state_n = state;\n        if (scan_tick) begin\n            unique case (state)\n                S_COL0: state_n = S_COL1;\n                S_COL1: state_n = S_COL2;\n                S_COL2: state_n = S_COL3;\n                default: state_n = S_COL0;\n            endcase\n        end\n    end\n    always_ff @(posedge clk) begin\n        if (!reset_n) state &lt;= S_COL0;\n        else          state &lt;= state_n;\n    end\n\n    // Register at most one key per continuous press:\n    // When not busy and exactly one row asserted, emit key_pulse and capture code.\n    function automatic logic is_onehot4(input logic [3:0] v);\n        return (v != 4'b0000) && ((v & (v - 1'b1)) == 4'b0000);\n    endfunction\n\n    // Encode row/col to hex (0..F). Mapping below is typical calculator style:\n    //   Col0   Col1   Col2   Col3\n    // R0  1      2      3      A\n    // R1  4      5      6      B\n    // R2  7      8      9      C\n    // R3  E      0      F      D\n    function automatic logic [3:0] encode_hex(\n        input logic [3:0] row_onehot,\n        input logic [3:0] col_onehot\n    );\n        int r, c;\n        begin\n            // onehot -&gt; index\n            r = (row_onehot[0]) ? 0 :\n                (row_onehot[1]) ? 1 :\n                (row_onehot[2]) ? 2 : 3;\n            c = (col_onehot[0]) ? 0 :\n                (col_onehot[1]) ? 1 :\n                (col_onehot[2]) ? 2 : 3;\n            // lookup\n            unique case ({r[1:0], c[1:0]})\n                4'(0),4'(0): encode_hex = 4'h1; // r0 c0\n                default: begin end\n            endcase\n        end\n    endfunction\n\n    // The above would be clunky—use a compact LUT instead:\n    // Index = {row_idx[1:0], col_idx[1:0]}\n    function automatic logic [3:0] lut_hex(input int r, input int c);\n        logic [3:0] table [0:15];\n        begin\n            // Fill table\n            // r=0: 1,2,3,A\n            table[ 0] = 4'h1; table[ 1] = 4'h2; table[ 2] = 4'h3; table[ 3] = 4'hA;\n            // r=1: 4,5,6,B\n            table[ 4] = 4'h4; table[ 5] = 4'h5; table[ 6] = 4'h6; table[ 7] = 4'hB;\n            // r=2: 7,8,9,C\n            table[ 8] = 4'h7; table[ 9] = 4'h8; table[10] = 4'h9; table[11] = 4'hC;\n            // r=3: E,0,F,D\n            table[12] = 4'hE; table[13] = 4'h0; table[14] = 4'hF; table[15] = 4'hD;\n            lut_hex = table[(r&lt;&lt;2)|c];\n        end\n    endfunction\n\n    function automatic int onehot_to_idx(input logic [3:0] v);\n        begin\n            case (1'b1)\n                v[0]: onehot_to_idx = 0;\n                v[1]: onehot_to_idx = 1;\n                v[2]: onehot_to_idx = 2;\n                default: onehot_to_idx = 3;\n            endcase\n        end\n    endfunction\n\n    // Busy latch and key pulse generation\n    always_ff @(posedge clk) begin\n        if (!reset_n) begin\n            latched_busy &lt;= 1'b0;\n            key_pulse    &lt;= 1'b0;\n            key_code     &lt;= 4'h0;\n        end else begin\n            key_pulse &lt;= 1'b0; // default\n\n            if (!latched_busy) begin\n                // Only accept a new key when exactly one row is asserted\n                if (scan_tick && is_onehot4(rows_smpl)) begin\n                    int r = onehot_to_idx(rows_smpl);\n                    int c = onehot_to_idx(col_sel);\n                    key_code  &lt;= lut_hex(r, c);\n                    key_pulse &lt;= 1'b1;   // one-cycle pulse on system clk\n                    latched_busy &lt;= 1'b1;\n                end\n            end else begin\n                // Wait for full release (no rows asserted across columns)\n                if (!any_pressed) begin\n                    // Note: any_pressed reflects sampled rows for the current column;\n                    // With a frame-by-frame scan at ~200 Hz, \"release observed\" is sufficient.\n                    latched_busy &lt;= 1'b0;\n                end\n            end\n        end\n    end\nendmodule\n\n// Hex nibble to 7-seg segments (a..g), active-LOW output by default.\nmodule hex7seg #(\n    parameter bit ACTIVE_LOW_SEG = 1\n) (\n    input  logic [3:0] hex,\n    output logic [6:0] seg  // {a,b,c,d,e,f,g}\n);\n    logic [6:0] seg_h; // active-high internal truth table\n\n    always_comb begin\n        unique case (hex)\n            4'h0: seg_h = 7'b1111110;\n            4'h1: seg_h = 7'b0110000;\n            4'h2: seg_h = 7'b1101101;\n            4'h3: seg_h = 7'b1111001;\n            4'h4: seg_h = 7'b0110011;\n            4'h5: seg_h = 7'b1011011;\n            4'h6: seg_h = 7'b1011111;\n            4'h7: seg_h = 7'b1110000;\n            4'h8: seg_h = 7'b1111111;\n            4'h9: seg_h = 7'b1111011;\n            4'hA: seg_h = 7'b1110111;\n            4'hB: seg_h = 7'b0011111; // lower-case b\n            4'hC: seg_h = 7'b1001110;\n            4'hD: seg_h = 7'b0111101; // lower-case d\n            4'hE: seg_h = 7'b1001111;\n            default: seg_h = 7'b1000111; // F\n        endcase\n        seg = (ACTIVE_LOW_SEG) ? ~seg_h : seg_h;\n    end\nendmodule\n\n\n// Two-digit 7-seg time-multiplexer with balanced brightness.\n// refresh_tick should be ~2 kHz (so each digit ~1 kHz).\nmodule sevenseg_mux2 #(\n    parameter bit ACTIVE_LOW_SEG = 1,\n    parameter bit ACTIVE_LOW_DIG = 1\n) (\n    input  logic       clk,\n    input  logic       reset_n,\n    input  logic       refresh_tick,    // toggles active digit\n    input  logic [3:0] hex0,            // right (least recent) or \"newest\"\n    input  logic [3:0] hex1,            // left (older)\n    output logic [6:0] seg,             // a..g (dp omitted; add if needed)\n    output logic [1:0] dig_en           // [1]=left, [0]=right\n);\n    logic sel; // 0: show right, 1: show left\n    logic [3:0] nibble;\n    logic [6:0] seg_int;\n    logic [1:0] dig_h;  // active-high internal enables\n\n    always_ff @(posedge clk) begin\n        if (!reset_n) sel &lt;= 1'b0;\n        else if (refresh_tick) sel &lt;= ~sel;\n    end\n\n    always_comb begin\n        nibble = (sel) ? hex1 : hex0;\n        dig_h  = (sel) ? 2'b10 : 2'b01; // sel=1 -&gt; left on; sel=0 -&gt; right on\n    end\n\n    hex7seg #(.ACTIVE_LOW_SEG(ACTIVE_LOW_SEG)) u_hex (\n        .hex (nibble),\n        .seg (seg_int)\n    );\n\n    // Outputs with desired polarities\n    always_comb begin\n        seg   = seg_int;\n        dig_en = (ACTIVE_LOW_DIG) ? ~dig_h : dig_h;\n    end\nendmodule\n\n\n// Top-level: scans keypad and shows last two hex keys (hex1=older, hex0=most recent)\n// on a dual 7-seg display with time-multiplexing.\nmodule top_keypad_7seg #(\n    // Clocking (assume ~20 MHz HSOSC)\n    parameter int unsigned F_CLK_HZ     = 20_000_000,\n    parameter int unsigned SCAN_HZ      = 200,     // keypad scan frame rate\n    parameter int unsigned REFRESH_HZ   = 2_000,   // 2 kHz digit toggle (~1 kHz per digit)\n    // IO polarity\n    parameter bit ROW_ACTIVE_LOW = 1,\n    parameter bit COL_ACTIVE_LOW = 1,\n    parameter bit SEG_ACTIVE_LOW = 1,\n    parameter bit DIG_ACTIVE_LOW = 1\n) (\n    input  logic        clk,           // connect to HSOSC (~20 MHz)\n    input  logic        reset_n,       // active-low synchronous reset\n    // Keypad IO\n    input  logic [3:0]  rows_in,       // keypad rows (with external pull-ups or IO pull-ups)\n    output logic [3:0]  cols_out,      // keypad cols\n    // 7-seg IO\n    output logic [6:0]  seg,           // segments a..g (dp omitted)\n    output logic [1:0]  dig_en         // digit enables [1]=left, [0]=right\n);\n    // --- Ticks ---\n    localparam int unsigned DIV_SCAN    = (F_CLK_HZ / SCAN_HZ);\n    localparam int unsigned DIV_REFRESH = (F_CLK_HZ / REFRESH_HZ);\n\n    logic tick_scan, tick_refresh;\n\n    clock_divider_tick #(.DIV(DIV_SCAN)) u_div_scan (\n        .clk     (clk),\n        .reset_n (reset_n),\n        .tick    (tick_scan)\n    );\n\n    clock_divider_tick #(.DIV(DIV_REFRESH)) u_div_ref (\n        .clk     (clk),\n        .reset_n (reset_n),\n        .tick    (tick_refresh)\n    );\n\n    // --- Synchronize keypad rows ---\n    logic [3:0] rows_sync;\n    sync2 #(.W(4)) u_sync_rows (\n        .clk     (clk),\n        .reset_n (reset_n),\n        .d_async (rows_in),\n        .q_sync  (rows_sync)\n    );\n\n    // --- Scanner ---\n    logic [3:0] key_nibble;\n    logic       key_pulse;\n\n    keypad_scanner_4x4 #(\n        .ROW_ACTIVE_LOW (ROW_ACTIVE_LOW),\n        .COL_ACTIVE_LOW (COL_ACTIVE_LOW)\n    ) u_scan (\n        .clk         (clk),\n        .reset_n     (reset_n),\n        .scan_tick   (tick_scan),\n        .rows_in_sync(rows_sync),\n        .cols_out    (cols_out),\n        .key_code    (key_nibble),\n        .key_pulse   (key_pulse)\n    );\n\n    // --- Last two keys history ---\n    // hex0 = most recent, hex1 = older\n    logic [3:0] hex0, hex1;\n\n    always_ff @(posedge clk) begin\n        if (!reset_n) begin\n            hex0 &lt;= 4'h0;\n            hex1 &lt;= 4'h0;\n        end else if (key_pulse) begin\n            hex1 &lt;= hex0;\n            hex0 &lt;= key_nibble;\n        end\n    end\n\n    // --- 7-seg MUX ---\n    sevenseg_mux2 #(\n        .ACTIVE_LOW_SEG (SEG_ACTIVE_LOW),\n        .ACTIVE_LOW_DIG (DIG_ACTIVE_LOW)\n    ) u_mux (\n        .clk          (clk),\n        .reset_n      (reset_n),\n        .refresh_tick (tick_refresh),\n        .hex0         (hex0),  // show most recent on right\n        .hex1         (hex1),  // older on left\n        .seg          (seg),\n        .dig_en       (dig_en)\n    );\nendmodule\nThis is the code AI generated. It gave me a syntax error, and when I tried to give the error to AI, it told me that I have to declare the return type differently. I didn’t fully understand the error or the code, because it used high-level functions.\nPrompt B had three modular prompts: one for the one-shot registration (to debounce by design), one for keypad scanner controller, and one for integrate and display. Here is the code it produced:\n\n//------------------------------------------------------------------------------\n// Key One-Shot Registrar for 4x4 Keypad Scanners\n// - Assert new_key_pulse for 1 clk when a *new, debounced* press is detected\n// - Latch key_code_out at that instant\n// - Block further registrations until *full, debounced* release\n// - Debounce windows expressed in \"samples\" (e.g., column-scan ticks)\n//------------------------------------------------------------------------------\nmodule key_one_shot #(\n    // Number of *consecutive* samples required to confirm a press/release.\n    // Choose small integers given a scan rate of ~100–600 Hz.\n    parameter int PRESS_STABLE_SAMPLES   = 2,\n    parameter int RELEASE_STABLE_SAMPLES = 2\n)(\n    input  logic       clk,\n    input  logic       rst,           // synchronous active-high reset\n\n    // Drive this with your keypad scanner's sampling cadence\n    // (e.g., once per full matrix read or per-column step).\n    input  logic       sample_tick,\n\n    // Current instantaneous keypad state (already synchronized to clk):\n    input  logic       key_down,      // 1 if *any* key is presently detected\n    input  logic [3:0] key_code_in,   // code for the currently-detected key\n\n    // Registration outputs:\n    output logic       new_key_pulse, // 1 clk pulse on *new* debounced press\n    output logic [3:0] key_code_out,  // latched code for that new press\n    output logic       busy           // 1 while a key is debounced/held\n);\n\n    // ============================ State machine =============================\n    typedef enum logic [1:0] {\n        S_IDLE            = 2'd0,  // no key; waiting for a candidate press\n        S_DEBOUNCE_PRESS  = 2'd1,  // verifying stable press of one code\n        S_HELD            = 2'd2,  // press registered; ignore until release\n        S_DEBOUNCE_RELEASE= 2'd3   // verifying stable release (no key)\n    } state_e;\n\n    state_e state, state_n;\n\n    // Candidate key being evaluated during press debounce\n    logic [3:0] cand_code, cand_code_n;\n\n    // Counters for press / release stability (count sample_tick edges)\n    localparam int PW = (PRESS_STABLE_SAMPLES   &gt; 1) ? $clog2(PRESS_STABLE_SAMPLES  ) : 1;\n    localparam int RW = (RELEASE_STABLE_SAMPLES &gt; 1) ? $clog2(RELEASE_STABLE_SAMPLES) : 1;\n\n    logic [PW-1:0] press_cnt,   press_cnt_n;\n    logic [RW-1:0] release_cnt, release_cnt_n;\n\n    // Outputs (registered)\n    logic       new_key_pulse_n;\n    logic [3:0] key_code_out_n;\n    logic       busy_n;\n\n    // ============================== Next-state ==============================\n    always_comb begin\n        // Defaults: hold state/regs, clear pulse\n        state_n         = state;\n        cand_code_n     = cand_code;\n        press_cnt_n     = press_cnt;\n        release_cnt_n   = release_cnt;\n        new_key_pulse_n = 1'b0;\n        key_code_out_n  = key_code_out;\n        busy_n          = 1'b0;\n\n        unique case (state)\n            // -------- No key; watch for a candidate press --------\n            S_IDLE: begin\n                if (key_down && sample_tick) begin\n                    // Start debouncing a specific code\n                    cand_code_n = key_code_in;\n                    press_cnt_n = (PRESS_STABLE_SAMPLES &gt; 1) ? '0 : press_cnt; // not used if 1\n                    state_n     = (PRESS_STABLE_SAMPLES &gt; 1) ? S_DEBOUNCE_PRESS : S_HELD;\n                    if (PRESS_STABLE_SAMPLES == 1) begin\n                        // Immediate registration (edge users may set this)\n                        new_key_pulse_n = 1'b1;\n                        key_code_out_n  = key_code_in;\n                    end\n                end\n            end\n\n            // -------- Require N consecutive samples of same code --------\n            S_DEBOUNCE_PRESS: begin\n                busy_n = 1'b1;\n                if (sample_tick) begin\n                    if (!key_down) begin\n                        // Bounce back to idle if key vanished\n                        state_n     = S_IDLE;\n                        press_cnt_n = '0;\n                    end else if (key_code_in != cand_code) begin\n                        // Different code appeared during debounce -&gt; restart with new candidate\n                        cand_code_n = key_code_in;\n                        press_cnt_n = '0;\n                    end else begin\n                        // Same code still present -&gt; advance count\n                        if (press_cnt == PRESS_STABLE_SAMPLES-1) begin\n                            // Confirmed: register once and move to HELD\n                            new_key_pulse_n = 1'b1;\n                            key_code_out_n  = cand_code;\n                            state_n         = S_HELD;\n                        end else begin\n                            press_cnt_n = press_cnt + 1'b1;\n                        end\n                    end\n                end\n            end\n\n            // -------- Key is considered down; ignore further presses --------\n            S_HELD: begin\n                busy_n = 1'b1;\n                if (sample_tick && !key_down) begin\n                    // Start verifying stable release\n                    release_cnt_n = (RELEASE_STABLE_SAMPLES &gt; 1) ? '0 : release_cnt;\n                    state_n       = (RELEASE_STABLE_SAMPLES &gt; 1) ? S_DEBOUNCE_RELEASE : S_IDLE;\n                end\n            end\n\n            // -------- Require N consecutive samples of \"no key\" --------\n            S_DEBOUNCE_RELEASE: begin\n                busy_n = 1'b1;\n                if (sample_tick) begin\n                    if (key_down) begin\n                        // Key returned (bounce) -&gt; still held\n                        state_n       = S_HELD;\n                        release_cnt_n = '0;\n                    end else begin\n                        if (release_cnt == RELEASE_STABLE_SAMPLES-1) begin\n                            state_n       = S_IDLE;\n                            release_cnt_n = '0;\n                        end else begin\n                            release_cnt_n = release_cnt + 1'b1;\n                        end\n                    end\n                end\n            end\n\n            default: begin\n                state_n = S_IDLE;\n            end\n        endcase\n    end\n\n    // =============================== Registers ==============================\n    always_ff @(posedge clk) begin\n        if (rst) begin\n            state         &lt;= S_IDLE;\n            cand_code     &lt;= '0;\n            press_cnt     &lt;= '0;\n            release_cnt   &lt;= '0;\n            new_key_pulse &lt;= 1'b0;\n            key_code_out  &lt;= '0;\n            busy          &lt;= 1'b0;\n        end else begin\n            state         &lt;= state_n;\n            cand_code     &lt;= cand_code_n;\n            press_cnt     &lt;= press_cnt_n;\n            release_cnt   &lt;= release_cnt_n;\n            new_key_pulse &lt;= new_key_pulse_n; // 1-cycle pulse\n            key_code_out  &lt;= key_code_out_n;\n            busy          &lt;= busy_n;\n        end\n    end\n\nendmodule\n\n\n\n//------------------------------------------------------------------------------\n// 4x4 Keypad Column Scanner (active-low columns, active-low rows)\n// - Cycles columns using a provided scan_tick (derived from a divided clock).\n// - Samples rows after driving a column (DRIVE -&gt; SAMPLE).\n// - Debounces both press and release, reports ONE stable key while held.\n// - key_code_out remains constant and key_down=1 while the held key stays pressed.\n//------------------------------------------------------------------------------\nmodule keypad_scan_4x4 #(\n    // Debounce intervals expressed in *column visits* (samples).\n    // Choose small values with a scan_tick ~100–600 Hz (per column).\n    parameter int PRESS_STABLE_SAMPLES   = 2,\n    parameter int RELEASE_STABLE_SAMPLES = 2\n)(\n    input  logic       clk,\n    input  logic       rst,          // synchronous active-high reset\n\n    // Advance the scanner one micro-step (DRIVE -&gt; SAMPLE -&gt; next column -&gt; ...).\n    // Typical: scan_tick at ~150–600 Hz (per column).\n    input  logic       scan_tick,\n\n    // Matrix I/O (active-low)\n    input  logic [3:0] rows_n,       // from keypad rows (external pull-ups recommended)\n    output logic [3:0] cols_n,       // to keypad columns (drive ONE low at a time)\n\n    // Outputs\n    output logic       key_down,     // 1 while a debounced key is held\n    output logic [3:0] key_code_out  // stable hex code for the held key\n);\n\n    // ----------------------------- Utilities ------------------------------\n    // Encode the first active-low row (priority 0&gt;1&gt;2&gt;3)\n    function automatic logic [1:0] encode_row(input logic [3:0] r_n);\n        if (!r_n[0])      return 2'd0;\n        else if (!r_n[1]) return 2'd1;\n        else if (!r_n[2]) return 2'd2;\n        else              return 2'd3;\n    endfunction\n\n    // LUT: (row, col) -&gt; hex (1..D, with *→E, 0→0, #→F)\n    function automatic logic [3:0] lut_hex(input logic [1:0] r, input logic [1:0] c);\n        unique case ({r,c})\n            // row 0\n            {2'd0,2'd0}: return 4'h1; {2'd0,2'd1}: return 4'h2; {2'd0,2'd2}: return 4'h3; {2'd0,2'd3}: return 4'hA;\n            // row 1\n            {2'd1,2'd0}: return 4'h4; {2'd1,2'd1}: return 4'h5; {2'd1,2'd2}: return 4'h6; {2'd1,2'd3}: return 4'hB;\n            // row 2\n            {2'd2,2'd0}: return 4'h7; {2'd2,2'd1}: return 4'h8; {2'd2,2'd2}: return 4'h9; {2'd2,2'd3}: return 4'hC;\n            // row 3\n            {2'd3,2'd0}: return 4'hE; // '*'\n            {2'd3,2'd1}: return 4'h0; // '0'\n            {2'd3,2'd2}: return 4'hF; // '#'\n            {2'd3,2'd3}: return 4'hD; // 'D'\n            default:                  return 4'h0;\n        endcase\n    endfunction\n\n    // --------------------- Row synchronizers (active-low) ------------------\n    logic [3:0] rows_meta, rows_sync_n;\n    always_ff @(posedge clk) begin\n        rows_meta   &lt;= rows_n;\n        rows_sync_n &lt;= rows_meta;\n    end\n\n    // ------------------------- Column sequencer ---------------------------\n    typedef enum logic [1:0] { PH_DRIVE=2'd0, PH_SAMPLE=2'd1 } phase_e;\n    phase_e phase, phase_n;\n\n    logic [1:0] col_idx, col_idx_n;\n\n    // Drive exactly one column low (others high)\n    always_comb begin\n        cols_n = 4'b1111;\n        cols_n[col_idx] = 1'b0;\n    end\n\n    // ----------------------------- Scanner FSM ----------------------------\n    typedef enum logic [1:0] {\n        S_IDLE = 2'd0,          // no key held; searching\n        S_DEB_PRESS = 2'd1,     // verifying stable press of candidate (row,col)\n        S_HELD = 2'd2           // key held; verify release\n    } state_e;\n    state_e state, state_n;\n\n    // Candidate / held key (row/col indices)\n    logic [1:0] cand_row, cand_col, cand_row_n, cand_col_n;\n    logic [1:0] held_row, held_col, held_row_n, held_col_n;\n\n    // Debounce counters (count column visits when relevant)\n    localparam int PW = (PRESS_STABLE_SAMPLES   &gt; 1) ? $clog2(PRESS_STABLE_SAMPLES  ) : 1;\n    localparam int RW = (RELEASE_STABLE_SAMPLES &gt; 1) ? $clog2(RELEASE_STABLE_SAMPLES) : 1;\n\n    logic [PW-1:0] press_cnt,   press_cnt_n;\n    logic [RW-1:0] release_cnt, release_cnt_n;\n\n    // Registered outputs\n    logic       key_down_n;\n    logic [3:0] key_code_out_n;\n\n    // Helper: any row active during SAMPLE\n    logic any_row_active;\n    assign any_row_active = (rows_sync_n != 4'b1111);\n\n    // ---------------------------- Next-state ------------------------------\n    always_comb begin\n        // Hold defaults\n        phase_n        = phase;\n        col_idx_n      = col_idx;\n\n        state_n        = state;\n        cand_row_n     = cand_row;\n        cand_col_n     = cand_col;\n        held_row_n     = held_row;\n        held_col_n     = held_col;\n\n        press_cnt_n    = press_cnt;\n        release_cnt_n  = release_cnt;\n\n        key_down_n     = key_down;\n        key_code_out_n = key_code_out;\n\n        // Phase machine: DRIVE -&gt; SAMPLE on tick; after SAMPLE, advance column.\n        if (scan_tick) begin\n            unique case (phase)\n                PH_DRIVE:  phase_n = PH_SAMPLE;\n                PH_SAMPLE: begin\n                    phase_n   = PH_DRIVE;\n                    col_idx_n = col_idx + 2'd1;\n                end\n                default: phase_n = PH_DRIVE;\n            endcase\n        end\n\n        // Scanner behavior only acts in SAMPLE phase (rows valid after DRIVE)\n        unique case (state)\n            // ------------------------- No key held -------------------------\n            S_IDLE: begin\n                key_down_n = 1'b0;\n                if (phase == PH_SAMPLE && scan_tick) begin\n                    if (any_row_active) begin\n                        cand_row_n  = encode_row(rows_sync_n);\n                        cand_col_n  = col_idx;\n                        press_cnt_n = (PRESS_STABLE_SAMPLES &gt; 1) ? '0 : press_cnt;\n\n                        if (PRESS_STABLE_SAMPLES == 1) begin\n                            // Immediate acceptance\n                            held_row_n     = cand_row_n;\n                            held_col_n     = cand_col_n;\n                            key_code_out_n = lut_hex(cand_row_n, cand_col_n);\n                            key_down_n     = 1'b1;\n                            state_n        = S_HELD;\n                        end else begin\n                            state_n = S_DEB_PRESS;\n                        end\n                    end\n                end\n            end\n\n            // --------- Require N visits to the SAME (row,col) candidate ----\n            S_DEB_PRESS: begin\n                key_down_n = 1'b0;\n                if (phase == PH_SAMPLE && scan_tick) begin\n                    if (!any_row_active) begin\n                        // Key disappeared -&gt; abandon\n                        press_cnt_n = '0;\n                        state_n     = S_IDLE;\n                    end else begin\n                        logic [1:0] this_row = encode_row(rows_sync_n);\n                        if (this_row == cand_row && col_idx == cand_col) begin\n                            // Same candidate observed again\n                            if (press_cnt == PRESS_STABLE_SAMPLES-1) begin\n                                held_row_n     = cand_row;\n                                held_col_n     = cand_col;\n                                key_code_out_n = lut_hex(cand_row, cand_col);\n                                key_down_n     = 1'b1;\n                                state_n        = S_HELD;\n                            end else begin\n                                press_cnt_n = press_cnt + 1'b1;\n                            end\n                        end else begin\n                            // Different key (or different column) -&gt; restart candidate\n                            cand_row_n  = this_row;\n                            cand_col_n  = col_idx;\n                            press_cnt_n = '0;\n                        end\n                    end\n                end\n            end\n\n            // ------------------------ Key is held --------------------------\n            S_HELD: begin\n                key_down_n = 1'b1;\n                if (phase == PH_SAMPLE && scan_tick) begin\n                    // Only evaluate release when we are sampling the held column\n                    if (col_idx == held_col) begin\n                        if (rows_sync_n[held_row] == 1'b1) begin\n                            // The held row is HIGH (inactive) on its column -&gt; count release\n                            if (RELEASE_STABLE_SAMPLES == 1) begin\n                                key_down_n    = 1'b0;\n                                release_cnt_n = '0;\n                                state_n       = S_IDLE;\n                            end else if (release_cnt == RELEASE_STABLE_SAMPLES-1) {\n                                key_down_n    = 1'b0;\n                                release_cnt_n = '0;\n                                state_n       = S_IDLE;\n                            end else begin\n                                release_cnt_n = release_cnt + 1'b1;\n                            end\n                        end else begin\n                            // Still pressed\n                            release_cnt_n = '0;\n                        end\n                    end\n                end\n            end\n\n            default: state_n = S_IDLE;\n        endcase\n    end\n\n    // ------------------------------ Registers -----------------------------\n    always_ff @(posedge clk) begin\n        if (rst) begin\n            phase         &lt;= PH_DRIVE;\n            col_idx       &lt;= 2'd0;\n\n            state         &lt;= S_IDLE;\n            cand_row      &lt;= '0;\n            cand_col      &lt;= '0;\n            held_row      &lt;= '0;\n            held_col      &lt;= '0;\n\n            press_cnt     &lt;= '0;\n            release_cnt   &lt;= '0;\n\n            key_down      &lt;= 1'b0;\n            key_code_out  &lt;= 4'h0;\n        end else begin\n            phase         &lt;= phase_n;\n            col_idx       &lt;= col_idx_n;\n\n            state         &lt;= state_n;\n            cand_row      &lt;= cand_row_n;\n            cand_col      &lt;= cand_col_n;\n            held_row      &lt;= held_row_n;\n            held_col      &lt;= held_col_n;\n\n            press_cnt     &lt;= press_cnt_n;\n            release_cnt   &lt;= release_cnt_n;\n\n            key_down      &lt;= key_down_n;\n            key_code_out  &lt;= key_code_out_n;\n        end\n    end\n\nendmodule\n\n//------------------------------------------------------------------------------\n// Top: 4x4 Keypad -&gt; Dual 7-seg (last two keys)\n// Target: Lattice iCE40 UP5K (internal HFOSC as root clock)\n//------------------------------------------------------------------------------\n\n// ------------------------------ Tick Divider -------------------------------\nmodule ce_divider #(\n    parameter int DIVISOR = 20_000  // Fclk / DIVISOR = enable rate (Hz if Fclk in Hz)\n) (\n    input  logic clk,\n    input  logic rst,     // synchronous active-high\n    output logic ce       // 1-cycle clock-enable pulse\n);\n    localparam int W = (DIVISOR &lt;= 1) ? 1 : $clog2(DIVISOR);\n    logic [W-1:0] cnt;\n\n    always_ff @(posedge clk) begin\n        if (rst) begin\n            cnt &lt;= '0;\n            ce  &lt;= 1'b0;\n        end else begin\n            if (cnt == DIVISOR-1) begin\n                cnt &lt;= '0;\n                ce  &lt;= 1'b1;\n            end else begin\n                cnt &lt;= cnt + 1'b1;\n                ce  &lt;= 1'b0;\n            end\n        end\n    end\nendmodule\n\n// ------------------------------ Top-level ----------------------------------\nmodule top_keypad_two7seg #(\n    // Nominal HFOSC frequency (adjust if you measure differently)\n    parameter int F_HZ                 = 20_000_000,\n\n    // Display timing: 2 kHz total refresh -&gt; 1 kHz per digit (no flicker)\n    parameter int REFRESH_HZ_TOTAL     = 2_000,\n\n    // Keypad scan: column step rate (per column). 200 Hz is safe/balanced.\n    parameter int SCAN_HZ_PER_COLUMN   = 200,\n\n    // Display polarity (set to 0 if your board is active-high)\n    parameter bit SEG_ACTIVE_LOW       = 1,  // segments a..g\n    parameter bit DIGIT_ACTIVE_LOW     = 1   // digit enables [left,right]\n) (\n    input  logic       rst_n,         // active-low reset\n    // Keypad matrix (active-low)\n    input  logic [3:0] rows_n,        // from keypad (pull-ups recommended)\n    output logic [3:0] cols_n,        // to keypad (one low at a time)\n    // 7-segment outputs\n    output logic [6:0] seg,           // a..g\n    output logic [1:0] dig_en         // [0]=left, [1]=right\n);\n    // ----------------------- Clock: iCE40 HFOSC -----------------------\n    logic clk;\n    SB_HFOSC #(.CLKHF_DIV(\"0b00\")) u_hfosc (  // see note below on freq\n        .CLKHFEN(1'b1),\n        .CLKHFPU(1'b1),\n        .CLKHF  (clk)\n    );\n    logic rst = ~rst_n;\n\n    // NOTE: HFOSC exact frequency depends on CLKHF_DIV; if your build yields\n    // ~24/48 MHz, set F_HZ accordingly or tweak divisors below.\n\n    // ------------------------ Clock-Enable ticks -----------------------\n    localparam int REFRESH_DIV  = (F_HZ / REFRESH_HZ_TOTAL);\n    localparam int SCAN_DIV     = (F_HZ / SCAN_HZ_PER_COLUMN);\n\n    logic refresh_tick, scan_tick;\n    ce_divider #(.DIVISOR(REFRESH_DIV)) u_refdiv (.clk(clk), .rst(rst), .ce(refresh_tick));\n    ce_divider #(.DIVISOR(SCAN_DIV   )) u_scndiv (.clk(clk), .rst(rst), .ce(scan_tick));\n\n    // --------------------- Keypad scan + one-shot ----------------------\n    logic       scan_key_down;\n    logic [3:0] scan_key_code;\n\n    // Scanner: cycles columns on scan_tick, debounces/holds one key\n    keypad_scan_4x4 #(\n        .PRESS_STABLE_SAMPLES  (2),\n        .RELEASE_STABLE_SAMPLES(2)\n    ) u_scan (\n        .clk         (clk),\n        .rst         (rst),\n        .scan_tick   (scan_tick),\n        .rows_n      (rows_n),\n        .cols_n      (cols_n),\n        .key_down    (scan_key_down),\n        .key_code_out(scan_key_code)\n    );\n\n    // One-shot: generate 1-cycle pulse when a new key is registered\n    // Scanner already debounces, so set samples=1 here (edge detect on held state)\n    logic       new_key_pulse;\n    logic [3:0] new_key_code;\n\n    key_one_shot #(\n        .PRESS_STABLE_SAMPLES  (1),\n        .RELEASE_STABLE_SAMPLES(1)\n    ) u_oneshot (\n        .clk          (clk),\n        .rst          (rst),\n        .sample_tick  (scan_tick),     // align with scanner cadence\n        .key_down     (scan_key_down),\n        .key_code_in  (scan_key_code),\n        .new_key_pulse(new_key_pulse),\n        .key_code_out (new_key_code),\n        .busy         (/* unused */)\n    );\n\n    // --------------------- Two-digit key history -----------------------\n    // Shift only on *new* key registration:\n    //   left  &lt;- previous right (older)\n    //   right &lt;- new key       (most recent)\n    logic [3:0] hex_left, hex_right;\n\n    always_ff @(posedge clk) begin\n        if (rst) begin\n            hex_left  &lt;= 4'h0;\n            hex_right &lt;= 4'h0;\n        end else if (new_key_pulse) begin\n            hex_left  &lt;= hex_right;\n            hex_right &lt;= new_key_code;\n        end\n    end\n\n    // --------------------- 7-seg decode (assumed provided) --------------\n    // sevenSegment: hex[3:0] -&gt; seg[6:0] (a..g). Assume active-low segments.\n    logic [6:0] seg_left, seg_right;\n    sevenSegment u_dec_left  (.hex(hex_left ), .seg(seg_left ));\n    sevenSegment u_dec_right (.hex(hex_right), .seg(seg_right));\n\n    // --------------------- Time-multiplex display -----------------------\n    // Toggle selected digit at REFRESH_HZ_TOTAL -&gt; 1 kHz per digit\n    logic sel; // 0 = left, 1 = right\n\n    always_ff @(posedge clk) begin\n        if (rst) sel &lt;= 1'b0;\n        else if (refresh_tick) sel &lt;= ~sel;\n    end\n\n    // Segment mux\n    logic [6:0] seg_mux = (sel == 1'b0) ? seg_left : seg_right;\n\n    // Apply polarities (segments and digit enables)\n    always_comb begin\n        // segments\n        seg = SEG_ACTIVE_LOW ? seg_mux : ~seg_mux;\n\n        // digit enables: one on, one off\n        logic [1:0] en_raw;\n        // Active-low encoding for common-anode:\n        // sel=0 -&gt; left on (0), right off (1) =&gt; 2'b10 (dig_en[0]=left, [1]=right)\n        // sel=1 -&gt; left off (1), right on (0) =&gt; 2'b01\n        en_raw = (sel == 1'b0) ? 2'b10 : 2'b01;\n\n        dig_en = DIGIT_ACTIVE_LOW ? en_raw : ~en_raw;\n    end\n\nendmodule\nThe second prompt also had syntax errors, which when I fed back into AI, it told me what could possible cause them. The descriptions were good, but it was still a bit hard to parse through because I didn’t understand the a lot of the syntax used in the AI code. Still, it was interesting (and a little dishreatening) to see it generate all the code and logic which took me many hours to come up with."
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, we used our MCU to determine the speed of a motor by reading from a quadrature encoder. Lab 4 helped me get familiarized with the microcontroller and working with documentation, and this time, we tackled another aspect of microcontrollers: interrupts. Using these, I was able to process real-time, fast changes and record accurate measurements.\n\n\n\n\n\nAn encoder is a sensor that converts physical motion into electrical signals. A quadrature encoder is a common type of encoder that is used to measure the relative or absolute angle of a motor. They do this with the use of a patterned disk that is attached to the motor and spins with the motor. As shown in Figure 1 below, two stationary digital sensors 90 degrees out of phase are placed to produce two square waves that are 90 degrees out of phase with each other. The encoders used in this lab use magnets and hall effect sensors to produce the square waves. Using this theory and understanding, I designed my system to take full advantage of both signals to get the highest resolution measurement of the speed of the motor.\n\n\n\nFigure 1. Diagram of quadrature encoder [Avnet Silica]\n\n\n\n\n\nIn order to check the signals from the encoder and measure the speed of the motor, I used interrupts instead of polling. Polling involves continuously checking the status of the GPIO pins to detect whether or not the encoder output changed. This means the speed of taking a measurement is dependent on the time it takes all the commmands in the while loop to execute. This is problematic because if the code in the main loop is executing of a delay is being executed, you could miss the signal coming from the GPIO pin. This can cause timing issues and lead to inaccurate motor speeds being recorded due to sampling not happening fast/accurately enough. This problem can be overrided by using interrupts. Interrupts are event-driven instead of time-driven. This means that when the interrupt goes high, the CPU jumps to that address and the main/current execution context is paused as the interrupt is executed. After it’s done, it returns back to the main code and continues where it left off. By doing this, interrupts give immediate attention to signal changes and ensure that all measurements are registered and correspond exactly to encoder changes. Some math to back up this understanding is shown below in Figure 2.\n\n\n\nFigure 2. Interrupt vs. Polling Calculations\n\n\nIn order to achieve the highest resolution measurement, I used all edges of the encoder pulses. I did this by using two interrupts, one for Encoder A and one for Encoder B. Each encoder checked for the following four cases: clockwise rising edge, counter-clockwise rising edge, clockwise falling edge, and counter-clockwise falling edge. A counter was also used, which is explained more in the next section. The main steps of the program and the function calls are shown below in the flowchart in Figure 3.\n\n\n\nFigure 3. Lab 5 Program Flowchart\n\n\n\n\n\nThe interrupt design, described above, was the main portion of the software. Another important part was incorporating the counter into the interrupt and using that to calculate velocity. As mentioned above, each interrupt had four cases. In each case, if the motion was clockwise, the counter incremented. If the motion was counter-clockwise, the counter decreased. A graphical illustration of this using the signals from the encoder are shown below in Figure 4.\n\n\n\nFigure 4. Encoder signals edges for CW and CCW rotation\n\n\nThe following equation was used to determine the speed of the motor based on the counter: velocity = counter / (PPR * 4).\n\n\n\nIn order to make sure the measured speed matches the true motor speed and direction, I calculated the theoretical speed of the motor, hooked my motor up to the oscilloscope, and checked this against the values that my code output. From the datasheet, we know that at 12 V and 408 PPR, the speed of the motor should be 2.5 revolutions per second. Connecting the motor to the oscilloscope, I saw the following output, as shown in Figure 5.\n\n\n\nFigure 5. Motor encoder signals at 12 V\n\n\nAs shown on the oscilloscope screen, the output signal has a period of 848us. Calculations are shown below in Figure 6 to derive the speed of the motor using this value.\n\n\n\nFigure 6. Speed of motor from oscilloscope\n\n\nAt this same voltage, the following speed of motor was output from my code, with each measurement being taken one second apart.\n\n\n\nFigure 7. Speed of motor from code\n\n\nAll of these calculations are close to each other. The variation between the speed of the motor from the oscilloscope and that from the code is very small, and could be due to the motor speed itself fluctuating and not spinning at the same frequency. Also, signal capture on the oscilloscope can’t be verified, so it’s hard to determine if I’m capturing at the same rate on both the oscilloscope and on my console. Give this, I’m happy with the small variation and error rate between expected and measured.\n\n\n\n\nThe source code for the project can be found in the associated Github repository.\n\n\nThe circuit from this lab was very simple, as shown in the schematic below in Figure 8. It only consisted of connecting the motor encoder to the two MCU GPIO pins and a variable DC voltage +/- Vs being applied to the positive terminal of the motor from a power supply.\n\n\n\nFigure 8. Lab 5 Schematic\n\n\n\n\n\n\nThe design met all the intended objectives. After becoming comfortable with how to use the datasheet and reference manual for the MCU, this lab went by much smoother on the software end. The biggest point of confusion was understanding interrupts conceptually, but after that was done, the lab went by pretty smoothly. The final results are shown in the video below, with speed being output once per second on the console.\n\n\n\n\nI gained even more experience with my MCU in this lab. Learning more about interrupts also taught me how to properly read and process fast changes in order to make the most accurate measurements. In total, this lab took me 9 hours to complete.\n\n\n\nThis was the prompt for ChatGPT for this lab: Write me interrupt handlers to interface with a quadrature encoder. I’m using the STM32L432KC, what pins should I connect the encoder to in order to allow it to easily trigger the interrupts?\nThis was its response and code:\n \n// quadrature_exti.c\n#include \"stm32l4xx_hal.h\"\n\n// === User options ===\n#define QUAD_REVERSE 0   // set to 1 to invert direction if needed\n\nvolatile int32_t g_encoder_pos = 0;   // 4x counts\nvolatile uint32_t g_last_edge_us = 0; // optional: for simple deglitching if desired\n\n// Forward decls\nstatic void MX_GPIO_Quad_Init(void);\n\n// Call this from your main init\nvoid Quad_Init(void) {\n    MX_GPIO_Quad_Init();\n}\n\n// --- GPIO + EXTI init for PA0/PA1 (A/B), optional PA2 (Z) ---\nstatic void MX_GPIO_Quad_Init(void)\n{\n    __HAL_RCC_GPIOA_CLK_ENABLE();\n    __HAL_RCC_SYSCFG_CLK_ENABLE();\n\n    GPIO_InitTypeDef gi = {0};\n\n    // Configure PA0 (A) and PA1 (B) as inputs with pull-ups and EXTI on both edges\n    gi.Mode  = GPIO_MODE_IT_RISING_FALLING;\n    gi.Pull  = GPIO_PULLUP;            // or PULLDOWN to match your encoder; many encoders are open-collector -&gt; use PULLUP\n    gi.Speed = GPIO_SPEED_FREQ_HIGH;\n\n    gi.Pin   = GPIO_PIN_0; HAL_GPIO_Init(GPIOA, &gi);  // A\n    gi.Pin   = GPIO_PIN_1; HAL_GPIO_Init(GPIOA, &gi);  // B\n\n    // Optional index Z on PA2\n    // gi.Pin   = GPIO_PIN_2; HAL_GPIO_Init(GPIOA, &gi);\n\n    // NVIC: each line has its own IRQ, keeps ISRs short\n    HAL_NVIC_SetPriority(EXTI0_IRQn, 3, 0);\n    HAL_NVIC_EnableIRQ(EXTI0_IRQn);\n\n    HAL_NVIC_SetPriority(EXTI1_IRQn, 3, 0);\n    HAL_NVIC_EnableIRQ(EXTI1_IRQn);\n\n    // Optional EXTI2 for index\n    // HAL_NVIC_SetPriority(EXTI2_IRQn, 3, 0);\n    // HAL_NVIC_EnableIRQ(EXTI2_IRQn);\n}\n\n// --- Direction logic helpers ---\n// If A changed: dir = (A == B) ? -1 : +1\n// If B changed: dir = (A == B) ? +1 : -1\n// (This matches a common quadrature phase; flip with QUAD_REVERSE if it’s backward.)\n\nstatic inline void quad_on_A_edge(void)\n{\n    uint8_t A = (uint8_t)HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0);\n    uint8_t B = (uint8_t)HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_1);\n    int step = (A == B) ? -1 : +1;\n#if QUAD_REVERSE\n    step = -step;\n#endif\n    g_encoder_pos += step;\n}\n\nstatic inline void quad_on_B_edge(void)\n{\n    uint8_t A = (uint8_t)HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0);\n    uint8_t B = (uint8_t)HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_1);\n    int step = (A == B) ? +1 : -1;\n#if QUAD_REVERSE\n    step = -step;\n#endif\n    g_encoder_pos += step;\n}\n\n// --- ISRs ---\nvoid EXTI0_IRQHandler(void)  // A on PA0\n{\n    if (__HAL_GPIO_EXTI_GET_IT(GPIO_PIN_0) != 0u) {\n        __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_0);\n        quad_on_A_edge();\n    }\n}\n\nvoid EXTI1_IRQHandler(void)  // B on PA1\n{\n    if (__HAL_GPIO_EXTI_GET_IT(GPIO_PIN_1) != 0u) {\n        __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_1);\n        quad_on_B_edge();\n    }\n}\n\n// Optional: index Z zeroing, both edges or rising only as you prefer\n// void EXTI2_IRQHandler(void)\n// {\n//     if (__HAL_GPIO_EXTI_GET_IT(GPIO_PIN_2) != 0u) {\n//         __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_2);\n//         g_encoder_pos = 0;  // or latch index, etc.\n//     }\n// }\nThis code did not include the libraries and was not written in a form to be properly integrated into my main code. Therefore, I gave it my libraries and code to go based off of but then, it didn’t produce original ideas."
  },
  {
    "objectID": "labs/lab5/lab5.html#lab-5-interrupts",
    "href": "labs/lab5/lab5.html#lab-5-interrupts",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, we used our MCU to determine the speed of a motor by reading from a quadrature encoder. Lab 4 helped me get familiarized with the microcontroller and working with documentation, and this time, we tackled another aspect of microcontrollers: interrupts. Using these, I was able to process real-time, fast changes and record accurate measurements.\n\n\n\n\n\nAn encoder is a sensor that converts physical motion into electrical signals. A quadrature encoder is a common type of encoder that is used to measure the relative or absolute angle of a motor. They do this with the use of a patterned disk that is attached to the motor and spins with the motor. As shown in Figure 1 below, two stationary digital sensors 90 degrees out of phase are placed to produce two square waves that are 90 degrees out of phase with each other. The encoders used in this lab use magnets and hall effect sensors to produce the square waves. Using this theory and understanding, I designed my system to take full advantage of both signals to get the highest resolution measurement of the speed of the motor.\n\n\n\nFigure 1. Diagram of quadrature encoder [Avnet Silica]\n\n\n\n\n\nIn order to check the signals from the encoder and measure the speed of the motor, I used interrupts instead of polling. Polling involves continuously checking the status of the GPIO pins to detect whether or not the encoder output changed. This means the speed of taking a measurement is dependent on the time it takes all the commmands in the while loop to execute. This is problematic because if the code in the main loop is executing of a delay is being executed, you could miss the signal coming from the GPIO pin. This can cause timing issues and lead to inaccurate motor speeds being recorded due to sampling not happening fast/accurately enough. This problem can be overrided by using interrupts. Interrupts are event-driven instead of time-driven. This means that when the interrupt goes high, the CPU jumps to that address and the main/current execution context is paused as the interrupt is executed. After it’s done, it returns back to the main code and continues where it left off. By doing this, interrupts give immediate attention to signal changes and ensure that all measurements are registered and correspond exactly to encoder changes. Some math to back up this understanding is shown below in Figure 2.\n\n\n\nFigure 2. Interrupt vs. Polling Calculations\n\n\nIn order to achieve the highest resolution measurement, I used all edges of the encoder pulses. I did this by using two interrupts, one for Encoder A and one for Encoder B. Each encoder checked for the following four cases: clockwise rising edge, counter-clockwise rising edge, clockwise falling edge, and counter-clockwise falling edge. A counter was also used, which is explained more in the next section. The main steps of the program and the function calls are shown below in the flowchart in Figure 3.\n\n\n\nFigure 3. Lab 5 Program Flowchart\n\n\n\n\n\nThe interrupt design, described above, was the main portion of the software. Another important part was incorporating the counter into the interrupt and using that to calculate velocity. As mentioned above, each interrupt had four cases. In each case, if the motion was clockwise, the counter incremented. If the motion was counter-clockwise, the counter decreased. A graphical illustration of this using the signals from the encoder are shown below in Figure 4.\n\n\n\nFigure 4. Encoder signals edges for CW and CCW rotation\n\n\nThe following equation was used to determine the speed of the motor based on the counter: velocity = counter / (PPR * 4).\n\n\n\nIn order to make sure the measured speed matches the true motor speed and direction, I calculated the theoretical speed of the motor, hooked my motor up to the oscilloscope, and checked this against the values that my code output. From the datasheet, we know that at 12 V and 408 PPR, the speed of the motor should be 2.5 revolutions per second. Connecting the motor to the oscilloscope, I saw the following output, as shown in Figure 5.\n\n\n\nFigure 5. Motor encoder signals at 12 V\n\n\nAs shown on the oscilloscope screen, the output signal has a period of 848us. Calculations are shown below in Figure 6 to derive the speed of the motor using this value.\n\n\n\nFigure 6. Speed of motor from oscilloscope\n\n\nAt this same voltage, the following speed of motor was output from my code, with each measurement being taken one second apart.\n\n\n\nFigure 7. Speed of motor from code\n\n\nAll of these calculations are close to each other. The variation between the speed of the motor from the oscilloscope and that from the code is very small, and could be due to the motor speed itself fluctuating and not spinning at the same frequency. Also, signal capture on the oscilloscope can’t be verified, so it’s hard to determine if I’m capturing at the same rate on both the oscilloscope and on my console. Give this, I’m happy with the small variation and error rate between expected and measured.\n\n\n\n\nThe source code for the project can be found in the associated Github repository.\n\n\nThe circuit from this lab was very simple, as shown in the schematic below in Figure 8. It only consisted of connecting the motor encoder to the two MCU GPIO pins and a variable DC voltage +/- Vs being applied to the positive terminal of the motor from a power supply.\n\n\n\nFigure 8. Lab 5 Schematic\n\n\n\n\n\n\nThe design met all the intended objectives. After becoming comfortable with how to use the datasheet and reference manual for the MCU, this lab went by much smoother on the software end. The biggest point of confusion was understanding interrupts conceptually, but after that was done, the lab went by pretty smoothly. The final results are shown in the video below, with speed being output once per second on the console.\n\n\n\n\nI gained even more experience with my MCU in this lab. Learning more about interrupts also taught me how to properly read and process fast changes in order to make the most accurate measurements. In total, this lab took me 9 hours to complete.\n\n\n\nThis was the prompt for ChatGPT for this lab: Write me interrupt handlers to interface with a quadrature encoder. I’m using the STM32L432KC, what pins should I connect the encoder to in order to allow it to easily trigger the interrupts?\nThis was its response and code:\n \n// quadrature_exti.c\n#include \"stm32l4xx_hal.h\"\n\n// === User options ===\n#define QUAD_REVERSE 0   // set to 1 to invert direction if needed\n\nvolatile int32_t g_encoder_pos = 0;   // 4x counts\nvolatile uint32_t g_last_edge_us = 0; // optional: for simple deglitching if desired\n\n// Forward decls\nstatic void MX_GPIO_Quad_Init(void);\n\n// Call this from your main init\nvoid Quad_Init(void) {\n    MX_GPIO_Quad_Init();\n}\n\n// --- GPIO + EXTI init for PA0/PA1 (A/B), optional PA2 (Z) ---\nstatic void MX_GPIO_Quad_Init(void)\n{\n    __HAL_RCC_GPIOA_CLK_ENABLE();\n    __HAL_RCC_SYSCFG_CLK_ENABLE();\n\n    GPIO_InitTypeDef gi = {0};\n\n    // Configure PA0 (A) and PA1 (B) as inputs with pull-ups and EXTI on both edges\n    gi.Mode  = GPIO_MODE_IT_RISING_FALLING;\n    gi.Pull  = GPIO_PULLUP;            // or PULLDOWN to match your encoder; many encoders are open-collector -&gt; use PULLUP\n    gi.Speed = GPIO_SPEED_FREQ_HIGH;\n\n    gi.Pin   = GPIO_PIN_0; HAL_GPIO_Init(GPIOA, &gi);  // A\n    gi.Pin   = GPIO_PIN_1; HAL_GPIO_Init(GPIOA, &gi);  // B\n\n    // Optional index Z on PA2\n    // gi.Pin   = GPIO_PIN_2; HAL_GPIO_Init(GPIOA, &gi);\n\n    // NVIC: each line has its own IRQ, keeps ISRs short\n    HAL_NVIC_SetPriority(EXTI0_IRQn, 3, 0);\n    HAL_NVIC_EnableIRQ(EXTI0_IRQn);\n\n    HAL_NVIC_SetPriority(EXTI1_IRQn, 3, 0);\n    HAL_NVIC_EnableIRQ(EXTI1_IRQn);\n\n    // Optional EXTI2 for index\n    // HAL_NVIC_SetPriority(EXTI2_IRQn, 3, 0);\n    // HAL_NVIC_EnableIRQ(EXTI2_IRQn);\n}\n\n// --- Direction logic helpers ---\n// If A changed: dir = (A == B) ? -1 : +1\n// If B changed: dir = (A == B) ? +1 : -1\n// (This matches a common quadrature phase; flip with QUAD_REVERSE if it’s backward.)\n\nstatic inline void quad_on_A_edge(void)\n{\n    uint8_t A = (uint8_t)HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0);\n    uint8_t B = (uint8_t)HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_1);\n    int step = (A == B) ? -1 : +1;\n#if QUAD_REVERSE\n    step = -step;\n#endif\n    g_encoder_pos += step;\n}\n\nstatic inline void quad_on_B_edge(void)\n{\n    uint8_t A = (uint8_t)HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0);\n    uint8_t B = (uint8_t)HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_1);\n    int step = (A == B) ? +1 : -1;\n#if QUAD_REVERSE\n    step = -step;\n#endif\n    g_encoder_pos += step;\n}\n\n// --- ISRs ---\nvoid EXTI0_IRQHandler(void)  // A on PA0\n{\n    if (__HAL_GPIO_EXTI_GET_IT(GPIO_PIN_0) != 0u) {\n        __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_0);\n        quad_on_A_edge();\n    }\n}\n\nvoid EXTI1_IRQHandler(void)  // B on PA1\n{\n    if (__HAL_GPIO_EXTI_GET_IT(GPIO_PIN_1) != 0u) {\n        __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_1);\n        quad_on_B_edge();\n    }\n}\n\n// Optional: index Z zeroing, both edges or rising only as you prefer\n// void EXTI2_IRQHandler(void)\n// {\n//     if (__HAL_GPIO_EXTI_GET_IT(GPIO_PIN_2) != 0u) {\n//         __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_2);\n//         g_encoder_pos = 0;  // or latch index, etc.\n//     }\n// }\nThis code did not include the libraries and was not written in a form to be properly integrated into my main code. Therefore, I gave it my libraries and code to go based off of but then, it didn’t produce original ideas."
  },
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, we designed and built an Internet of Things (IoT) device. We used the ESP8266, which is a small Wi-Fi development board that incorporates onboard WiFi, along with some web server code to host a webpage. The MCU was interfaced with the ESP8266 module over a UART link, which allowed the MCU to communicate with and change the webpage. We also used a DS1722 Digital Thermometer to read the ambient temperature in the lab. We wrote code to interface the MCU with the temperature sensor over an SPI link. Together, the MCU communicated with the temperature sensor to receive temperature data and display it on the webpage.\n\n\n\n\n\nTo implement the SPI functionality of the MCU, I wrote libraries in C using the CMSIS device templates. I did this using two functions, one to initiate the SPI and the other to send/receive data from the temperature sensor. To initiate the SPI, I configured the clock, CIPO, and COPI pins for the transactions. I then configured CPI_CR1, which included setting things like the baud rate, clock phase, and clock polarity. In the send/receive function, the program waited until the transmit buffer was empty. Then, the message was sent over SPI and the program waited until the data had been received to return the received character.\n\n\n\nThe temperature sensor we used for this lab is the DS1722 Digital Thermometer. It had both an SPI and a 3-Wire interface, but in this lab, we used SPI. I consulted the DS1722 datasheet to correctly wire up the device, which consisted of connecting the MCU pins to the sensor’s CLK, CE, SDI, and SDO, with the SERMODE being set to SPI.\nAs shown below in table 1, I used the register address structure from the DS1722 datasheet to communicate with it over SPI. I configured the temperature sensor by first calling the SPI send/receive function with the config register, 0x80, and then calling the send/receive function again with the resolution as the argument. Then, to read data from the most significant and least significant bits, I called the send/receive function on 0x20 for MSB and 0x10 for LSB. After sending the address to read from, to actually read the data, I need to run the SPI clock again, which is why I called the send/receive function with the dummy bits 0x00. Before sending and receiving SPI, I made sure to put the chip enable high beforehand and low afterwards, which was specified in the datasheet.\n\n\n\nTable 1: DS1722 Register Address Structure\n\n\nUsing the information from table 2 below, a simple calculation was done to calculate the temperature value from the data received from the sensor. The raw data is divided by 256 in order to get the temperatyre out. This is because the DS1722 only uses 12 bits for temperature but sends 16 bits, meaning it shifts its data left by 4 bits (×2⁴) and fills the lowest 4 bits with zeros. When you read both bytes and combine them in code, you shift the MSB by another 8 bits (×2⁸). The unused 4 zeros cancel out part of that scaling, leaving the final number 2⁸ = 256 times larger than the real temperature. So ividing by 256 moves the binary point back, giving the correct temperature value.\n\n\n\nTable 2: DS1722 Temperature/Data Relationships\n\n\n\n\n\nIn order to test the SPI transactions, I checked them on a logic analyzer to ensure that the SCLK, CIPO, COPI, and the CE were all matching my expectations. A trace of a properly functioning SPI transaction is shown below in Figure 1.\n\n\n\nFigure 1. Logic Analyzer Trace\n\n\nYou can see the entire SPI functionality as described above in the temperature sensor section on the trace. The MOSI (COPI) line first shows sending the addres 0x80, which is the configuration register. Then, the line shows it sending the address 0x20, which is the address of the MSB. As the dummy bits 0x00 are sent, the temperature value is shown on the MISO (CIPO) line as 0x16, which equals 22 C, the ambient room temperature. Next, the address 0x10 is sent, which is the address of the LSB. When the dummy bits 0x00 are sent, the MISO (CIPO) line shows 0xE0, indicating the decimal value of 0.875 C. This aligned with the temperature being displayed on the website, which was 22.875 C.\n\n\n\n\nThe source code for the project can be found in the associated Github repository.\n\n\nThe circuit for this lab included wiring up the temperature sensor and the ESP8266 modules to the MCU. This is shown below in Figure 2.\n\n\n\nFigure 2. Lab 6 Schematic\n\n\n\n\n\n\nI gained a lot of troubleshooting skills in this lab. There were little things to debug in my SPI protocol functions, but debugging these were not difficult using the logic analyzer. One of the issues I ran into was that my IoT WiFi connection was not showing up on the computer, which meant I could not connect to the device. I spent a lot of time trying to debug this, and the solution was that since this device draws a lot of power, I had to use an external power supply to provide power. Another issue I had was that on the logic analyzer, I was seeing strange behavior on the CIPO line. To debug this, as it was possibly an analog issue, I probed the CIPO line. Some of this can be seen in the logic analyzer trace in Figure 1 (yellow tace). I identified capacitive behavior, and had to resolder some of the pins that seemed to have a lot of solder. Another issue I had was that for a long time, I was only seeing 0s on the LSB bits. To fix this, I realized that the conversion time was quite high for the higher resolutions, so I added a delay, which made me see better values in the least significant bits.\nThe design met all the intended objectives. The final result of the website is shown below in Figure 3. The button to blink the onboard LED on and off functions properly, and the temperature sensor also reads accurate ambient room temperature data and allows for user resolution input.\n\n\n\nFigure 3. Functioning Website\n\n\n\n\n\nIn this lab, I gained a deep understanding of the SPI communication protocol, as well as configuring peripheral devices with the MCU. I also did a lot of testing on the logic analyzer, and am now very comfortable using it as a debugging tool. I also gained a deeper understanding of WiFi modules and IoT devices. In total, this lab took me 35 hours to complete.\n\n\n\nFor this week’s AI Prototype, I typed the following prompt into ChatGPT: I’m making a web portal to interface with a temperature sensor. Create a HTML page that looks good and is intuitive to show the temperature, control an LED, and change the precision of the readout.\nI had to give it some additional prompts for the AI to generate code that would fit in my main.c, but after adding the code to my web server, I saw website shown below.\n\n\n\nFigure 4. AI Generated Website\n\n\nThis website worked well, and looked much better than the web server that I wrote. It had more intricate functions, like better displays, buttons, and a drop down menu to select the resolution. It was definitely more aesthetically pleasing than my website.\nI then gave it this second prompt: Write me a C function to carry out a SPI transaction to retrieve a temperature reading from a DS1722 sensor. Make use of CMSIS libraries for the STM32L432KC.\nThis did not work out as well. Even though the code looked reasonable, it did not work when I plugged it into the project. It was using syntax and libraries that were not supported by my existing code, and a lot of editing would have to be done to make it work."
  },
  {
    "objectID": "labs/lab6/lab6.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "href": "labs/lab6/lab6.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, we designed and built an Internet of Things (IoT) device. We used the ESP8266, which is a small Wi-Fi development board that incorporates onboard WiFi, along with some web server code to host a webpage. The MCU was interfaced with the ESP8266 module over a UART link, which allowed the MCU to communicate with and change the webpage. We also used a DS1722 Digital Thermometer to read the ambient temperature in the lab. We wrote code to interface the MCU with the temperature sensor over an SPI link. Together, the MCU communicated with the temperature sensor to receive temperature data and display it on the webpage.\n\n\n\n\n\nTo implement the SPI functionality of the MCU, I wrote libraries in C using the CMSIS device templates. I did this using two functions, one to initiate the SPI and the other to send/receive data from the temperature sensor. To initiate the SPI, I configured the clock, CIPO, and COPI pins for the transactions. I then configured CPI_CR1, which included setting things like the baud rate, clock phase, and clock polarity. In the send/receive function, the program waited until the transmit buffer was empty. Then, the message was sent over SPI and the program waited until the data had been received to return the received character.\n\n\n\nThe temperature sensor we used for this lab is the DS1722 Digital Thermometer. It had both an SPI and a 3-Wire interface, but in this lab, we used SPI. I consulted the DS1722 datasheet to correctly wire up the device, which consisted of connecting the MCU pins to the sensor’s CLK, CE, SDI, and SDO, with the SERMODE being set to SPI.\nAs shown below in table 1, I used the register address structure from the DS1722 datasheet to communicate with it over SPI. I configured the temperature sensor by first calling the SPI send/receive function with the config register, 0x80, and then calling the send/receive function again with the resolution as the argument. Then, to read data from the most significant and least significant bits, I called the send/receive function on 0x20 for MSB and 0x10 for LSB. After sending the address to read from, to actually read the data, I need to run the SPI clock again, which is why I called the send/receive function with the dummy bits 0x00. Before sending and receiving SPI, I made sure to put the chip enable high beforehand and low afterwards, which was specified in the datasheet.\n\n\n\nTable 1: DS1722 Register Address Structure\n\n\nUsing the information from table 2 below, a simple calculation was done to calculate the temperature value from the data received from the sensor. The raw data is divided by 256 in order to get the temperatyre out. This is because the DS1722 only uses 12 bits for temperature but sends 16 bits, meaning it shifts its data left by 4 bits (×2⁴) and fills the lowest 4 bits with zeros. When you read both bytes and combine them in code, you shift the MSB by another 8 bits (×2⁸). The unused 4 zeros cancel out part of that scaling, leaving the final number 2⁸ = 256 times larger than the real temperature. So ividing by 256 moves the binary point back, giving the correct temperature value.\n\n\n\nTable 2: DS1722 Temperature/Data Relationships\n\n\n\n\n\nIn order to test the SPI transactions, I checked them on a logic analyzer to ensure that the SCLK, CIPO, COPI, and the CE were all matching my expectations. A trace of a properly functioning SPI transaction is shown below in Figure 1.\n\n\n\nFigure 1. Logic Analyzer Trace\n\n\nYou can see the entire SPI functionality as described above in the temperature sensor section on the trace. The MOSI (COPI) line first shows sending the addres 0x80, which is the configuration register. Then, the line shows it sending the address 0x20, which is the address of the MSB. As the dummy bits 0x00 are sent, the temperature value is shown on the MISO (CIPO) line as 0x16, which equals 22 C, the ambient room temperature. Next, the address 0x10 is sent, which is the address of the LSB. When the dummy bits 0x00 are sent, the MISO (CIPO) line shows 0xE0, indicating the decimal value of 0.875 C. This aligned with the temperature being displayed on the website, which was 22.875 C.\n\n\n\n\nThe source code for the project can be found in the associated Github repository.\n\n\nThe circuit for this lab included wiring up the temperature sensor and the ESP8266 modules to the MCU. This is shown below in Figure 2.\n\n\n\nFigure 2. Lab 6 Schematic\n\n\n\n\n\n\nI gained a lot of troubleshooting skills in this lab. There were little things to debug in my SPI protocol functions, but debugging these were not difficult using the logic analyzer. One of the issues I ran into was that my IoT WiFi connection was not showing up on the computer, which meant I could not connect to the device. I spent a lot of time trying to debug this, and the solution was that since this device draws a lot of power, I had to use an external power supply to provide power. Another issue I had was that on the logic analyzer, I was seeing strange behavior on the CIPO line. To debug this, as it was possibly an analog issue, I probed the CIPO line. Some of this can be seen in the logic analyzer trace in Figure 1 (yellow tace). I identified capacitive behavior, and had to resolder some of the pins that seemed to have a lot of solder. Another issue I had was that for a long time, I was only seeing 0s on the LSB bits. To fix this, I realized that the conversion time was quite high for the higher resolutions, so I added a delay, which made me see better values in the least significant bits.\nThe design met all the intended objectives. The final result of the website is shown below in Figure 3. The button to blink the onboard LED on and off functions properly, and the temperature sensor also reads accurate ambient room temperature data and allows for user resolution input.\n\n\n\nFigure 3. Functioning Website\n\n\n\n\n\nIn this lab, I gained a deep understanding of the SPI communication protocol, as well as configuring peripheral devices with the MCU. I also did a lot of testing on the logic analyzer, and am now very comfortable using it as a debugging tool. I also gained a deeper understanding of WiFi modules and IoT devices. In total, this lab took me 35 hours to complete.\n\n\n\nFor this week’s AI Prototype, I typed the following prompt into ChatGPT: I’m making a web portal to interface with a temperature sensor. Create a HTML page that looks good and is intuitive to show the temperature, control an LED, and change the precision of the readout.\nI had to give it some additional prompts for the AI to generate code that would fit in my main.c, but after adding the code to my web server, I saw website shown below.\n\n\n\nFigure 4. AI Generated Website\n\n\nThis website worked well, and looked much better than the web server that I wrote. It had more intricate functions, like better displays, buttons, and a drop down menu to select the resolution. It was definitely more aesthetically pleasing than my website.\nI then gave it this second prompt: Write me a C function to carry out a SPI transaction to retrieve a temperature reading from a DS1722 sensor. Make use of CMSIS libraries for the STM32L432KC.\nThis did not work out as well. Even though the code looked reasonable, it did not work when I plugged it into the project. It was using syntax and libraries that were not supported by my existing code, and a lot of editing would have to be done to make it work."
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, we soldered our E155 protoboard and implemented designs on the FPGA to drive on-board LEDs and a seven segment display. Two of the LEDs outputted combinational logic, and one of them was blinked at a specific frequency using the on-board high-speed oscillator.\n\n\n\nAfter soldering and testing the FPGA, MCU, and the development board for proper functionality, I designed my FPGA to further test the hardware on my board and operate a 7-segment display. The design consisted of the following:\n\n\n\n\n\n\n\n\nSignal Name\nSignal Type\nDescription\n\n\n\n\nclk\ninput\n48 MHz clock on FPGA\n\n\ns[3:0]\ninput\nfour DIP switches (on the board)\n\n\nled[2:0]\noutput\n3 on-board LEDs\n\n\nseg[6:0]\noutput\nthe segments of a common-anode 7-segment display\n\n\n\nThere were two primary aspects to this lab: operate three on-board LEDs (led[0], led[1], and led[2]) and create a 7-segment display.\nThe relationship between the switches (s0, s1, s2, s3) and the first two LEDs (led[0] and led[1]) were provided in the form of truth tables. Upon deriving the combinational logic, it was clear that led[0] was an exclusive or (XOR) of s0 and s1, while led[1] was an AND of s2 and s3. The third LED, led[3], was to be blinked at 2.4Hz. This was done using the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library. This oscillator generated a 48 MHz clock, and a counter was used to divide this down so the blinking frequency could be visualized on led[2]. In order to generate a 2.4 Hz signal that would complete a half cycle, a clock divider module was designed to count every (0.5)* 48 MHz/2.4 Hz, or 10 million ticks.\nThe 7-segment display was designed to display a signle hexadecimal digit specified by a four bit binary input s[3:0]. To do this, a separate SystemVerliog module was written, which contained 16 case statements detailing which segments of the display should be lit to create the hexademical digit corresponding to the dip switch input of s[3:0]. When breadboarding this design, it was important to remember that in the common annode display we were working with, a logic 0 applied to the cathode turned on the segment.\nAfter designing the modules on SystemVerilog and programming the designs to the FPGA, we tested our design. For the LEDs, in order to test led[0] and led[1], we tried the different combination logic using the switches to ensure the proper XOR and AND gate functionality. For led[2], we used an oscilloscope to verify the blink frequency of 2.4 Hz. To test the 7-segment display, we operated the DIP switches to ensure that the four bit binary numbers displayed their corresponding hexadecimal digit with equal brightness in segments, as shown in Figure 1.\n\n\n\nFigure 1. Output of hex digit 5 for a binary input of 4’b0101\n\n\nIn order to enxure that the current draw for each segment in the 7-segment display was within recommended operating conditions, the calculations shown in Figure 2 were done. The absolute maximum current rating is 20 mA, and as the calculations show, we have a 1.3 mA current draw, which is standard for LEDs.\n\n\n\nFigure 2. Calculations for current draw in 7-segment display\n\n\n\n\n\nThe source code for the project can be found in the associated Github repository.\n\n\n\n\n\nFigure 3. Block diagram of the Verilog module\n\n\nThe block diagram shown in Figure 3 demonstrates the overall architecture of the design. The top-level module (top) includes two submodules: the high-speed oscillator block (HSOSC) and the module to operate the 7-segment display. The operation of the LEDs happens in the top-level module as combinational logic.\n\n\n\n\n\n\nFigure 4. Schematic of the physical circuit\n\n\nThe physical layout of the design is shown in Figure 4. The left side of the UPduino shows the inputs, while the right side shows the outputs. The inputs consist of a reset button and four switches. An internal 100 kΩ pullup resistor was used to ensure the active low reset pin was not floating. The outputs consist of the seven LEDs from the 7-segment display, and three LEDs to test the combinational logic and blinking. These LEDs are connected using a 1kΩ current-limiting resistor to ensure the output current did not exceed the maximum output current of the FPGA I/O pins.\n\n\n\n\n\n\nTwo testbenches were written in SystemVerilog, one for the top-level and one for the 7-segment display modules, in order to verify that the designs were working as intended. Using the written test vectors, the testbenches ran all 16 cominations of the DIP switches in order to simulate and test if the led[2:0] and seg[6:0] outputs matched the expected outputs.\nAs shown in the simulation images shown in Figures 5 and 6, all the simulations passed and produced the expected outputs. Therefore, the design met all of the intended design objectives, and performed quickly and reliably. The simulations shown below ran in just a few seconds, and the hardware displayed all the required lights brightly.\n\n\n\nFigure 5. Top-level module QuestaSim simulation\n\n\n\n\n\nFigure 6. 7-segment module QuestaSim simulation\n\n\n\n\n\n\nMy FPGA designs successfully controlled a 7-segment display and LEDs, thus validating the functionality of my soldered protoboard. By blinking one of the LEDs at 2.4 Hz, I also validated the functionality of the on-board high-speed oscillator. In total, I spent 25 hours on this lab.\n\n\n\nUpon typing the following prompt into ChatGPT, the following code, along with the comment, was generated, as shown in Figures 7 and 8:\nLLM Prompt: Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\n\n\n\nFigure 7. Code generated by LLM\n\n\n\n\n\nFigure 8. Comment generated by LLM\n\n\nThe LLM-generated code was synthesized the first time around in Radiant. There were no errors and a few warnings in synthesis, but these warnings only pointed to top-level module declaration. These warnings were not related to the code itself.\nThe logic to blink the 2 Hz LED operated on the same principle: have a set number of toggle cycles, and when the counter reaches this number, reset the counter and blink the LED. The math to blink the LED was also the same: 48MHz divided by two times the desired blink frequency of 2 Hz.\nOne of the first differences I noticed was that there was no reset or reset case within the clock divide in the LLM-generated code. Another between my top-level module and the LLM-generated code is the declaration/usage of the internal high-speed oscillator. The module was declared using the # operator for parameter passing, but had essentially the same arguments as my one line of code. Another syntax that was new to me was the usage of “localparam” to define the variables (such as the number of toggle cycles) fixed within the design. A stylistic difference I noticed is that the calculations for the toggle cycle were included in the code generated by the LLM as variables, whereas I only included the final number of cycles. I liked the LLM’s version, as it was clear to follow the mathematical reasoning behind the number of cycles.\nI would rate the quality of the output pretty highly, as it was able to do the most difficult parts of this code generation quickly and efficiently. It demonstrated how to generate the number of toggles, how to use the internal high-speed oscillator, and how to create the clock divider, which are the main parts of this code. If I were to use an LLM in my workflow next time, I think I would specify SystemVerilog constructs/syntax I was familiar with in order to receive code that is most catered to my understanding."
  },
  {
    "objectID": "labs/lab1/lab1.html#lab-1-fpga-and-mcu-setup-and-testing",
    "href": "labs/lab1/lab1.html#lab-1-fpga-and-mcu-setup-and-testing",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, we soldered our E155 protoboard and implemented designs on the FPGA to drive on-board LEDs and a seven segment display. Two of the LEDs outputted combinational logic, and one of them was blinked at a specific frequency using the on-board high-speed oscillator.\n\n\n\nAfter soldering and testing the FPGA, MCU, and the development board for proper functionality, I designed my FPGA to further test the hardware on my board and operate a 7-segment display. The design consisted of the following:\n\n\n\n\n\n\n\n\nSignal Name\nSignal Type\nDescription\n\n\n\n\nclk\ninput\n48 MHz clock on FPGA\n\n\ns[3:0]\ninput\nfour DIP switches (on the board)\n\n\nled[2:0]\noutput\n3 on-board LEDs\n\n\nseg[6:0]\noutput\nthe segments of a common-anode 7-segment display\n\n\n\nThere were two primary aspects to this lab: operate three on-board LEDs (led[0], led[1], and led[2]) and create a 7-segment display.\nThe relationship between the switches (s0, s1, s2, s3) and the first two LEDs (led[0] and led[1]) were provided in the form of truth tables. Upon deriving the combinational logic, it was clear that led[0] was an exclusive or (XOR) of s0 and s1, while led[1] was an AND of s2 and s3. The third LED, led[3], was to be blinked at 2.4Hz. This was done using the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library. This oscillator generated a 48 MHz clock, and a counter was used to divide this down so the blinking frequency could be visualized on led[2]. In order to generate a 2.4 Hz signal that would complete a half cycle, a clock divider module was designed to count every (0.5)* 48 MHz/2.4 Hz, or 10 million ticks.\nThe 7-segment display was designed to display a signle hexadecimal digit specified by a four bit binary input s[3:0]. To do this, a separate SystemVerliog module was written, which contained 16 case statements detailing which segments of the display should be lit to create the hexademical digit corresponding to the dip switch input of s[3:0]. When breadboarding this design, it was important to remember that in the common annode display we were working with, a logic 0 applied to the cathode turned on the segment.\nAfter designing the modules on SystemVerilog and programming the designs to the FPGA, we tested our design. For the LEDs, in order to test led[0] and led[1], we tried the different combination logic using the switches to ensure the proper XOR and AND gate functionality. For led[2], we used an oscilloscope to verify the blink frequency of 2.4 Hz. To test the 7-segment display, we operated the DIP switches to ensure that the four bit binary numbers displayed their corresponding hexadecimal digit with equal brightness in segments, as shown in Figure 1.\n\n\n\nFigure 1. Output of hex digit 5 for a binary input of 4’b0101\n\n\nIn order to enxure that the current draw for each segment in the 7-segment display was within recommended operating conditions, the calculations shown in Figure 2 were done. The absolute maximum current rating is 20 mA, and as the calculations show, we have a 1.3 mA current draw, which is standard for LEDs.\n\n\n\nFigure 2. Calculations for current draw in 7-segment display\n\n\n\n\n\nThe source code for the project can be found in the associated Github repository.\n\n\n\n\n\nFigure 3. Block diagram of the Verilog module\n\n\nThe block diagram shown in Figure 3 demonstrates the overall architecture of the design. The top-level module (top) includes two submodules: the high-speed oscillator block (HSOSC) and the module to operate the 7-segment display. The operation of the LEDs happens in the top-level module as combinational logic.\n\n\n\n\n\n\nFigure 4. Schematic of the physical circuit\n\n\nThe physical layout of the design is shown in Figure 4. The left side of the UPduino shows the inputs, while the right side shows the outputs. The inputs consist of a reset button and four switches. An internal 100 kΩ pullup resistor was used to ensure the active low reset pin was not floating. The outputs consist of the seven LEDs from the 7-segment display, and three LEDs to test the combinational logic and blinking. These LEDs are connected using a 1kΩ current-limiting resistor to ensure the output current did not exceed the maximum output current of the FPGA I/O pins.\n\n\n\n\n\n\nTwo testbenches were written in SystemVerilog, one for the top-level and one for the 7-segment display modules, in order to verify that the designs were working as intended. Using the written test vectors, the testbenches ran all 16 cominations of the DIP switches in order to simulate and test if the led[2:0] and seg[6:0] outputs matched the expected outputs.\nAs shown in the simulation images shown in Figures 5 and 6, all the simulations passed and produced the expected outputs. Therefore, the design met all of the intended design objectives, and performed quickly and reliably. The simulations shown below ran in just a few seconds, and the hardware displayed all the required lights brightly.\n\n\n\nFigure 5. Top-level module QuestaSim simulation\n\n\n\n\n\nFigure 6. 7-segment module QuestaSim simulation\n\n\n\n\n\n\nMy FPGA designs successfully controlled a 7-segment display and LEDs, thus validating the functionality of my soldered protoboard. By blinking one of the LEDs at 2.4 Hz, I also validated the functionality of the on-board high-speed oscillator. In total, I spent 25 hours on this lab.\n\n\n\nUpon typing the following prompt into ChatGPT, the following code, along with the comment, was generated, as shown in Figures 7 and 8:\nLLM Prompt: Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\n\n\n\nFigure 7. Code generated by LLM\n\n\n\n\n\nFigure 8. Comment generated by LLM\n\n\nThe LLM-generated code was synthesized the first time around in Radiant. There were no errors and a few warnings in synthesis, but these warnings only pointed to top-level module declaration. These warnings were not related to the code itself.\nThe logic to blink the 2 Hz LED operated on the same principle: have a set number of toggle cycles, and when the counter reaches this number, reset the counter and blink the LED. The math to blink the LED was also the same: 48MHz divided by two times the desired blink frequency of 2 Hz.\nOne of the first differences I noticed was that there was no reset or reset case within the clock divide in the LLM-generated code. Another between my top-level module and the LLM-generated code is the declaration/usage of the internal high-speed oscillator. The module was declared using the # operator for parameter passing, but had essentially the same arguments as my one line of code. Another syntax that was new to me was the usage of “localparam” to define the variables (such as the number of toggle cycles) fixed within the design. A stylistic difference I noticed is that the calculations for the toggle cycle were included in the code generated by the LLM as variables, whereas I only included the final number of cycles. I liked the LLM’s version, as it was clear to follow the mathematical reasoning behind the number of cycles.\nI would rate the quality of the output pretty highly, as it was able to do the most difficult parts of this code generation quickly and efficiently. It demonstrated how to generate the number of toggles, how to use the internal high-speed oscillator, and how to create the clock divider, which are the main parts of this code. If I were to use an LLM in my workflow next time, I think I would specify SystemVerilog constructs/syntax I was familiar with in order to receive code that is most catered to my understanding."
  },
  {
    "objectID": "labs/labs.html",
    "href": "labs/labs.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "List of E155 Labs\nLab 1 - Board Assembly and Testing\nLab 2 - Multiplexed 7-Segment Display\nLab 3 - Keypad Scanner\nLab 4 - Digital Audio\nLab 5 - Interrupts\nLab 6 - The Internet of Things and Serial Peripheral Interface"
  },
  {
    "objectID": "labs/labs.html#labs-overview",
    "href": "labs/labs.html#labs-overview",
    "title": "E155 Portfolio",
    "section": "",
    "text": "List of E155 Labs\nLab 1 - Board Assembly and Testing\nLab 2 - Multiplexed 7-Segment Display\nLab 3 - Keypad Scanner\nLab 4 - Digital Audio\nLab 5 - Interrupts\nLab 6 - The Internet of Things and Serial Peripheral Interface"
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, time multiplexing was used to efficiently drive two seven-segment displays with a single set of FPGA I/O pins. The sum of both numbers were displayed on five separate LEDs. Additionally, transistors were used to drive large currents from the FPGA pins.\n\n\n\nThe design of the time multiplexing scheme was one of the main components of this lab. Time multiplexing is a technique that is used to share a common expensive hardware resource for several purposes at different times. In this lab, time multiplexing was used to drive a single seven-segment decoder module to run both halves of a dual display.\nIn terms of wiring, this is done by connecting a single GPIO pin on the FPGA to the same segment (e.g. segment e) on both the seven-segment displays. However, in order to control which half of the dual display is active, the common anode of only one display at a time is turned ON. The power to these two displays are controlled by two separate GPIO pins, which are toggled at a certain speed in order for two distinct numbers to appear simultaneously on each display. Due to the anode requiring more current than the FPGA output pin can drive, a 2N3906 PNP transistor was used to limit the base current and not draw too much from the FPGA pin. Both of the dual displays are controlled by four bit DIP switches, and the sum of both numbers is displayed as a five bit number on five separate LEDs. The hardware layout, with the breadboard and wiring as described above, is shown in Figure 1.\n\n\n\nFigure 1. Wiring of the dual seven-segment display, LEDs, and transistor circuits\n\n\nThe wiring and breadboard layout was intuitively done to enable easy debugging and be visually appealing. In order to justify resistor choices, calcuations were done, as shown in Figure 2, to ensure proper brightness of the five individual LEDs and that the current draw/sink on all the FPGA pins was below the currents specified in the recommended operating conditions.\n\n\n\nFigure 2. Calculations to justify chosen resistor values for the dual seven-segment display, the five individual LEDs, and the PNP transistor\n\n\nFrom a software standpoint, important decisions were made in order to split up the required tasks of the lab into respective modules. A top level module was used to instantiate the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library, which was the 48 MHz clock that was divided and used throughout the system. The top level module also contained the combinational logic for the five individual LEDs, as they were simple and therefore did not require a separate module.\nOne of the most important design considerations was the speed at which the two displays were toggled. This was done using a clock divider and 32-bit counter, where choosing different bits of the counter in the clock division allowed for different switching speeds. After testing, it was determined that the 18th bit of the counter produced a toggling speed that ensured that both hexadecimal digits lit up simultaneously without visible oscillation and without the digits bleeding into each other. At this speed, the clock divider enabled power to each of the displays in the dual display and the four bit inputs were sent one at a time to the seven segment module.\nIn order to verify the software, three testbenches were written with one for each module——top level, seven-segment, and multiplexer. The seven-segment testbench checked that the correct segments displayed with the corresponding four bit inpupts. The top level testbench checked that the combinational logic for the five LEDs functioned as properly. The multiplexer module checked that the input to the seven segment display was the correct four bit input corresponding to which display was enabled. The testbenches also checked the toggling of the enable signals. The waveforms are shown in the Results and Discussion section. In order to test the hardware, all switches and their summing combinational logic was tested on the breadboard. A picture from one of these tests is shown below in Figure 3.\n\n\n\nFigure 3. Image from testing displaying functioning hardware. The hex digit “b” is displayed on the left, and “0” is displayed on the right, with their sum equalling 11 and being displayed on the five individual LEDs.\n\n\n\n\n\nThe source code for the project can be found in the associated Github repository.\n\n\n\n\n\nFigure 4. Block diagram of the Verilog module\n\n\nThe block diagram shown in Figure 4 demonstrates the overall architecture of the design. The top-level module includes three submodules: the high-speed oscillator block (HSOSC), the seven-segment module to operate the 7-segment display, and the multiplexer module to operate the correct switching/toggling of the dual displays.\n\n\n\n\n\n\nFigure 5. Schematic of the physical circuit\n\n\nThe physical layout of the design is shown in Figure 5. The left side of the UPduino shows the inputs, which are the reset and two sets of four-input DIP switches with an internal 100 kΩ pullup resistor to ensure the active low reset pin was not floating. The right side shows the outputs, which are the GPIO pins connecting the transistors to power, the two enables, the seven segments, and the five LEDs. All of the LEDs and transistors are connected to current-limiting resistors, the calculations for which are shown above in Figure 2.\n\n\n\n\n\n\nThree testbenches were written in SystemVerilog, one for each of the modules (top level, multiplexer, and seven-segment), in order to show that the combinational logic works and that the enables toggle and produce the correct, corresponding display.\nAs shown in the simulation images below, all the simulations passed and produced the expected outputs. Figures 6 and 7 show the simulation waveforms for the top level module. Figure 6 shows that the led variable is the correct sum of the 8-bit counter input. Figure 7 shows that when zoomed out, the enable toggles and tests the other cases. Figure 8 shows that s (input to the seven-segment module) gets the correct four bit input during the correct enable. In the waveforms, it is visible that the value of four bits of s_counter (the input) match the value of s one clock cycle later. This makes sense because s is an output of the multiplexer module, and thus displays its value one clock cycle later. Similar to the top level, zooming out shows that the enable switches as expected to test all the other cases. Figure 10 shows the seven-segment waveforms also producing the expected outputs for the segment values on the display.\n\n\n\nFigure 6. Top-level module QuestaSim simulation showing correct combinational logic\n\n\n\n\n\nFigure 7. Zoomed-out view of top-level module QuestaSim simulation showing the enables switching\n\n\n\n\n\nFigure 8. Multiplexer module QuestaSim simulation showing the seven-segment getting the correct input\n\n\n\n\n\nFigure 9. Zoomed-out view of multiplexer module QuestaSim simulation showing the enables switching\n\n\n\n\n\nFigure 10. Seven-segment module QuestaSim simulation\n\n\nTherefore, the design met all of the intended design objectives, and performed quickly and reliably. The simulations shown below ran in a few seconds, and the hardware displayed all the required LEDs brightly.\n\n\n\n\nMy FPGA designs successfully controlled a time multiplexing scheme to drive two 7-segment displays with a single set of FPGA I/O pins. A transistor to drive large currents from the FPGA pins was also successfully implemented. Additionally, I gained a lot of experience with building testbenches and modular Verilog systems.\nIn total, I spent 21 hours on this lab.\n\n\n\nUpon typing the following prompt into ChatGPT, the following code was generated:\nPrompt: Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.\nCode:\n// -----------------------------------------------------------------------------\n// Common–anode 7-segment decoder (active LOW segments)\n// seg_n order = {a,b,c,d,e,f,g}\n// -----------------------------------------------------------------------------\nmodule sevenseg_ca_decode (\n  input  logic [3:0] x,\n  output logic [6:0] seg_n\n);\n  always_comb begin\n    unique case (x)\n      4'h0: seg_n = 7'b0000001;\n      4'h1: seg_n = 7'b1001111;\n      4'h2: seg_n = 7'b0010010;\n      4'h3: seg_n = 7'b0000110;\n      4'h4: seg_n = 7'b1001100;\n      4'h5: seg_n = 7'b0100100;\n      4'h6: seg_n = 7'b0100000;\n      4'h7: seg_n = 7'b0001111;\n      4'h8: seg_n = 7'b0000000;\n      4'h9: seg_n = 7'b0000100;\n      4'hA: seg_n = 7'b0001000;\n      4'hB: seg_n = 7'b1100000; // 'b' as 11\n      4'hC: seg_n = 7'b0110001;\n      4'hD: seg_n = 7'b1000010; // 'd' as 13\n      4'hE: seg_n = 7'b0110000;\n      4'hF: seg_n = 7'b0111000;\n      default: seg_n = 7'b1111111; // all OFF\n    endcase\n  end\nendmodule\n\n\n// -----------------------------------------------------------------------------\n// Two-channel time-multiplexer using a single decoder instance\n//  - Alternates between in0 and in1 at a programmable rate\n//  - Latches each decoded pattern into seg0_n/seg1_n registers\n//  - Outputs are stable between refresh ticks (no comb fanout from muxed input)\n// -----------------------------------------------------------------------------\nmodule sevenseg_twoch_tmux #(\n  // Adjust these to set the update rate.\n  // Example: at 25 MHz, DIV=125_000 gives a 200 Hz tick (each channel ~100 Hz).\n  parameter int unsigned DIV = 125_000\n) (\n  input  logic        clk,\n  input  logic        rst_n,\n\n  input  logic [3:0]  in0,\n  input  logic [3:0]  in1,\n\n  output logic [6:0]  seg0_n,  // decoded output for in0 (active LOW)\n  output logic [6:0]  seg1_n   // decoded output for in1 (active LOW)\n);\n\n  // Clock divider to make a refresh \"tick\"\n  logic [$clog2(DIV)-1:0] div_cnt;\n  logic                   tick;\n\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      div_cnt &lt;= '0;\n      tick    &lt;= 1'b0;\n    end else if (div_cnt == DIV-1) begin\n      div_cnt &lt;= '0;\n      tick    &lt;= 1'b1;\n    end else begin\n      div_cnt &lt;= div_cnt + 1'b1;\n      tick    &lt;= 1'b0;\n    end\n  end\n\n  // Channel select toggles each tick\n  logic sel;  // 0 -&gt; service in0, 1 -&gt; service in1\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) sel &lt;= 1'b0;\n    else if (tick) sel &lt;= ~sel;\n  end\n\n  // Single decoder instance, input multiplexed\n  logic [3:0] muxed_in;\n  logic [6:0] dec_out_n;\n\n  assign muxed_in = sel ? in1 : in0;\n\n  sevenseg_ca_decode u_dec (\n    .x     (muxed_in),\n    .seg_n (dec_out_n)\n  );\n\n  // Register each channel's pattern when it is serviced\n  // This removes glitches and gives each output a steady value\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      seg0_n &lt;= 7'h7F;  // all off\n      seg1_n &lt;= 7'h7F;\n    end else if (tick) begin\n      if (sel)  seg1_n &lt;= dec_out_n; // just decoded in1\n      else      seg0_n &lt;= dec_out_n; // just decoded in0\n    end\n  end\n\nendmodule\nThe LLM-generated code was synthesized the first time around in Radiant. It did take a longer time to synthesize than code that I’ve written, but there were no errors.\nThe hierarchy of the code it generated was different than mine, as it only had two modules, and mine had three. The seven segment module it wrote was pretty identical to my seven segment module, but the top level in the LLM-generated code (which included my multiplexer module functionality as well) was quite different. One of the main differences was that it didn’t use the on-board high speed oscillator for the clock and instead generated and used a new clock divider. It used a variable called “DIV,” which is told us to adjust to set the update or switching rate. The LLM-generated code also had two signals for enabling that performed the multiplexing, but it had two seven bit outputs instead of one. The generated code was pretty different than mine in terms of syntax, hierarchy, and implementation, but it was interesting to see that it does the same function (more or less) and compiles without errors.\nNext, I started a new conversation in ChatGPT and uploaded the following prompt along with my lab 1 files (all source files) as context to get the LLM-generated code shown below.\nPrompt: Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.\nCode:\n// dual_sevenseg_mux.sv\n// Time-multiplex a single 7-seg decoder across two 4-bit inputs and\n// drive two independent 7-bit (common-anode) segment buses.\n\nmodule dual_sevenseg_mux #(\n    // Internal oscillator nominal frequency (UP5K HFOSC ~48 MHz)\n    parameter int unsigned CLK_HZ      = 48_000_000,\n    // Per-digit refresh rate (how often each digit is updated)\n    parameter int unsigned REFRESH_HZ  = 1_000\n)(\n    input  logic        rst_n,          // active-low async reset (tie high if unused)\n\n    input  logic [3:0]  in0,            // nibble for \"left\" display\n    input  logic [3:0]  in1,            // nibble for \"right\" display\n\n    output logic [6:0]  seg0,           // segments for display 0 (common anode: active-low segments)\n    output logic [6:0]  seg1            // segments for display 1\n);\n\n    // ----------------------------------------------------------------\n    // Internal high-speed oscillator (Lattice iCE40 UP family primitive)\n    // ----------------------------------------------------------------\n    logic clk_hf;\n    HSOSC hf_osc (\n        .CLKHFPU (1'b1),   // power up\n        .CLKHFEN (1'b1),   // enable\n        .CLKHF   (clk_hf)  // ~48 MHz clock out\n    );\n\n    // ---------------------------------------------------------------\n    // Refresh tick generator (sets the multiplexing cadence)\n    // Each digit is updated at REFRESH_HZ, so the decoder input\n    // switches at 2*REFRESH_HZ overall.\n    // ---------------------------------------------------------------\n    localparam int unsigned TICKS_PER_REFRESH = CLK_HZ / REFRESH_HZ;\n    localparam int unsigned CNTW = $clog2(TICKS_PER_REFRESH);\n\n    logic [CNTW-1:0] tick_cnt;\n    logic            refresh_tick;\n\n    always_ff @(posedge clk_hf or negedge rst_n) begin\n        if (!rst_n) begin\n            tick_cnt     &lt;= '0;\n            refresh_tick &lt;= 1'b0;\n        end else begin\n            if (tick_cnt == TICKS_PER_REFRESH-1) begin\n                tick_cnt     &lt;= '0;\n                refresh_tick &lt;= 1'b1;\n            end else begin\n                tick_cnt     &lt;= tick_cnt + 1'b1;\n                refresh_tick &lt;= 1'b0;\n            end\n        end\n    end\n\n    // ---------------------------------------------------------------\n    // Single decoder instance, input mux, and latched outputs\n    // ---------------------------------------------------------------\n    logic        sel;           // 0 -&gt; in0 path active, 1 -&gt; in1 path active\n    logic [3:0]  mux_in;        // presented to the decoder\n    logic [6:0]  dec_out;       // raw decoder output (active-low segments)\n\n    // Feed one nibble at a time into the single decoder\n    assign mux_in = (sel == 1'b0) ? in0 : in1;\n\n    // Your provided seven-seg decoder (common-anode) — adjust names if needed.\n    seven_seg_sj u_dec (\n        .value (mux_in),\n        .seg   (dec_out)\n    );\n\n    // Registers to hold each display’s last-decoded segments\n    logic [6:0] seg0_r, seg1_r;\n\n    // On each refresh tick:\n    //  - latch current decoder output into the register corresponding to `sel`\n    //  - then toggle `sel` so the *other* nibble is decoded next period\n    always_ff @(posedge clk_hf or negedge rst_n) begin\n        if (!rst_n) begin\n            sel   &lt;= 1'b0;\n            seg0_r &lt;= 7'h7F;   // all OFF for common-anode (active-low)\n            seg1_r &lt;= 7'h7F;\n        end else if (refresh_tick) begin\n            if (sel == 1'b0) begin\n                seg0_r &lt;= dec_out; // we were decoding in0; capture for seg0\n            end else begin\n                seg1_r &lt;= dec_out; // we were decoding in1; capture for seg1\n            end\n            sel &lt;= ~sel; // switch to decode the other input next\n        end\n    end\n\n    // Drive outputs\n    assign seg0 = seg0_r;\n    assign seg1 = seg1_r;\n\nendmodule\nThis LLM-generated code did synthesize relatively quickly but had one error—that it was instantiating an unknown module seven_seg_sj. This was a mistake on my part because I didn’t add my module into the project. Besides this, the code looks pretty similar to mine. It uses the high speed oscillator and chooses the correct dual display based on the enable. Once again, it does have two 7-bit outputs while I have one, and it also uses syntax I’m not familiar with. But overall, it was efficient code, and was even more similar to mine when I inputted my lab 1 files."
  },
  {
    "objectID": "labs/lab2/lab2.html#lab-2-multiplexed-7-segment-display",
    "href": "labs/lab2/lab2.html#lab-2-multiplexed-7-segment-display",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, time multiplexing was used to efficiently drive two seven-segment displays with a single set of FPGA I/O pins. The sum of both numbers were displayed on five separate LEDs. Additionally, transistors were used to drive large currents from the FPGA pins.\n\n\n\nThe design of the time multiplexing scheme was one of the main components of this lab. Time multiplexing is a technique that is used to share a common expensive hardware resource for several purposes at different times. In this lab, time multiplexing was used to drive a single seven-segment decoder module to run both halves of a dual display.\nIn terms of wiring, this is done by connecting a single GPIO pin on the FPGA to the same segment (e.g. segment e) on both the seven-segment displays. However, in order to control which half of the dual display is active, the common anode of only one display at a time is turned ON. The power to these two displays are controlled by two separate GPIO pins, which are toggled at a certain speed in order for two distinct numbers to appear simultaneously on each display. Due to the anode requiring more current than the FPGA output pin can drive, a 2N3906 PNP transistor was used to limit the base current and not draw too much from the FPGA pin. Both of the dual displays are controlled by four bit DIP switches, and the sum of both numbers is displayed as a five bit number on five separate LEDs. The hardware layout, with the breadboard and wiring as described above, is shown in Figure 1.\n\n\n\nFigure 1. Wiring of the dual seven-segment display, LEDs, and transistor circuits\n\n\nThe wiring and breadboard layout was intuitively done to enable easy debugging and be visually appealing. In order to justify resistor choices, calcuations were done, as shown in Figure 2, to ensure proper brightness of the five individual LEDs and that the current draw/sink on all the FPGA pins was below the currents specified in the recommended operating conditions.\n\n\n\nFigure 2. Calculations to justify chosen resistor values for the dual seven-segment display, the five individual LEDs, and the PNP transistor\n\n\nFrom a software standpoint, important decisions were made in order to split up the required tasks of the lab into respective modules. A top level module was used to instantiate the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library, which was the 48 MHz clock that was divided and used throughout the system. The top level module also contained the combinational logic for the five individual LEDs, as they were simple and therefore did not require a separate module.\nOne of the most important design considerations was the speed at which the two displays were toggled. This was done using a clock divider and 32-bit counter, where choosing different bits of the counter in the clock division allowed for different switching speeds. After testing, it was determined that the 18th bit of the counter produced a toggling speed that ensured that both hexadecimal digits lit up simultaneously without visible oscillation and without the digits bleeding into each other. At this speed, the clock divider enabled power to each of the displays in the dual display and the four bit inputs were sent one at a time to the seven segment module.\nIn order to verify the software, three testbenches were written with one for each module——top level, seven-segment, and multiplexer. The seven-segment testbench checked that the correct segments displayed with the corresponding four bit inpupts. The top level testbench checked that the combinational logic for the five LEDs functioned as properly. The multiplexer module checked that the input to the seven segment display was the correct four bit input corresponding to which display was enabled. The testbenches also checked the toggling of the enable signals. The waveforms are shown in the Results and Discussion section. In order to test the hardware, all switches and their summing combinational logic was tested on the breadboard. A picture from one of these tests is shown below in Figure 3.\n\n\n\nFigure 3. Image from testing displaying functioning hardware. The hex digit “b” is displayed on the left, and “0” is displayed on the right, with their sum equalling 11 and being displayed on the five individual LEDs.\n\n\n\n\n\nThe source code for the project can be found in the associated Github repository.\n\n\n\n\n\nFigure 4. Block diagram of the Verilog module\n\n\nThe block diagram shown in Figure 4 demonstrates the overall architecture of the design. The top-level module includes three submodules: the high-speed oscillator block (HSOSC), the seven-segment module to operate the 7-segment display, and the multiplexer module to operate the correct switching/toggling of the dual displays.\n\n\n\n\n\n\nFigure 5. Schematic of the physical circuit\n\n\nThe physical layout of the design is shown in Figure 5. The left side of the UPduino shows the inputs, which are the reset and two sets of four-input DIP switches with an internal 100 kΩ pullup resistor to ensure the active low reset pin was not floating. The right side shows the outputs, which are the GPIO pins connecting the transistors to power, the two enables, the seven segments, and the five LEDs. All of the LEDs and transistors are connected to current-limiting resistors, the calculations for which are shown above in Figure 2.\n\n\n\n\n\n\nThree testbenches were written in SystemVerilog, one for each of the modules (top level, multiplexer, and seven-segment), in order to show that the combinational logic works and that the enables toggle and produce the correct, corresponding display.\nAs shown in the simulation images below, all the simulations passed and produced the expected outputs. Figures 6 and 7 show the simulation waveforms for the top level module. Figure 6 shows that the led variable is the correct sum of the 8-bit counter input. Figure 7 shows that when zoomed out, the enable toggles and tests the other cases. Figure 8 shows that s (input to the seven-segment module) gets the correct four bit input during the correct enable. In the waveforms, it is visible that the value of four bits of s_counter (the input) match the value of s one clock cycle later. This makes sense because s is an output of the multiplexer module, and thus displays its value one clock cycle later. Similar to the top level, zooming out shows that the enable switches as expected to test all the other cases. Figure 10 shows the seven-segment waveforms also producing the expected outputs for the segment values on the display.\n\n\n\nFigure 6. Top-level module QuestaSim simulation showing correct combinational logic\n\n\n\n\n\nFigure 7. Zoomed-out view of top-level module QuestaSim simulation showing the enables switching\n\n\n\n\n\nFigure 8. Multiplexer module QuestaSim simulation showing the seven-segment getting the correct input\n\n\n\n\n\nFigure 9. Zoomed-out view of multiplexer module QuestaSim simulation showing the enables switching\n\n\n\n\n\nFigure 10. Seven-segment module QuestaSim simulation\n\n\nTherefore, the design met all of the intended design objectives, and performed quickly and reliably. The simulations shown below ran in a few seconds, and the hardware displayed all the required LEDs brightly.\n\n\n\n\nMy FPGA designs successfully controlled a time multiplexing scheme to drive two 7-segment displays with a single set of FPGA I/O pins. A transistor to drive large currents from the FPGA pins was also successfully implemented. Additionally, I gained a lot of experience with building testbenches and modular Verilog systems.\nIn total, I spent 21 hours on this lab.\n\n\n\nUpon typing the following prompt into ChatGPT, the following code was generated:\nPrompt: Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.\nCode:\n// -----------------------------------------------------------------------------\n// Common–anode 7-segment decoder (active LOW segments)\n// seg_n order = {a,b,c,d,e,f,g}\n// -----------------------------------------------------------------------------\nmodule sevenseg_ca_decode (\n  input  logic [3:0] x,\n  output logic [6:0] seg_n\n);\n  always_comb begin\n    unique case (x)\n      4'h0: seg_n = 7'b0000001;\n      4'h1: seg_n = 7'b1001111;\n      4'h2: seg_n = 7'b0010010;\n      4'h3: seg_n = 7'b0000110;\n      4'h4: seg_n = 7'b1001100;\n      4'h5: seg_n = 7'b0100100;\n      4'h6: seg_n = 7'b0100000;\n      4'h7: seg_n = 7'b0001111;\n      4'h8: seg_n = 7'b0000000;\n      4'h9: seg_n = 7'b0000100;\n      4'hA: seg_n = 7'b0001000;\n      4'hB: seg_n = 7'b1100000; // 'b' as 11\n      4'hC: seg_n = 7'b0110001;\n      4'hD: seg_n = 7'b1000010; // 'd' as 13\n      4'hE: seg_n = 7'b0110000;\n      4'hF: seg_n = 7'b0111000;\n      default: seg_n = 7'b1111111; // all OFF\n    endcase\n  end\nendmodule\n\n\n// -----------------------------------------------------------------------------\n// Two-channel time-multiplexer using a single decoder instance\n//  - Alternates between in0 and in1 at a programmable rate\n//  - Latches each decoded pattern into seg0_n/seg1_n registers\n//  - Outputs are stable between refresh ticks (no comb fanout from muxed input)\n// -----------------------------------------------------------------------------\nmodule sevenseg_twoch_tmux #(\n  // Adjust these to set the update rate.\n  // Example: at 25 MHz, DIV=125_000 gives a 200 Hz tick (each channel ~100 Hz).\n  parameter int unsigned DIV = 125_000\n) (\n  input  logic        clk,\n  input  logic        rst_n,\n\n  input  logic [3:0]  in0,\n  input  logic [3:0]  in1,\n\n  output logic [6:0]  seg0_n,  // decoded output for in0 (active LOW)\n  output logic [6:0]  seg1_n   // decoded output for in1 (active LOW)\n);\n\n  // Clock divider to make a refresh \"tick\"\n  logic [$clog2(DIV)-1:0] div_cnt;\n  logic                   tick;\n\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      div_cnt &lt;= '0;\n      tick    &lt;= 1'b0;\n    end else if (div_cnt == DIV-1) begin\n      div_cnt &lt;= '0;\n      tick    &lt;= 1'b1;\n    end else begin\n      div_cnt &lt;= div_cnt + 1'b1;\n      tick    &lt;= 1'b0;\n    end\n  end\n\n  // Channel select toggles each tick\n  logic sel;  // 0 -&gt; service in0, 1 -&gt; service in1\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) sel &lt;= 1'b0;\n    else if (tick) sel &lt;= ~sel;\n  end\n\n  // Single decoder instance, input multiplexed\n  logic [3:0] muxed_in;\n  logic [6:0] dec_out_n;\n\n  assign muxed_in = sel ? in1 : in0;\n\n  sevenseg_ca_decode u_dec (\n    .x     (muxed_in),\n    .seg_n (dec_out_n)\n  );\n\n  // Register each channel's pattern when it is serviced\n  // This removes glitches and gives each output a steady value\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      seg0_n &lt;= 7'h7F;  // all off\n      seg1_n &lt;= 7'h7F;\n    end else if (tick) begin\n      if (sel)  seg1_n &lt;= dec_out_n; // just decoded in1\n      else      seg0_n &lt;= dec_out_n; // just decoded in0\n    end\n  end\n\nendmodule\nThe LLM-generated code was synthesized the first time around in Radiant. It did take a longer time to synthesize than code that I’ve written, but there were no errors.\nThe hierarchy of the code it generated was different than mine, as it only had two modules, and mine had three. The seven segment module it wrote was pretty identical to my seven segment module, but the top level in the LLM-generated code (which included my multiplexer module functionality as well) was quite different. One of the main differences was that it didn’t use the on-board high speed oscillator for the clock and instead generated and used a new clock divider. It used a variable called “DIV,” which is told us to adjust to set the update or switching rate. The LLM-generated code also had two signals for enabling that performed the multiplexing, but it had two seven bit outputs instead of one. The generated code was pretty different than mine in terms of syntax, hierarchy, and implementation, but it was interesting to see that it does the same function (more or less) and compiles without errors.\nNext, I started a new conversation in ChatGPT and uploaded the following prompt along with my lab 1 files (all source files) as context to get the LLM-generated code shown below.\nPrompt: Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.\nCode:\n// dual_sevenseg_mux.sv\n// Time-multiplex a single 7-seg decoder across two 4-bit inputs and\n// drive two independent 7-bit (common-anode) segment buses.\n\nmodule dual_sevenseg_mux #(\n    // Internal oscillator nominal frequency (UP5K HFOSC ~48 MHz)\n    parameter int unsigned CLK_HZ      = 48_000_000,\n    // Per-digit refresh rate (how often each digit is updated)\n    parameter int unsigned REFRESH_HZ  = 1_000\n)(\n    input  logic        rst_n,          // active-low async reset (tie high if unused)\n\n    input  logic [3:0]  in0,            // nibble for \"left\" display\n    input  logic [3:0]  in1,            // nibble for \"right\" display\n\n    output logic [6:0]  seg0,           // segments for display 0 (common anode: active-low segments)\n    output logic [6:0]  seg1            // segments for display 1\n);\n\n    // ----------------------------------------------------------------\n    // Internal high-speed oscillator (Lattice iCE40 UP family primitive)\n    // ----------------------------------------------------------------\n    logic clk_hf;\n    HSOSC hf_osc (\n        .CLKHFPU (1'b1),   // power up\n        .CLKHFEN (1'b1),   // enable\n        .CLKHF   (clk_hf)  // ~48 MHz clock out\n    );\n\n    // ---------------------------------------------------------------\n    // Refresh tick generator (sets the multiplexing cadence)\n    // Each digit is updated at REFRESH_HZ, so the decoder input\n    // switches at 2*REFRESH_HZ overall.\n    // ---------------------------------------------------------------\n    localparam int unsigned TICKS_PER_REFRESH = CLK_HZ / REFRESH_HZ;\n    localparam int unsigned CNTW = $clog2(TICKS_PER_REFRESH);\n\n    logic [CNTW-1:0] tick_cnt;\n    logic            refresh_tick;\n\n    always_ff @(posedge clk_hf or negedge rst_n) begin\n        if (!rst_n) begin\n            tick_cnt     &lt;= '0;\n            refresh_tick &lt;= 1'b0;\n        end else begin\n            if (tick_cnt == TICKS_PER_REFRESH-1) begin\n                tick_cnt     &lt;= '0;\n                refresh_tick &lt;= 1'b1;\n            end else begin\n                tick_cnt     &lt;= tick_cnt + 1'b1;\n                refresh_tick &lt;= 1'b0;\n            end\n        end\n    end\n\n    // ---------------------------------------------------------------\n    // Single decoder instance, input mux, and latched outputs\n    // ---------------------------------------------------------------\n    logic        sel;           // 0 -&gt; in0 path active, 1 -&gt; in1 path active\n    logic [3:0]  mux_in;        // presented to the decoder\n    logic [6:0]  dec_out;       // raw decoder output (active-low segments)\n\n    // Feed one nibble at a time into the single decoder\n    assign mux_in = (sel == 1'b0) ? in0 : in1;\n\n    // Your provided seven-seg decoder (common-anode) — adjust names if needed.\n    seven_seg_sj u_dec (\n        .value (mux_in),\n        .seg   (dec_out)\n    );\n\n    // Registers to hold each display’s last-decoded segments\n    logic [6:0] seg0_r, seg1_r;\n\n    // On each refresh tick:\n    //  - latch current decoder output into the register corresponding to `sel`\n    //  - then toggle `sel` so the *other* nibble is decoded next period\n    always_ff @(posedge clk_hf or negedge rst_n) begin\n        if (!rst_n) begin\n            sel   &lt;= 1'b0;\n            seg0_r &lt;= 7'h7F;   // all OFF for common-anode (active-low)\n            seg1_r &lt;= 7'h7F;\n        end else if (refresh_tick) begin\n            if (sel == 1'b0) begin\n                seg0_r &lt;= dec_out; // we were decoding in0; capture for seg0\n            end else begin\n                seg1_r &lt;= dec_out; // we were decoding in1; capture for seg1\n            end\n            sel &lt;= ~sel; // switch to decode the other input next\n        end\n    end\n\n    // Drive outputs\n    assign seg0 = seg0_r;\n    assign seg1 = seg1_r;\n\nendmodule\nThis LLM-generated code did synthesize relatively quickly but had one error—that it was instantiating an unknown module seven_seg_sj. This was a mistake on my part because I didn’t add my module into the project. Besides this, the code looks pretty similar to mine. It uses the high speed oscillator and chooses the correct dual display based on the enable. Once again, it does have two 7-bit outputs while I have one, and it also uses syntax I’m not familiar with. But overall, it was efficient code, and was even more similar to mine when I inputted my lab 1 files."
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, I learned how to use my MCU to play music by using timers. These timers generated square waves by toggling a GPIO pin at a specific frequency for specified durations. This lab also served as an introduction to working with the STM32 microcontroller boards. I gained a lot of experience with reading proper documentation (reference manual and datasheet) to understand clocks, timers, register, I/O, and more. The end result consisted of playing “Fur Elise” and my chosen song of “Hedwig’s Theme” from Harry Potter!\n\n\n\n\n\nI used the Timer 15 and Timer 16 registers in order to output a square wave signal from the microcontroller. For this lab, we had to read the datasheet carefully and write our own library in C from scratch. One of the reasons I chose Timers 15 and 16 is because they have the same register map. This meant I could take advantage of only having to write one struct in my timer header file. Another reason I chose these timers is that they both have the ability to be configured to a PWM mode and be connected to a GPIO pin in alternate function mode in order to have the desired functionality of producing a square wave output.\nAfter writing my header file, I wrote my timer source code, which consisted of four functions: initTIM to initialize my timer, delay_millis to provide a millisecond delay to set my note durations, initPWM to initialize the PWM mode of Timer 16, and setFreq to set the square wave to the desired frequency. Writing these four functions was the most difficult part of the lab, as they consisted of hours reading the reference manual to understand configuration, registers, and precisely which bits to set in which order to produce the desired functionality.\n\n\n\nTo go into more details on how the timers work, the timer configured in the PWM mode had the auto reload register (ARR) and the capture/compare register (CCR1) set in order to produce a specific period and duty cycle. The ARR value is set such that when the counter is equal to this value, it resets to 0, meaning this value sets the period of the signal. When the counter is less than the CCR1 value, it outputs a low (0), and when the counter is higher, it outputs a high (1), meaning the CCR1 value sets teh duty cycle. I set the CCR1 value to be half of the ARR value to have a duty cycle of 0.5. For the timer configured to set the delay, I utilized the ARR to control the delay, as it was set depending on the millisecond input.\nIn this lab, I used a phase-locked-loop (PLL) to set the microcontroller clock at 80 MHz, and to produce lower frequencies, I used prescalers. The timing calculations and theory behind my prescaler values are shown below in Figure 1.\n\n\n\nFigure 1. Timing calculations for frequency of sound output\n\n\nIn order to make sure that the minimum and maximum frequency and duration were supported with my chosen prescaler values, I did the calculations shown below in Figure 2.\n\n\n\nFigure 2. Max and min duration and frequency calculations\n\n\nOne of the specs for this lab was to produce individual pitches calculated to be accurate within 1% across the frequency range of 220-1000 Hz. Using the derived formula in figure 1 and careful unit conversion, I ran a timing analysis across this frequency range to make sure the spec was met. The calculations used to program the spreadsheet, showing examples of the pitches and durations being correct, as well as the resulting data is shown below in Figure 3 and 4, respectively.\n\n\n\nFigure 3. Calculations for spreadsheet and examples\n\n\n\n\n\nFigure 4. Pitch accuracy spreadsheet\n\n\n\n\n\nIn order to test the software’s functionality first, I uploaded the code to my MCU and used an oscilloscope to read the values of the GPIO pin to check that I was seeing the correct duty cycle and frequency. There was a lot of troubleshooting here, as I originlly did not see any square waves. I used Segger’s built in Debug mode to step through my code and ensure that all my registers were getting the value they were supposed to. After debugging and changing the way I configured/enabled things in my code, I started to see the correct frequency square waves in the oscilloscope.\n\n\n\n\nThe source code for the project can be found in the associated Github repository.\n\n\nThe circuit for this lab was simple. It contained an LM386 audio amplifier to drive the 8 ohm speaker and a potentiometer for volume control. The schematic is shown below in Figure 5.\n\n\n\nFigure 5. Schematic for audio amplifier circuit\n\n\n\n\n\n\nThe design met all the intended objectives. The hardware for this lab, which was tested after making sure the software worked properly, worked on the first try. To encode a new song, I found the site music for music from Harry Potter, and transcribed the notes into frequencies using the table from the class website. A video of the final result, including Fur Elise and Hedwig’s Theme from Harry Potter, is shown below.\n\n\n\n\nI was successfully able to use my MCU to play music in this lab! The learning curve was steep, as this was my first time writing libraries in C and using a microcontroller in depth. However, I got really comfortable reading the datasheet and reference manual, and I gained a better understanding of the STM32 overall. In total, I spent 19 hours on this lab.\n\n\n\nThis was the prompt I entered into ChatGPT: What timers should I use on the STM32L432KC to generate frequencies ranging from 220Hz to 1kHz? What’s the best choice of timer if I want to easily connect it to a GPIO pin? What formulae are relevant, and what registers need to be set to configure them properly?\nThis is the answer it gave me:\nGreat question. On the STM32L432KC you’ve got several timers that can do this cleanly.\n\nWhich timer(s) to use\n\nEasiest “hook to a GPIO and forget it” (50% square wave):\nTIM2 (general-purpose, 32-bit) using Output Compare Toggle mode. It routes to lots of pins (e.g., PA0…PA3 for CH1…CH4 on most L4s), and since it’s 32-bit you’ll never worry about running out of counts.\n\nIf you might want PWM duty control now or later:\nTIM1 (advanced) or TIM2 / TIM15 / TIM16 / TIM17 in PWM mode. TIM1 has “advanced” features (BDTR/MOE), but TIM2 is simplest and widely pinned out. Pick whichever has a channel available on a pin you’ve broken out; PA8 (TIM1_CH1) and PA0 (TIM2_CH1) are common.\n(Exact pin/AF depends on your board; check the “Alternate function mapping” table for the L432KC to pick the cleanest pin.)\n\nCore formulas (you’ll use these every time)\n\nLet f_tim be the timer’s input clock after the prescaler:\n\nf_tim = f_clk / (PSC + 1)\n\nPWM / update frequency (ARR reload):\nf_out = f_tim / (ARR + 1)\n\nPWM duty (edge-aligned):\nduty = (CCR + 1) / (ARR + 1) → for 50%, set CCR = ARR / 2.\n\nOutput-compare TOGGLE (pure 50% square):\nThe pin toggles each compare event, so period is 2×(CCR+1) ticks →\nf_out = f_tim / (2 * (CCR + 1))\n\nThese let you hit anything from 220 Hz to 1 kHz by choosing (PSC, ARR) for PWM or (PSC, CCR) for toggle.\n\nQuick worked choices (two common clock setups)\n\nAssume the timer clock (f_clk) is:\n\n16 MHz (HSI default)\n\nPWM at 1 kHz: pick PSC = 15 ⇒ f_tim = 1 MHz. Need ARR = 999 for 1 kHz. 50%: CCR = 500 - 1 = 499 (or just 500 if you’re not using “+1” convention).\n\nPWM at 220 Hz: same PSC = 15 ⇒ f_tim = 1 MHz. ARR ≈ 1,000,000/220 − 1 = 4545 − 1 = 4544. 50%: CCR = 2272.\n\nToggle at 440 Hz (A4): PSC = 15 ⇒ f_tim = 1 MHz. Need CCR = f_tim/(2*f) − 1 = 1e6/(880) − 1 ≈ 1136 − 1 = 1135.\n\n80 MHz (PLL to 80 MHz, common on L4)\n\nPWM at 1 kHz: PSC = 79 ⇒ f_tim = 1 MHz. ARR = 999.\n\nPWM at 220 Hz: PSC = 79 ⇒ ARR = 4544.\n\nToggle at 1 kHz: PSC = 79 ⇒ CCR = 1e6/(2*1000) − 1 = 499.\n\nAll of these fit in 16-bit easily; you don’t need TIM2’s 32-bit width, but it’s convenient.\n\nRegisters you’ll touch\nRCC (enable clocks)\n\nGPIO: RCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOxEN;\n\nTimer:\n\nTIM2/TIM6/7/15/16/17 → RCC-&gt;APB1ENR1 or APB2ENR (TIM1/15/16/17 are on APB2).\n\nExample: RCC-&gt;APB1ENR1 |= RCC_APB1ENR1_TIM2EN;\nRCC-&gt;APB2ENR |= RCC_APB2ENR_TIM1EN;\n\nGPIO (put the pin in Alternate Function)\n\nMODER: set to AF for your pin (10b).\n\nAFRL/AFRH: set AF# for the chosen timer channel (e.g., AF1 for TIM1/TIM2 on many L4 pins).\n\nOptional: OSPEEDR medium/high, PUPDR none, OTYPER push-pull.\n\nTimer core (common)\n\nPSC – prescaler\n\nARR – auto-reload (period); set before enabling counter\n\nCR1 – ARPE=1 (preload ARR), CEN=1 to start; DIR=0 for upcount\n\nOptional: EGR |= UG to force an update event so new PSC/ARR latch immediately\n\nPWM mode specifics\n\nCCMRx: set OCxM = 110 (PWM mode 1); OCxPE=1 (preload enable)\n\nCCR x: duty value (0…ARR)\n\nCCER: CCxE=1 (enable channel), choose polarity (CCxP=0 for active high)\n\nTIM1 only (advanced timer): BDTR: set MOE=1 (Main Output Enable) or nothing will come out\n\nOutput Compare TOGGLE mode specifics\n\nCCMRx: OCxM = 011 (Toggle), OCxPE=0 (typically no preload), CCR x = half-period − 1 in ticks\n\nCCER: **CCxE=1`\n\nARR: can be large; in toggle mode you don’t need it to set the frequency (but keep it ≥ CCR)\n\nMinimal LL-style pseudo-sequence\nA) TIM2 PWM @ 1 kHz, 50% on PA0 (TIM2_CH1 as an example)\n// clocks\nRCC-&gt;AHB2ENR  |= RCC_AHB2ENR_GPIOAEN;\nRCC-&gt;APB1ENR1 |= RCC_APB1ENR1_TIM2EN;\n\n// PA0 -&gt; AF1 (TIM2_CH1)\nGPIOA-&gt;MODER   = (GPIOA-&gt;MODER & ~(3U &lt;&lt; (0*2))) | (2U &lt;&lt; (0*2));\nGPIOA-&gt;AFR[0]  = (GPIOA-&gt;AFR[0] & ~(0xF &lt;&lt; (0*4))) | (0x1 &lt;&lt; (0*4)); // AF1\nGPIOA-&gt;OSPEEDR = (GPIOA-&gt;OSPEEDR & ~(3U &lt;&lt; (0*2))) | (2U &lt;&lt; (0*2));  // medium/high\n\n// timer base: f_clk=80MHz -&gt; PSC=79 =&gt; f_tim=1MHz\nTIM2-&gt;PSC = 79;\nTIM2-&gt;ARR = 999;          // 1 kHz\nTIM2-&gt;CCR1 = 500;         // ~50%\n\n// PWM mode 1 on CH1\nTIM2-&gt;CCMR1 = (TIM2-&gt;CCMR1 & ~TIM_CCMR1_OC1M) | (6U &lt;&lt; TIM_CCMR1_OC1M_Pos);\nTIM2-&gt;CCMR1 |= TIM_CCMR1_OC1PE;  // preload\nTIM2-&gt;CCER  |= TIM_CCER_CC1E;    // enable output\n\nTIM2-&gt;CR1 |= TIM_CR1_ARPE;       // ARR preload\nTIM2-&gt;EGR |= TIM_EGR_UG;         // latch PSC/ARR/CCR\nTIM2-&gt;CR1 |= TIM_CR1_CEN;        // go\n\nB) TIM2 TOGGLE @ 440 Hz on PA0 (exact 50% square, set-and-forget)\n// clocks & pin same as above...\n\nTIM2-&gt;PSC = 79;            // 80MHz/80 = 1MHz tick\nTIM2-&gt;CCR1 = 1135;         // f_out = 1e6 / (2*(1135+1)) ≈ 440 Hz\nTIM2-&gt;ARR = 0xFFFF;        // big enough (not critical)\n\n// OC toggle on CH1\nTIM2-&gt;CCMR1 = (TIM2-&gt;CCMR1 & ~TIM_CCMR1_OC1M) | (3U &lt;&lt; TIM_CCMR1_OC1M_Pos); // toggle\nTIM2-&gt;CCER  |= TIM_CCER_CC1E;\n\nTIM2-&gt;EGR |= TIM_EGR_UG;\nTIM2-&gt;CR1 |= TIM_CR1_CEN;\n\nC) TIM1 PWM (remember BDTR/MOE)\nRCC-&gt;APB2ENR |= RCC_APB2ENR_TIM1EN;\n// ...GPIO to AF for TIM1_CH1 (e.g., PA8/AF1)...\nTIM1-&gt;PSC = 79; TIM1-&gt;ARR = 999; TIM1-&gt;CCR1 = 500;\nTIM1-&gt;CCMR1 = (TIM1-&gt;CCMR1 & ~TIM_CCMR1_OC1M) | (6U &lt;&lt; TIM_CCMR1_OC1M_Pos);\nTIM1-&gt;CCMR1 |= TIM_CCMR1_OC1PE;\nTIM1-&gt;CCER  |= TIM_CCER_CC1E;\nTIM1-&gt;BDTR  |= TIM_BDTR_MOE;   // **required** for TIM1\nTIM1-&gt;CR1   |= TIM_CR1_ARPE;\nTIM1-&gt;EGR   |= TIM_EGR_UG;\nTIM1-&gt;CR1   |= TIM_CR1_CEN;\n\nPractical picking guidance\n\nJust tones (always 50%)? Use TIM2 + OC Toggle. One register (CCR) sets the frequency; rock-solid 50% duty.\n\nWant variable duty / envelopes / volume via duty? Use PWM mode on TIM2 (simplest routing) or TIM1 (if you need advanced features, dead-time, etc.).\n\nPin choice: Favour PA0..PA3 (TIM2 CH1..4) or PA8..PA11 (TIM1 CH1..4) because they’re commonly available on L432KC boards. Confirm the AF number for your exact pin in the datasheet’s AF table.\n\nIf you tell me your exact pin and your current system clock (16 MHz HSI vs 80 MHz PLL), I can drop in the exact (PSC, ARR, CCR) values for 220 Hz, 261.63 Hz, … up to 1 kHz in whichever mode you prefer.\n\nIt was honestly pretty useful. It walked through why you would want to use certain timers, what kinds of bits you need to enable, and the general formula for the thought process. It gave a more confident, even better answer after inputting the reference manual. It’s good for understanding general process flow, but I think I still wouldn’t trust it for the exact bits because a lot of precision and thought specific to your design is needed for the code."
  },
  {
    "objectID": "labs/lab4/lab4.html#lab-4-digital-audio",
    "href": "labs/lab4/lab4.html#lab-4-digital-audio",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, I learned how to use my MCU to play music by using timers. These timers generated square waves by toggling a GPIO pin at a specific frequency for specified durations. This lab also served as an introduction to working with the STM32 microcontroller boards. I gained a lot of experience with reading proper documentation (reference manual and datasheet) to understand clocks, timers, register, I/O, and more. The end result consisted of playing “Fur Elise” and my chosen song of “Hedwig’s Theme” from Harry Potter!\n\n\n\n\n\nI used the Timer 15 and Timer 16 registers in order to output a square wave signal from the microcontroller. For this lab, we had to read the datasheet carefully and write our own library in C from scratch. One of the reasons I chose Timers 15 and 16 is because they have the same register map. This meant I could take advantage of only having to write one struct in my timer header file. Another reason I chose these timers is that they both have the ability to be configured to a PWM mode and be connected to a GPIO pin in alternate function mode in order to have the desired functionality of producing a square wave output.\nAfter writing my header file, I wrote my timer source code, which consisted of four functions: initTIM to initialize my timer, delay_millis to provide a millisecond delay to set my note durations, initPWM to initialize the PWM mode of Timer 16, and setFreq to set the square wave to the desired frequency. Writing these four functions was the most difficult part of the lab, as they consisted of hours reading the reference manual to understand configuration, registers, and precisely which bits to set in which order to produce the desired functionality.\n\n\n\nTo go into more details on how the timers work, the timer configured in the PWM mode had the auto reload register (ARR) and the capture/compare register (CCR1) set in order to produce a specific period and duty cycle. The ARR value is set such that when the counter is equal to this value, it resets to 0, meaning this value sets the period of the signal. When the counter is less than the CCR1 value, it outputs a low (0), and when the counter is higher, it outputs a high (1), meaning the CCR1 value sets teh duty cycle. I set the CCR1 value to be half of the ARR value to have a duty cycle of 0.5. For the timer configured to set the delay, I utilized the ARR to control the delay, as it was set depending on the millisecond input.\nIn this lab, I used a phase-locked-loop (PLL) to set the microcontroller clock at 80 MHz, and to produce lower frequencies, I used prescalers. The timing calculations and theory behind my prescaler values are shown below in Figure 1.\n\n\n\nFigure 1. Timing calculations for frequency of sound output\n\n\nIn order to make sure that the minimum and maximum frequency and duration were supported with my chosen prescaler values, I did the calculations shown below in Figure 2.\n\n\n\nFigure 2. Max and min duration and frequency calculations\n\n\nOne of the specs for this lab was to produce individual pitches calculated to be accurate within 1% across the frequency range of 220-1000 Hz. Using the derived formula in figure 1 and careful unit conversion, I ran a timing analysis across this frequency range to make sure the spec was met. The calculations used to program the spreadsheet, showing examples of the pitches and durations being correct, as well as the resulting data is shown below in Figure 3 and 4, respectively.\n\n\n\nFigure 3. Calculations for spreadsheet and examples\n\n\n\n\n\nFigure 4. Pitch accuracy spreadsheet\n\n\n\n\n\nIn order to test the software’s functionality first, I uploaded the code to my MCU and used an oscilloscope to read the values of the GPIO pin to check that I was seeing the correct duty cycle and frequency. There was a lot of troubleshooting here, as I originlly did not see any square waves. I used Segger’s built in Debug mode to step through my code and ensure that all my registers were getting the value they were supposed to. After debugging and changing the way I configured/enabled things in my code, I started to see the correct frequency square waves in the oscilloscope.\n\n\n\n\nThe source code for the project can be found in the associated Github repository.\n\n\nThe circuit for this lab was simple. It contained an LM386 audio amplifier to drive the 8 ohm speaker and a potentiometer for volume control. The schematic is shown below in Figure 5.\n\n\n\nFigure 5. Schematic for audio amplifier circuit\n\n\n\n\n\n\nThe design met all the intended objectives. The hardware for this lab, which was tested after making sure the software worked properly, worked on the first try. To encode a new song, I found the site music for music from Harry Potter, and transcribed the notes into frequencies using the table from the class website. A video of the final result, including Fur Elise and Hedwig’s Theme from Harry Potter, is shown below.\n\n\n\n\nI was successfully able to use my MCU to play music in this lab! The learning curve was steep, as this was my first time writing libraries in C and using a microcontroller in depth. However, I got really comfortable reading the datasheet and reference manual, and I gained a better understanding of the STM32 overall. In total, I spent 19 hours on this lab.\n\n\n\nThis was the prompt I entered into ChatGPT: What timers should I use on the STM32L432KC to generate frequencies ranging from 220Hz to 1kHz? What’s the best choice of timer if I want to easily connect it to a GPIO pin? What formulae are relevant, and what registers need to be set to configure them properly?\nThis is the answer it gave me:\nGreat question. On the STM32L432KC you’ve got several timers that can do this cleanly.\n\nWhich timer(s) to use\n\nEasiest “hook to a GPIO and forget it” (50% square wave):\nTIM2 (general-purpose, 32-bit) using Output Compare Toggle mode. It routes to lots of pins (e.g., PA0…PA3 for CH1…CH4 on most L4s), and since it’s 32-bit you’ll never worry about running out of counts.\n\nIf you might want PWM duty control now or later:\nTIM1 (advanced) or TIM2 / TIM15 / TIM16 / TIM17 in PWM mode. TIM1 has “advanced” features (BDTR/MOE), but TIM2 is simplest and widely pinned out. Pick whichever has a channel available on a pin you’ve broken out; PA8 (TIM1_CH1) and PA0 (TIM2_CH1) are common.\n(Exact pin/AF depends on your board; check the “Alternate function mapping” table for the L432KC to pick the cleanest pin.)\n\nCore formulas (you’ll use these every time)\n\nLet f_tim be the timer’s input clock after the prescaler:\n\nf_tim = f_clk / (PSC + 1)\n\nPWM / update frequency (ARR reload):\nf_out = f_tim / (ARR + 1)\n\nPWM duty (edge-aligned):\nduty = (CCR + 1) / (ARR + 1) → for 50%, set CCR = ARR / 2.\n\nOutput-compare TOGGLE (pure 50% square):\nThe pin toggles each compare event, so period is 2×(CCR+1) ticks →\nf_out = f_tim / (2 * (CCR + 1))\n\nThese let you hit anything from 220 Hz to 1 kHz by choosing (PSC, ARR) for PWM or (PSC, CCR) for toggle.\n\nQuick worked choices (two common clock setups)\n\nAssume the timer clock (f_clk) is:\n\n16 MHz (HSI default)\n\nPWM at 1 kHz: pick PSC = 15 ⇒ f_tim = 1 MHz. Need ARR = 999 for 1 kHz. 50%: CCR = 500 - 1 = 499 (or just 500 if you’re not using “+1” convention).\n\nPWM at 220 Hz: same PSC = 15 ⇒ f_tim = 1 MHz. ARR ≈ 1,000,000/220 − 1 = 4545 − 1 = 4544. 50%: CCR = 2272.\n\nToggle at 440 Hz (A4): PSC = 15 ⇒ f_tim = 1 MHz. Need CCR = f_tim/(2*f) − 1 = 1e6/(880) − 1 ≈ 1136 − 1 = 1135.\n\n80 MHz (PLL to 80 MHz, common on L4)\n\nPWM at 1 kHz: PSC = 79 ⇒ f_tim = 1 MHz. ARR = 999.\n\nPWM at 220 Hz: PSC = 79 ⇒ ARR = 4544.\n\nToggle at 1 kHz: PSC = 79 ⇒ CCR = 1e6/(2*1000) − 1 = 499.\n\nAll of these fit in 16-bit easily; you don’t need TIM2’s 32-bit width, but it’s convenient.\n\nRegisters you’ll touch\nRCC (enable clocks)\n\nGPIO: RCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOxEN;\n\nTimer:\n\nTIM2/TIM6/7/15/16/17 → RCC-&gt;APB1ENR1 or APB2ENR (TIM1/15/16/17 are on APB2).\n\nExample: RCC-&gt;APB1ENR1 |= RCC_APB1ENR1_TIM2EN;\nRCC-&gt;APB2ENR |= RCC_APB2ENR_TIM1EN;\n\nGPIO (put the pin in Alternate Function)\n\nMODER: set to AF for your pin (10b).\n\nAFRL/AFRH: set AF# for the chosen timer channel (e.g., AF1 for TIM1/TIM2 on many L4 pins).\n\nOptional: OSPEEDR medium/high, PUPDR none, OTYPER push-pull.\n\nTimer core (common)\n\nPSC – prescaler\n\nARR – auto-reload (period); set before enabling counter\n\nCR1 – ARPE=1 (preload ARR), CEN=1 to start; DIR=0 for upcount\n\nOptional: EGR |= UG to force an update event so new PSC/ARR latch immediately\n\nPWM mode specifics\n\nCCMRx: set OCxM = 110 (PWM mode 1); OCxPE=1 (preload enable)\n\nCCR x: duty value (0…ARR)\n\nCCER: CCxE=1 (enable channel), choose polarity (CCxP=0 for active high)\n\nTIM1 only (advanced timer): BDTR: set MOE=1 (Main Output Enable) or nothing will come out\n\nOutput Compare TOGGLE mode specifics\n\nCCMRx: OCxM = 011 (Toggle), OCxPE=0 (typically no preload), CCR x = half-period − 1 in ticks\n\nCCER: **CCxE=1`\n\nARR: can be large; in toggle mode you don’t need it to set the frequency (but keep it ≥ CCR)\n\nMinimal LL-style pseudo-sequence\nA) TIM2 PWM @ 1 kHz, 50% on PA0 (TIM2_CH1 as an example)\n// clocks\nRCC-&gt;AHB2ENR  |= RCC_AHB2ENR_GPIOAEN;\nRCC-&gt;APB1ENR1 |= RCC_APB1ENR1_TIM2EN;\n\n// PA0 -&gt; AF1 (TIM2_CH1)\nGPIOA-&gt;MODER   = (GPIOA-&gt;MODER & ~(3U &lt;&lt; (0*2))) | (2U &lt;&lt; (0*2));\nGPIOA-&gt;AFR[0]  = (GPIOA-&gt;AFR[0] & ~(0xF &lt;&lt; (0*4))) | (0x1 &lt;&lt; (0*4)); // AF1\nGPIOA-&gt;OSPEEDR = (GPIOA-&gt;OSPEEDR & ~(3U &lt;&lt; (0*2))) | (2U &lt;&lt; (0*2));  // medium/high\n\n// timer base: f_clk=80MHz -&gt; PSC=79 =&gt; f_tim=1MHz\nTIM2-&gt;PSC = 79;\nTIM2-&gt;ARR = 999;          // 1 kHz\nTIM2-&gt;CCR1 = 500;         // ~50%\n\n// PWM mode 1 on CH1\nTIM2-&gt;CCMR1 = (TIM2-&gt;CCMR1 & ~TIM_CCMR1_OC1M) | (6U &lt;&lt; TIM_CCMR1_OC1M_Pos);\nTIM2-&gt;CCMR1 |= TIM_CCMR1_OC1PE;  // preload\nTIM2-&gt;CCER  |= TIM_CCER_CC1E;    // enable output\n\nTIM2-&gt;CR1 |= TIM_CR1_ARPE;       // ARR preload\nTIM2-&gt;EGR |= TIM_EGR_UG;         // latch PSC/ARR/CCR\nTIM2-&gt;CR1 |= TIM_CR1_CEN;        // go\n\nB) TIM2 TOGGLE @ 440 Hz on PA0 (exact 50% square, set-and-forget)\n// clocks & pin same as above...\n\nTIM2-&gt;PSC = 79;            // 80MHz/80 = 1MHz tick\nTIM2-&gt;CCR1 = 1135;         // f_out = 1e6 / (2*(1135+1)) ≈ 440 Hz\nTIM2-&gt;ARR = 0xFFFF;        // big enough (not critical)\n\n// OC toggle on CH1\nTIM2-&gt;CCMR1 = (TIM2-&gt;CCMR1 & ~TIM_CCMR1_OC1M) | (3U &lt;&lt; TIM_CCMR1_OC1M_Pos); // toggle\nTIM2-&gt;CCER  |= TIM_CCER_CC1E;\n\nTIM2-&gt;EGR |= TIM_EGR_UG;\nTIM2-&gt;CR1 |= TIM_CR1_CEN;\n\nC) TIM1 PWM (remember BDTR/MOE)\nRCC-&gt;APB2ENR |= RCC_APB2ENR_TIM1EN;\n// ...GPIO to AF for TIM1_CH1 (e.g., PA8/AF1)...\nTIM1-&gt;PSC = 79; TIM1-&gt;ARR = 999; TIM1-&gt;CCR1 = 500;\nTIM1-&gt;CCMR1 = (TIM1-&gt;CCMR1 & ~TIM_CCMR1_OC1M) | (6U &lt;&lt; TIM_CCMR1_OC1M_Pos);\nTIM1-&gt;CCMR1 |= TIM_CCMR1_OC1PE;\nTIM1-&gt;CCER  |= TIM_CCER_CC1E;\nTIM1-&gt;BDTR  |= TIM_BDTR_MOE;   // **required** for TIM1\nTIM1-&gt;CR1   |= TIM_CR1_ARPE;\nTIM1-&gt;EGR   |= TIM_EGR_UG;\nTIM1-&gt;CR1   |= TIM_CR1_CEN;\n\nPractical picking guidance\n\nJust tones (always 50%)? Use TIM2 + OC Toggle. One register (CCR) sets the frequency; rock-solid 50% duty.\n\nWant variable duty / envelopes / volume via duty? Use PWM mode on TIM2 (simplest routing) or TIM1 (if you need advanced features, dead-time, etc.).\n\nPin choice: Favour PA0..PA3 (TIM2 CH1..4) or PA8..PA11 (TIM1 CH1..4) because they’re commonly available on L432KC boards. Confirm the AF number for your exact pin in the datasheet’s AF table.\n\nIf you tell me your exact pin and your current system clock (16 MHz HSI vs 80 MHz PLL), I can drop in the exact (PSC, ARR, CCR) values for 220 Hz, 261.63 Hz, … up to 1 kHz in whichever mode you prefer.\n\nIt was honestly pretty useful. It walked through why you would want to use certain timers, what kinds of bits you need to enable, and the general formula for the thought process. It gave a more confident, even better answer after inputting the reference manual. It’s good for understanding general process flow, but I think I still wouldn’t trust it for the exact bits because a lot of precision and thought specific to your design is needed for the code."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Shreya Jampana is an Engineering student at Harvey Mudd College. Her academic interests lie primarily in analog and digital electronics, RF, and embedded systems with applications in biotechnology. Outside of the classroom, you can find her in the machine shop, camping at a national park, or reading with sunset view."
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "E155 Course Website"
  },
  {
    "objectID": "resources.html#resources",
    "href": "resources.html#resources",
    "title": "E155 Portfolio",
    "section": "",
    "text": "E155 Course Website"
  }
]
[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Post #1\n\n\nPersonal goals for E155\n\n\n\n\n\nAug 29, 2025\n\n\nShreya Jampana\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Shreya Jampana is an Engineering student at Harvey Mudd College. Her academic interests lie primarily in analog and digital electronics, RF, and embedded systems with applications in biotechnology. Outside of the classroom, you can find her in the machine shop, camping at a national park, or reading with sunset view."
  },
  {
    "objectID": "labs/labs.html",
    "href": "labs/labs.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "List of E155 Labs\nLab 1 - Board Assembly and Testing\nLab 2 - Multiplexed 7-Segment Display\nLab 3 - Keypad Scanner\nLab 4 - Digital Audio\nLab 5 - Interrupts\nLab 6 - The Internet of Things and Serial Peripheral Interface\nLab 7 - The Advanced Encryption Standard (AES)"
  },
  {
    "objectID": "labs/labs.html#labs-overview",
    "href": "labs/labs.html#labs-overview",
    "title": "E155 Portfolio",
    "section": "",
    "text": "List of E155 Labs\nLab 1 - Board Assembly and Testing\nLab 2 - Multiplexed 7-Segment Display\nLab 3 - Keypad Scanner\nLab 4 - Digital Audio\nLab 5 - Interrupts\nLab 6 - The Internet of Things and Serial Peripheral Interface\nLab 7 - The Advanced Encryption Standard (AES)"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, we soldered our E155 protoboard and implemented designs on the FPGA to drive on-board LEDs and a seven segment display. Two of the LEDs outputted combinational logic, and one of them was blinked at a specific frequency using the on-board high-speed oscillator.\n\n\n\nAfter soldering and testing the FPGA, MCU, and the development board for proper functionality, I designed my FPGA to further test the hardware on my board and operate a 7-segment display. The design consisted of the following:\n\n\n\n\n\n\n\n\nSignal Name\nSignal Type\nDescription\n\n\n\n\nclk\ninput\n48 MHz clock on FPGA\n\n\ns[3:0]\ninput\nfour DIP switches (on the board)\n\n\nled[2:0]\noutput\n3 on-board LEDs\n\n\nseg[6:0]\noutput\nthe segments of a common-anode 7-segment display\n\n\n\nThere were two primary aspects to this lab: operate three on-board LEDs (led[0], led[1], and led[2]) and create a 7-segment display.\nThe relationship between the switches (s0, s1, s2, s3) and the first two LEDs (led[0] and led[1]) were provided in the form of truth tables. Upon deriving the combinational logic, it was clear that led[0] was an exclusive or (XOR) of s0 and s1, while led[1] was an AND of s2 and s3. The third LED, led[3], was to be blinked at 2.4Hz. This was done using the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library. This oscillator generated a 48 MHz clock, and a counter was used to divide this down so the blinking frequency could be visualized on led[2]. In order to generate a 2.4 Hz signal that would complete a half cycle, a clock divider module was designed to count every (0.5)* 48 MHz/2.4 Hz, or 10 million ticks.\nThe 7-segment display was designed to display a signle hexadecimal digit specified by a four bit binary input s[3:0]. To do this, a separate SystemVerliog module was written, which contained 16 case statements detailing which segments of the display should be lit to create the hexademical digit corresponding to the dip switch input of s[3:0]. When breadboarding this design, it was important to remember that in the common annode display we were working with, a logic 0 applied to the cathode turned on the segment.\nAfter designing the modules on SystemVerilog and programming the designs to the FPGA, we tested our design. For the LEDs, in order to test led[0] and led[1], we tried the different combination logic using the switches to ensure the proper XOR and AND gate functionality. For led[2], we used an oscilloscope to verify the blink frequency of 2.4 Hz. To test the 7-segment display, we operated the DIP switches to ensure that the four bit binary numbers displayed their corresponding hexadecimal digit with equal brightness in segments, as shown in Figure 1.\n\n\n\nFigure 1. Output of hex digit 5 for a binary input of 4’b0101\n\n\nIn order to enxure that the current draw for each segment in the 7-segment display was within recommended operating conditions, the calculations shown in Figure 2 were done. The absolute maximum current rating is 20 mA, and as the calculations show, we have a 1.3 mA current draw, which is standard for LEDs.\n\n\n\nFigure 2. Calculations for current draw in 7-segment display\n\n\n\n\n\nThe source code for the project can be found in the associated Github repository.\n\n\n\n\n\nFigure 3. Block diagram of the Verilog module\n\n\nThe block diagram shown in Figure 3 demonstrates the overall architecture of the design. The top-level module (top) includes two submodules: the high-speed oscillator block (HSOSC) and the module to operate the 7-segment display. The operation of the LEDs happens in the top-level module as combinational logic.\n\n\n\n\n\n\nFigure 4. Schematic of the physical circuit\n\n\nThe physical layout of the design is shown in Figure 4. The left side of the UPduino shows the inputs, while the right side shows the outputs. The inputs consist of a reset button and four switches. An internal 100 kΩ pullup resistor was used to ensure the active low reset pin was not floating. The outputs consist of the seven LEDs from the 7-segment display, and three LEDs to test the combinational logic and blinking. These LEDs are connected using a 1kΩ current-limiting resistor to ensure the output current did not exceed the maximum output current of the FPGA I/O pins.\n\n\n\n\n\n\nTwo testbenches were written in SystemVerilog, one for the top-level and one for the 7-segment display modules, in order to verify that the designs were working as intended. Using the written test vectors, the testbenches ran all 16 cominations of the DIP switches in order to simulate and test if the led[2:0] and seg[6:0] outputs matched the expected outputs.\nAs shown in the simulation images shown in Figures 5 and 6, all the simulations passed and produced the expected outputs. Therefore, the design met all of the intended design objectives, and performed quickly and reliably. The simulations shown below ran in just a few seconds, and the hardware displayed all the required lights brightly.\n\n\n\nFigure 5. Top-level module QuestaSim simulation\n\n\n\n\n\nFigure 6. 7-segment module QuestaSim simulation\n\n\n\n\n\n\nMy FPGA designs successfully controlled a 7-segment display and LEDs, thus validating the functionality of my soldered protoboard. By blinking one of the LEDs at 2.4 Hz, I also validated the functionality of the on-board high-speed oscillator. In total, I spent 25 hours on this lab.\n\n\n\nUpon typing the following prompt into ChatGPT, the following code, along with the comment, was generated, as shown in Figures 7 and 8:\nLLM Prompt: Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\n\n\n\nFigure 7. Code generated by LLM\n\n\n\n\n\nFigure 8. Comment generated by LLM\n\n\nThe LLM-generated code was synthesized the first time around in Radiant. There were no errors and a few warnings in synthesis, but these warnings only pointed to top-level module declaration. These warnings were not related to the code itself.\nThe logic to blink the 2 Hz LED operated on the same principle: have a set number of toggle cycles, and when the counter reaches this number, reset the counter and blink the LED. The math to blink the LED was also the same: 48MHz divided by two times the desired blink frequency of 2 Hz.\nOne of the first differences I noticed was that there was no reset or reset case within the clock divide in the LLM-generated code. Another between my top-level module and the LLM-generated code is the declaration/usage of the internal high-speed oscillator. The module was declared using the # operator for parameter passing, but had essentially the same arguments as my one line of code. Another syntax that was new to me was the usage of “localparam” to define the variables (such as the number of toggle cycles) fixed within the design. A stylistic difference I noticed is that the calculations for the toggle cycle were included in the code generated by the LLM as variables, whereas I only included the final number of cycles. I liked the LLM’s version, as it was clear to follow the mathematical reasoning behind the number of cycles.\nI would rate the quality of the output pretty highly, as it was able to do the most difficult parts of this code generation quickly and efficiently. It demonstrated how to generate the number of toggles, how to use the internal high-speed oscillator, and how to create the clock divider, which are the main parts of this code. If I were to use an LLM in my workflow next time, I think I would specify SystemVerilog constructs/syntax I was familiar with in order to receive code that is most catered to my understanding."
  },
  {
    "objectID": "labs/lab1/lab1.html#lab-1-fpga-and-mcu-setup-and-testing",
    "href": "labs/lab1/lab1.html#lab-1-fpga-and-mcu-setup-and-testing",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, we soldered our E155 protoboard and implemented designs on the FPGA to drive on-board LEDs and a seven segment display. Two of the LEDs outputted combinational logic, and one of them was blinked at a specific frequency using the on-board high-speed oscillator.\n\n\n\nAfter soldering and testing the FPGA, MCU, and the development board for proper functionality, I designed my FPGA to further test the hardware on my board and operate a 7-segment display. The design consisted of the following:\n\n\n\n\n\n\n\n\nSignal Name\nSignal Type\nDescription\n\n\n\n\nclk\ninput\n48 MHz clock on FPGA\n\n\ns[3:0]\ninput\nfour DIP switches (on the board)\n\n\nled[2:0]\noutput\n3 on-board LEDs\n\n\nseg[6:0]\noutput\nthe segments of a common-anode 7-segment display\n\n\n\nThere were two primary aspects to this lab: operate three on-board LEDs (led[0], led[1], and led[2]) and create a 7-segment display.\nThe relationship between the switches (s0, s1, s2, s3) and the first two LEDs (led[0] and led[1]) were provided in the form of truth tables. Upon deriving the combinational logic, it was clear that led[0] was an exclusive or (XOR) of s0 and s1, while led[1] was an AND of s2 and s3. The third LED, led[3], was to be blinked at 2.4Hz. This was done using the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library. This oscillator generated a 48 MHz clock, and a counter was used to divide this down so the blinking frequency could be visualized on led[2]. In order to generate a 2.4 Hz signal that would complete a half cycle, a clock divider module was designed to count every (0.5)* 48 MHz/2.4 Hz, or 10 million ticks.\nThe 7-segment display was designed to display a signle hexadecimal digit specified by a four bit binary input s[3:0]. To do this, a separate SystemVerliog module was written, which contained 16 case statements detailing which segments of the display should be lit to create the hexademical digit corresponding to the dip switch input of s[3:0]. When breadboarding this design, it was important to remember that in the common annode display we were working with, a logic 0 applied to the cathode turned on the segment.\nAfter designing the modules on SystemVerilog and programming the designs to the FPGA, we tested our design. For the LEDs, in order to test led[0] and led[1], we tried the different combination logic using the switches to ensure the proper XOR and AND gate functionality. For led[2], we used an oscilloscope to verify the blink frequency of 2.4 Hz. To test the 7-segment display, we operated the DIP switches to ensure that the four bit binary numbers displayed their corresponding hexadecimal digit with equal brightness in segments, as shown in Figure 1.\n\n\n\nFigure 1. Output of hex digit 5 for a binary input of 4’b0101\n\n\nIn order to enxure that the current draw for each segment in the 7-segment display was within recommended operating conditions, the calculations shown in Figure 2 were done. The absolute maximum current rating is 20 mA, and as the calculations show, we have a 1.3 mA current draw, which is standard for LEDs.\n\n\n\nFigure 2. Calculations for current draw in 7-segment display\n\n\n\n\n\nThe source code for the project can be found in the associated Github repository.\n\n\n\n\n\nFigure 3. Block diagram of the Verilog module\n\n\nThe block diagram shown in Figure 3 demonstrates the overall architecture of the design. The top-level module (top) includes two submodules: the high-speed oscillator block (HSOSC) and the module to operate the 7-segment display. The operation of the LEDs happens in the top-level module as combinational logic.\n\n\n\n\n\n\nFigure 4. Schematic of the physical circuit\n\n\nThe physical layout of the design is shown in Figure 4. The left side of the UPduino shows the inputs, while the right side shows the outputs. The inputs consist of a reset button and four switches. An internal 100 kΩ pullup resistor was used to ensure the active low reset pin was not floating. The outputs consist of the seven LEDs from the 7-segment display, and three LEDs to test the combinational logic and blinking. These LEDs are connected using a 1kΩ current-limiting resistor to ensure the output current did not exceed the maximum output current of the FPGA I/O pins.\n\n\n\n\n\n\nTwo testbenches were written in SystemVerilog, one for the top-level and one for the 7-segment display modules, in order to verify that the designs were working as intended. Using the written test vectors, the testbenches ran all 16 cominations of the DIP switches in order to simulate and test if the led[2:0] and seg[6:0] outputs matched the expected outputs.\nAs shown in the simulation images shown in Figures 5 and 6, all the simulations passed and produced the expected outputs. Therefore, the design met all of the intended design objectives, and performed quickly and reliably. The simulations shown below ran in just a few seconds, and the hardware displayed all the required lights brightly.\n\n\n\nFigure 5. Top-level module QuestaSim simulation\n\n\n\n\n\nFigure 6. 7-segment module QuestaSim simulation\n\n\n\n\n\n\nMy FPGA designs successfully controlled a 7-segment display and LEDs, thus validating the functionality of my soldered protoboard. By blinking one of the LEDs at 2.4 Hz, I also validated the functionality of the on-board high-speed oscillator. In total, I spent 25 hours on this lab.\n\n\n\nUpon typing the following prompt into ChatGPT, the following code, along with the comment, was generated, as shown in Figures 7 and 8:\nLLM Prompt: Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\n\n\n\nFigure 7. Code generated by LLM\n\n\n\n\n\nFigure 8. Comment generated by LLM\n\n\nThe LLM-generated code was synthesized the first time around in Radiant. There were no errors and a few warnings in synthesis, but these warnings only pointed to top-level module declaration. These warnings were not related to the code itself.\nThe logic to blink the 2 Hz LED operated on the same principle: have a set number of toggle cycles, and when the counter reaches this number, reset the counter and blink the LED. The math to blink the LED was also the same: 48MHz divided by two times the desired blink frequency of 2 Hz.\nOne of the first differences I noticed was that there was no reset or reset case within the clock divide in the LLM-generated code. Another between my top-level module and the LLM-generated code is the declaration/usage of the internal high-speed oscillator. The module was declared using the # operator for parameter passing, but had essentially the same arguments as my one line of code. Another syntax that was new to me was the usage of “localparam” to define the variables (such as the number of toggle cycles) fixed within the design. A stylistic difference I noticed is that the calculations for the toggle cycle were included in the code generated by the LLM as variables, whereas I only included the final number of cycles. I liked the LLM’s version, as it was clear to follow the mathematical reasoning behind the number of cycles.\nI would rate the quality of the output pretty highly, as it was able to do the most difficult parts of this code generation quickly and efficiently. It demonstrated how to generate the number of toggles, how to use the internal high-speed oscillator, and how to create the clock divider, which are the main parts of this code. If I were to use an LLM in my workflow next time, I think I would specify SystemVerilog constructs/syntax I was familiar with in order to receive code that is most catered to my understanding."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Post #1",
    "section": "",
    "text": "This semester, my personal goal in E-155 is to bridge a gap in my skill set: while I’ve always been drawn to analog circuitry and PCB design, I want to grow more confident in the digital side of hardware. I’m excited by the wide applications of embedded systems, from everyday devices to specialized applications in medicine and beyond, and I see this class as a chance to reframe how I think about hardware and software working together. I also want to get better at debugging with discipline rather than just trial and error. Another goal is to practice designing at the system level, balancing elegance with practicality, and then clearly communicating those decisions in reports and documentation. More broadly, I want to get comfortable with iteration and failure as part of the process, and to use the labs and project to experiment creatively and push myself beyond the bare minimum. After the labs and by the end of the semester, I hope to feel fluent enough in digital design to integrate it with my analog interests, and to carry that confidence into a really cool final project and beyond!"
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "E155 Course Website"
  },
  {
    "objectID": "resources.html#resources",
    "href": "resources.html#resources",
    "title": "E155 Portfolio",
    "section": "",
    "text": "E155 Course Website"
  }
]
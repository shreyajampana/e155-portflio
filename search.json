[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Post #1\n\n\nPersonal goals for E155\n\n\n\n\n\nAug 29, 2025\n\n\nShreya Jampana\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Shreya Jampana is an Engineering student at Harvey Mudd College. Her academic interests lie primarily in analog and digital electronics, RF, and embedded systems with applications in biotechnology. Outside of the classroom, you can find her in the machine shop, camping at a national park, or reading with sunset view."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, time multiplexing was used to efficiently drive two seven-segment displays with a single set of FPGA I/O pins. The sum of both numbers were displayed on five separate LEDs. Additionally, transistors were used to drive large currents from the FPGA pins.\n\n\n\nThe design of the time multiplexing scheme was one of the main components of this lab. Time multiplexing is a technique that is used to share a common expensive hardware resource for several purposes at different times. In this lab, time multiplexing was used to drive a single seven-segment decoder module to run both halves of a dual display.\nIn terms of wiring, this is done by connecting a single GPIO pin on the FPGA to the same segment (e.g. segment e) on both the seven-segment displays. However, in order to control which half of the dual display is active, the common anode of only one display at a time is turned ON. The power to these two displays are controlled by two separate GPIO pins, which are toggled at a certain speed in order for two distinct numbers to appear simultaneously on each display. Due to the anode requiring more current than the FPGA output pin can drive, a 2N3906 PNP transistor was used to limit the base current and not draw too much from the FPGA pin. Both of the dual displays are controlled by four bit DIP switches, and the sum of both numbers is displayed as a five bit number on five separate LEDs. The hardware layout, with the breadboard and wiring as described above, is shown in Figure 1.\n\n\n\nFigure 1. Wiring of the dual seven-segment display, LEDs, and transistor circuits\n\n\nThe wiring and breadboard layout was intuitively done to enable easy debugging and be visually appealing. In order to justify resistor choices, calcuations were done, as shown in Figure 2, to ensure proper brightness of the five individual LEDs and that the current draw/sink on all the FPGA pins was below the currents specified in the recommended operating conditions.\n\n\n\nFigure 2. Calculations to justify chosen resistor values for the dual seven-segment display, the five individual LEDs, and the PNP transistor\n\n\nFrom a software standpoint, important decisions were made in order to split up the required tasks of the lab into respective modules. A top level module was used to instantiate the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library, which was the 48 MHz clock that was divided and used throughout the system. The top level module also contained the combinational logic for the five individual LEDs, as they were simple and therefore did not require a separate module.\nOne of the most important design considerations was the speed at which the two displays were toggled. This was done using a clock divider and 32-bit counter, where choosing different bits of the counter in the clock division allowed for different switching speeds. After testing, it was determined that the 18th bit of the counter produced a toggling speed that ensured that both hexadecimal digits lit up simultaneously without visible oscillation and without the digits bleeding into each other. At this speed, the clock divider enabled power to each of the displays in the dual display and the four bit inputs were sent one at a time to the seven segment module.\nIn order to verify the software, three testbenches were written with one for each module——top level, seven-segment, and multiplexer. The seven-segment testbench checked that the correct segments displayed with the corresponding four bit inpupts. The top level testbench checked that the combinational logic for the five LEDs functioned as properly. The multiplexer module checked that the input to the seven segment display was the correct four bit input corresponding to which display was enabled. The testbenches also checked the toggling of the enable signals. The waveforms are shown in the Results and Discussion section. In order to test the hardware, all switches and their summing combinational logic was tested on the breadboard. A picture from one of these tests is shown below in Figure 3.\n\n\n\nFigure 3. Image from testing displaying functioning hardware. The hex digit “b” is displayed on the left, and “0” is displayed on the right, with their sum equalling 11 and being displayed on the five individual LEDs.\n\n\n\n\n\nThe source code for the project can be found in the associated Github repository.\n\n\n\n\n\nFigure 4. Block diagram of the Verilog module\n\n\nThe block diagram shown in Figure 4 demonstrates the overall architecture of the design. The top-level module includes three submodules: the high-speed oscillator block (HSOSC), the seven-segment module to operate the 7-segment display, and the multiplexer module to operate the correct switching/toggling of the dual displays.\n\n\n\n\n\n\nFigure 5. Schematic of the physical circuit\n\n\nThe physical layout of the design is shown in Figure 5. The left side of the UPduino shows the inputs, which are the reset and two sets of four-input DIP switches with an internal 100 kΩ pullup resistor to ensure the active low reset pin was not floating. The right side shows the outputs, which are the GPIO pins connecting the transistors to power, the two enables, the seven segments, and the five LEDs. All of the LEDs and transistors are connected to current-limiting resistors, the calculations for which are shown above in Figure 2.\n\n\n\n\n\n\nThree testbenches were written in SystemVerilog, one for each of the modules (top level, multiplexer, and seven-segment), in order to show that the combinational logic works and that the enables toggle and produce the correct, corresponding display.\nAs shown in the simulation images below, all the simulations passed and produced the expected outputs. Figures 6 and 7 show the simulation waveforms for the top level module. Figure 6 shows that the led variable is the correct sum of the 8-bit counter input. Figure 7 shows that when zoomed out, the enable toggles and tests the other cases. Figure 8 shows that s (input to the seven-segment module) gets the correct four bit input during the correct enable. In the waveforms, it is visible that the value of four bits of s_counter (the input) match the value of s one clock cycle later. This makes sense because s is an output of the multiplexer module, and thus displays its value one clock cycle later. Similar to the top level, zooming out shows that the enable switches as expected to test all the other cases. Figure 10 shows the seven-segment waveforms also producing the expected outputs for the segment values on the display.\n\n\n\nFigure 6. Top-level module QuestaSim simulation showing correct combinational logic\n\n\n\n\n\nFigure 7. Zoomed-out view of top-level module QuestaSim simulation showing the enables switching\n\n\n\n\n\nFigure 8. Multiplexer module QuestaSim simulation showing the seven-segment getting the correct input\n\n\n\n\n\nFigure 9. Zoomed-out view of multiplexer module QuestaSim simulation showing the enables switching\n\n\n\n\n\nFigure 10. Seven-segment module QuestaSim simulation\n\n\nTherefore, the design met all of the intended design objectives, and performed quickly and reliably. The simulations shown below ran in a few seconds, and the hardware displayed all the required LEDs brightly.\n\n\n\n\nMy FPGA designs successfully controlled a time multiplexing scheme to drive two 7-segment displays with a single set of FPGA I/O pins. A transistor to drive large currents from the FPGA pins was also successfully implemented. Additionally, I gained a lot of experience with building testbenches and modular Verilog systems.\nIn total, I spent 21 hours on this lab.\n\n\n\nUpon typing the following prompt into ChatGPT, the following code was generated:\nPrompt: Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.\nCode:\n// -----------------------------------------------------------------------------\n// Common–anode 7-segment decoder (active LOW segments)\n// seg_n order = {a,b,c,d,e,f,g}\n// -----------------------------------------------------------------------------\nmodule sevenseg_ca_decode (\n  input  logic [3:0] x,\n  output logic [6:0] seg_n\n);\n  always_comb begin\n    unique case (x)\n      4'h0: seg_n = 7'b0000001;\n      4'h1: seg_n = 7'b1001111;\n      4'h2: seg_n = 7'b0010010;\n      4'h3: seg_n = 7'b0000110;\n      4'h4: seg_n = 7'b1001100;\n      4'h5: seg_n = 7'b0100100;\n      4'h6: seg_n = 7'b0100000;\n      4'h7: seg_n = 7'b0001111;\n      4'h8: seg_n = 7'b0000000;\n      4'h9: seg_n = 7'b0000100;\n      4'hA: seg_n = 7'b0001000;\n      4'hB: seg_n = 7'b1100000; // 'b' as 11\n      4'hC: seg_n = 7'b0110001;\n      4'hD: seg_n = 7'b1000010; // 'd' as 13\n      4'hE: seg_n = 7'b0110000;\n      4'hF: seg_n = 7'b0111000;\n      default: seg_n = 7'b1111111; // all OFF\n    endcase\n  end\nendmodule\n\n\n// -----------------------------------------------------------------------------\n// Two-channel time-multiplexer using a single decoder instance\n//  - Alternates between in0 and in1 at a programmable rate\n//  - Latches each decoded pattern into seg0_n/seg1_n registers\n//  - Outputs are stable between refresh ticks (no comb fanout from muxed input)\n// -----------------------------------------------------------------------------\nmodule sevenseg_twoch_tmux #(\n  // Adjust these to set the update rate.\n  // Example: at 25 MHz, DIV=125_000 gives a 200 Hz tick (each channel ~100 Hz).\n  parameter int unsigned DIV = 125_000\n) (\n  input  logic        clk,\n  input  logic        rst_n,\n\n  input  logic [3:0]  in0,\n  input  logic [3:0]  in1,\n\n  output logic [6:0]  seg0_n,  // decoded output for in0 (active LOW)\n  output logic [6:0]  seg1_n   // decoded output for in1 (active LOW)\n);\n\n  // Clock divider to make a refresh \"tick\"\n  logic [$clog2(DIV)-1:0] div_cnt;\n  logic                   tick;\n\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      div_cnt &lt;= '0;\n      tick    &lt;= 1'b0;\n    end else if (div_cnt == DIV-1) begin\n      div_cnt &lt;= '0;\n      tick    &lt;= 1'b1;\n    end else begin\n      div_cnt &lt;= div_cnt + 1'b1;\n      tick    &lt;= 1'b0;\n    end\n  end\n\n  // Channel select toggles each tick\n  logic sel;  // 0 -&gt; service in0, 1 -&gt; service in1\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) sel &lt;= 1'b0;\n    else if (tick) sel &lt;= ~sel;\n  end\n\n  // Single decoder instance, input multiplexed\n  logic [3:0] muxed_in;\n  logic [6:0] dec_out_n;\n\n  assign muxed_in = sel ? in1 : in0;\n\n  sevenseg_ca_decode u_dec (\n    .x     (muxed_in),\n    .seg_n (dec_out_n)\n  );\n\n  // Register each channel's pattern when it is serviced\n  // This removes glitches and gives each output a steady value\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      seg0_n &lt;= 7'h7F;  // all off\n      seg1_n &lt;= 7'h7F;\n    end else if (tick) begin\n      if (sel)  seg1_n &lt;= dec_out_n; // just decoded in1\n      else      seg0_n &lt;= dec_out_n; // just decoded in0\n    end\n  end\n\nendmodule\nThe LLM-generated code was synthesized the first time around in Radiant. It did take a longer time to synthesize than code that I’ve written, but there were no errors.\nThe hierarchy of the code it generated was different than mine, as it only had two modules, and mine had three. The seven segment module it wrote was pretty identical to my seven segment module, but the top level in the LLM-generated code (which included my multiplexer module functionality as well) was quite different. One of the main differences was that it didn’t use the on-board high speed oscillator for the clock and instead generated and used a new clock divider. It used a variable called “DIV,” which is told us to adjust to set the update or switching rate. The LLM-generated code also had two signals for enabling that performed the multiplexing, but it had two seven bit outputs instead of one. The generated code was pretty different than mine in terms of syntax, hierarchy, and implementation, but it was interesting to see that it does the same function (more or less) and compiles without errors.\nNext, I started a new conversation in ChatGPT and uploaded the following prompt along with my lab 1 files (all source files) as context to get the LLM-generated code shown below.\nPrompt: Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.\nCode:\n// dual_sevenseg_mux.sv\n// Time-multiplex a single 7-seg decoder across two 4-bit inputs and\n// drive two independent 7-bit (common-anode) segment buses.\n\nmodule dual_sevenseg_mux #(\n    // Internal oscillator nominal frequency (UP5K HFOSC ~48 MHz)\n    parameter int unsigned CLK_HZ      = 48_000_000,\n    // Per-digit refresh rate (how often each digit is updated)\n    parameter int unsigned REFRESH_HZ  = 1_000\n)(\n    input  logic        rst_n,          // active-low async reset (tie high if unused)\n\n    input  logic [3:0]  in0,            // nibble for \"left\" display\n    input  logic [3:0]  in1,            // nibble for \"right\" display\n\n    output logic [6:0]  seg0,           // segments for display 0 (common anode: active-low segments)\n    output logic [6:0]  seg1            // segments for display 1\n);\n\n    // ----------------------------------------------------------------\n    // Internal high-speed oscillator (Lattice iCE40 UP family primitive)\n    // ----------------------------------------------------------------\n    logic clk_hf;\n    HSOSC hf_osc (\n        .CLKHFPU (1'b1),   // power up\n        .CLKHFEN (1'b1),   // enable\n        .CLKHF   (clk_hf)  // ~48 MHz clock out\n    );\n\n    // ---------------------------------------------------------------\n    // Refresh tick generator (sets the multiplexing cadence)\n    // Each digit is updated at REFRESH_HZ, so the decoder input\n    // switches at 2*REFRESH_HZ overall.\n    // ---------------------------------------------------------------\n    localparam int unsigned TICKS_PER_REFRESH = CLK_HZ / REFRESH_HZ;\n    localparam int unsigned CNTW = $clog2(TICKS_PER_REFRESH);\n\n    logic [CNTW-1:0] tick_cnt;\n    logic            refresh_tick;\n\n    always_ff @(posedge clk_hf or negedge rst_n) begin\n        if (!rst_n) begin\n            tick_cnt     &lt;= '0;\n            refresh_tick &lt;= 1'b0;\n        end else begin\n            if (tick_cnt == TICKS_PER_REFRESH-1) begin\n                tick_cnt     &lt;= '0;\n                refresh_tick &lt;= 1'b1;\n            end else begin\n                tick_cnt     &lt;= tick_cnt + 1'b1;\n                refresh_tick &lt;= 1'b0;\n            end\n        end\n    end\n\n    // ---------------------------------------------------------------\n    // Single decoder instance, input mux, and latched outputs\n    // ---------------------------------------------------------------\n    logic        sel;           // 0 -&gt; in0 path active, 1 -&gt; in1 path active\n    logic [3:0]  mux_in;        // presented to the decoder\n    logic [6:0]  dec_out;       // raw decoder output (active-low segments)\n\n    // Feed one nibble at a time into the single decoder\n    assign mux_in = (sel == 1'b0) ? in0 : in1;\n\n    // Your provided seven-seg decoder (common-anode) — adjust names if needed.\n    seven_seg_sj u_dec (\n        .value (mux_in),\n        .seg   (dec_out)\n    );\n\n    // Registers to hold each display’s last-decoded segments\n    logic [6:0] seg0_r, seg1_r;\n\n    // On each refresh tick:\n    //  - latch current decoder output into the register corresponding to `sel`\n    //  - then toggle `sel` so the *other* nibble is decoded next period\n    always_ff @(posedge clk_hf or negedge rst_n) begin\n        if (!rst_n) begin\n            sel   &lt;= 1'b0;\n            seg0_r &lt;= 7'h7F;   // all OFF for common-anode (active-low)\n            seg1_r &lt;= 7'h7F;\n        end else if (refresh_tick) begin\n            if (sel == 1'b0) begin\n                seg0_r &lt;= dec_out; // we were decoding in0; capture for seg0\n            end else begin\n                seg1_r &lt;= dec_out; // we were decoding in1; capture for seg1\n            end\n            sel &lt;= ~sel; // switch to decode the other input next\n        end\n    end\n\n    // Drive outputs\n    assign seg0 = seg0_r;\n    assign seg1 = seg1_r;\n\nendmodule\nThis LLM-generated code did synthesize relatively quickly but had one error——that it was instantiating an unknown module seven_seg_sj. This was a mistake on my part because I didn’t add my module into the project. Besides this, the code looks pretty similar to mine. It uses the high speed oscillator and chooses the correct dual display based on the enable. Once again, it does have two 7-bit outputs while I have one, and it also uses syntax I’m not familiar with. But overall, it was efficient code, and was even more similar to mine when I inputted my lab 1 files."
  },
  {
    "objectID": "labs/lab2/lab2.html#lab-2-multiplexed-7-segment-display",
    "href": "labs/lab2/lab2.html#lab-2-multiplexed-7-segment-display",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, time multiplexing was used to efficiently drive two seven-segment displays with a single set of FPGA I/O pins. The sum of both numbers were displayed on five separate LEDs. Additionally, transistors were used to drive large currents from the FPGA pins.\n\n\n\nThe design of the time multiplexing scheme was one of the main components of this lab. Time multiplexing is a technique that is used to share a common expensive hardware resource for several purposes at different times. In this lab, time multiplexing was used to drive a single seven-segment decoder module to run both halves of a dual display.\nIn terms of wiring, this is done by connecting a single GPIO pin on the FPGA to the same segment (e.g. segment e) on both the seven-segment displays. However, in order to control which half of the dual display is active, the common anode of only one display at a time is turned ON. The power to these two displays are controlled by two separate GPIO pins, which are toggled at a certain speed in order for two distinct numbers to appear simultaneously on each display. Due to the anode requiring more current than the FPGA output pin can drive, a 2N3906 PNP transistor was used to limit the base current and not draw too much from the FPGA pin. Both of the dual displays are controlled by four bit DIP switches, and the sum of both numbers is displayed as a five bit number on five separate LEDs. The hardware layout, with the breadboard and wiring as described above, is shown in Figure 1.\n\n\n\nFigure 1. Wiring of the dual seven-segment display, LEDs, and transistor circuits\n\n\nThe wiring and breadboard layout was intuitively done to enable easy debugging and be visually appealing. In order to justify resistor choices, calcuations were done, as shown in Figure 2, to ensure proper brightness of the five individual LEDs and that the current draw/sink on all the FPGA pins was below the currents specified in the recommended operating conditions.\n\n\n\nFigure 2. Calculations to justify chosen resistor values for the dual seven-segment display, the five individual LEDs, and the PNP transistor\n\n\nFrom a software standpoint, important decisions were made in order to split up the required tasks of the lab into respective modules. A top level module was used to instantiate the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library, which was the 48 MHz clock that was divided and used throughout the system. The top level module also contained the combinational logic for the five individual LEDs, as they were simple and therefore did not require a separate module.\nOne of the most important design considerations was the speed at which the two displays were toggled. This was done using a clock divider and 32-bit counter, where choosing different bits of the counter in the clock division allowed for different switching speeds. After testing, it was determined that the 18th bit of the counter produced a toggling speed that ensured that both hexadecimal digits lit up simultaneously without visible oscillation and without the digits bleeding into each other. At this speed, the clock divider enabled power to each of the displays in the dual display and the four bit inputs were sent one at a time to the seven segment module.\nIn order to verify the software, three testbenches were written with one for each module——top level, seven-segment, and multiplexer. The seven-segment testbench checked that the correct segments displayed with the corresponding four bit inpupts. The top level testbench checked that the combinational logic for the five LEDs functioned as properly. The multiplexer module checked that the input to the seven segment display was the correct four bit input corresponding to which display was enabled. The testbenches also checked the toggling of the enable signals. The waveforms are shown in the Results and Discussion section. In order to test the hardware, all switches and their summing combinational logic was tested on the breadboard. A picture from one of these tests is shown below in Figure 3.\n\n\n\nFigure 3. Image from testing displaying functioning hardware. The hex digit “b” is displayed on the left, and “0” is displayed on the right, with their sum equalling 11 and being displayed on the five individual LEDs.\n\n\n\n\n\nThe source code for the project can be found in the associated Github repository.\n\n\n\n\n\nFigure 4. Block diagram of the Verilog module\n\n\nThe block diagram shown in Figure 4 demonstrates the overall architecture of the design. The top-level module includes three submodules: the high-speed oscillator block (HSOSC), the seven-segment module to operate the 7-segment display, and the multiplexer module to operate the correct switching/toggling of the dual displays.\n\n\n\n\n\n\nFigure 5. Schematic of the physical circuit\n\n\nThe physical layout of the design is shown in Figure 5. The left side of the UPduino shows the inputs, which are the reset and two sets of four-input DIP switches with an internal 100 kΩ pullup resistor to ensure the active low reset pin was not floating. The right side shows the outputs, which are the GPIO pins connecting the transistors to power, the two enables, the seven segments, and the five LEDs. All of the LEDs and transistors are connected to current-limiting resistors, the calculations for which are shown above in Figure 2.\n\n\n\n\n\n\nThree testbenches were written in SystemVerilog, one for each of the modules (top level, multiplexer, and seven-segment), in order to show that the combinational logic works and that the enables toggle and produce the correct, corresponding display.\nAs shown in the simulation images below, all the simulations passed and produced the expected outputs. Figures 6 and 7 show the simulation waveforms for the top level module. Figure 6 shows that the led variable is the correct sum of the 8-bit counter input. Figure 7 shows that when zoomed out, the enable toggles and tests the other cases. Figure 8 shows that s (input to the seven-segment module) gets the correct four bit input during the correct enable. In the waveforms, it is visible that the value of four bits of s_counter (the input) match the value of s one clock cycle later. This makes sense because s is an output of the multiplexer module, and thus displays its value one clock cycle later. Similar to the top level, zooming out shows that the enable switches as expected to test all the other cases. Figure 10 shows the seven-segment waveforms also producing the expected outputs for the segment values on the display.\n\n\n\nFigure 6. Top-level module QuestaSim simulation showing correct combinational logic\n\n\n\n\n\nFigure 7. Zoomed-out view of top-level module QuestaSim simulation showing the enables switching\n\n\n\n\n\nFigure 8. Multiplexer module QuestaSim simulation showing the seven-segment getting the correct input\n\n\n\n\n\nFigure 9. Zoomed-out view of multiplexer module QuestaSim simulation showing the enables switching\n\n\n\n\n\nFigure 10. Seven-segment module QuestaSim simulation\n\n\nTherefore, the design met all of the intended design objectives, and performed quickly and reliably. The simulations shown below ran in a few seconds, and the hardware displayed all the required LEDs brightly.\n\n\n\n\nMy FPGA designs successfully controlled a time multiplexing scheme to drive two 7-segment displays with a single set of FPGA I/O pins. A transistor to drive large currents from the FPGA pins was also successfully implemented. Additionally, I gained a lot of experience with building testbenches and modular Verilog systems.\nIn total, I spent 21 hours on this lab.\n\n\n\nUpon typing the following prompt into ChatGPT, the following code was generated:\nPrompt: Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.\nCode:\n// -----------------------------------------------------------------------------\n// Common–anode 7-segment decoder (active LOW segments)\n// seg_n order = {a,b,c,d,e,f,g}\n// -----------------------------------------------------------------------------\nmodule sevenseg_ca_decode (\n  input  logic [3:0] x,\n  output logic [6:0] seg_n\n);\n  always_comb begin\n    unique case (x)\n      4'h0: seg_n = 7'b0000001;\n      4'h1: seg_n = 7'b1001111;\n      4'h2: seg_n = 7'b0010010;\n      4'h3: seg_n = 7'b0000110;\n      4'h4: seg_n = 7'b1001100;\n      4'h5: seg_n = 7'b0100100;\n      4'h6: seg_n = 7'b0100000;\n      4'h7: seg_n = 7'b0001111;\n      4'h8: seg_n = 7'b0000000;\n      4'h9: seg_n = 7'b0000100;\n      4'hA: seg_n = 7'b0001000;\n      4'hB: seg_n = 7'b1100000; // 'b' as 11\n      4'hC: seg_n = 7'b0110001;\n      4'hD: seg_n = 7'b1000010; // 'd' as 13\n      4'hE: seg_n = 7'b0110000;\n      4'hF: seg_n = 7'b0111000;\n      default: seg_n = 7'b1111111; // all OFF\n    endcase\n  end\nendmodule\n\n\n// -----------------------------------------------------------------------------\n// Two-channel time-multiplexer using a single decoder instance\n//  - Alternates between in0 and in1 at a programmable rate\n//  - Latches each decoded pattern into seg0_n/seg1_n registers\n//  - Outputs are stable between refresh ticks (no comb fanout from muxed input)\n// -----------------------------------------------------------------------------\nmodule sevenseg_twoch_tmux #(\n  // Adjust these to set the update rate.\n  // Example: at 25 MHz, DIV=125_000 gives a 200 Hz tick (each channel ~100 Hz).\n  parameter int unsigned DIV = 125_000\n) (\n  input  logic        clk,\n  input  logic        rst_n,\n\n  input  logic [3:0]  in0,\n  input  logic [3:0]  in1,\n\n  output logic [6:0]  seg0_n,  // decoded output for in0 (active LOW)\n  output logic [6:0]  seg1_n   // decoded output for in1 (active LOW)\n);\n\n  // Clock divider to make a refresh \"tick\"\n  logic [$clog2(DIV)-1:0] div_cnt;\n  logic                   tick;\n\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      div_cnt &lt;= '0;\n      tick    &lt;= 1'b0;\n    end else if (div_cnt == DIV-1) begin\n      div_cnt &lt;= '0;\n      tick    &lt;= 1'b1;\n    end else begin\n      div_cnt &lt;= div_cnt + 1'b1;\n      tick    &lt;= 1'b0;\n    end\n  end\n\n  // Channel select toggles each tick\n  logic sel;  // 0 -&gt; service in0, 1 -&gt; service in1\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) sel &lt;= 1'b0;\n    else if (tick) sel &lt;= ~sel;\n  end\n\n  // Single decoder instance, input multiplexed\n  logic [3:0] muxed_in;\n  logic [6:0] dec_out_n;\n\n  assign muxed_in = sel ? in1 : in0;\n\n  sevenseg_ca_decode u_dec (\n    .x     (muxed_in),\n    .seg_n (dec_out_n)\n  );\n\n  // Register each channel's pattern when it is serviced\n  // This removes glitches and gives each output a steady value\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      seg0_n &lt;= 7'h7F;  // all off\n      seg1_n &lt;= 7'h7F;\n    end else if (tick) begin\n      if (sel)  seg1_n &lt;= dec_out_n; // just decoded in1\n      else      seg0_n &lt;= dec_out_n; // just decoded in0\n    end\n  end\n\nendmodule\nThe LLM-generated code was synthesized the first time around in Radiant. It did take a longer time to synthesize than code that I’ve written, but there were no errors.\nThe hierarchy of the code it generated was different than mine, as it only had two modules, and mine had three. The seven segment module it wrote was pretty identical to my seven segment module, but the top level in the LLM-generated code (which included my multiplexer module functionality as well) was quite different. One of the main differences was that it didn’t use the on-board high speed oscillator for the clock and instead generated and used a new clock divider. It used a variable called “DIV,” which is told us to adjust to set the update or switching rate. The LLM-generated code also had two signals for enabling that performed the multiplexing, but it had two seven bit outputs instead of one. The generated code was pretty different than mine in terms of syntax, hierarchy, and implementation, but it was interesting to see that it does the same function (more or less) and compiles without errors.\nNext, I started a new conversation in ChatGPT and uploaded the following prompt along with my lab 1 files (all source files) as context to get the LLM-generated code shown below.\nPrompt: Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.\nCode:\n// dual_sevenseg_mux.sv\n// Time-multiplex a single 7-seg decoder across two 4-bit inputs and\n// drive two independent 7-bit (common-anode) segment buses.\n\nmodule dual_sevenseg_mux #(\n    // Internal oscillator nominal frequency (UP5K HFOSC ~48 MHz)\n    parameter int unsigned CLK_HZ      = 48_000_000,\n    // Per-digit refresh rate (how often each digit is updated)\n    parameter int unsigned REFRESH_HZ  = 1_000\n)(\n    input  logic        rst_n,          // active-low async reset (tie high if unused)\n\n    input  logic [3:0]  in0,            // nibble for \"left\" display\n    input  logic [3:0]  in1,            // nibble for \"right\" display\n\n    output logic [6:0]  seg0,           // segments for display 0 (common anode: active-low segments)\n    output logic [6:0]  seg1            // segments for display 1\n);\n\n    // ----------------------------------------------------------------\n    // Internal high-speed oscillator (Lattice iCE40 UP family primitive)\n    // ----------------------------------------------------------------\n    logic clk_hf;\n    HSOSC hf_osc (\n        .CLKHFPU (1'b1),   // power up\n        .CLKHFEN (1'b1),   // enable\n        .CLKHF   (clk_hf)  // ~48 MHz clock out\n    );\n\n    // ---------------------------------------------------------------\n    // Refresh tick generator (sets the multiplexing cadence)\n    // Each digit is updated at REFRESH_HZ, so the decoder input\n    // switches at 2*REFRESH_HZ overall.\n    // ---------------------------------------------------------------\n    localparam int unsigned TICKS_PER_REFRESH = CLK_HZ / REFRESH_HZ;\n    localparam int unsigned CNTW = $clog2(TICKS_PER_REFRESH);\n\n    logic [CNTW-1:0] tick_cnt;\n    logic            refresh_tick;\n\n    always_ff @(posedge clk_hf or negedge rst_n) begin\n        if (!rst_n) begin\n            tick_cnt     &lt;= '0;\n            refresh_tick &lt;= 1'b0;\n        end else begin\n            if (tick_cnt == TICKS_PER_REFRESH-1) begin\n                tick_cnt     &lt;= '0;\n                refresh_tick &lt;= 1'b1;\n            end else begin\n                tick_cnt     &lt;= tick_cnt + 1'b1;\n                refresh_tick &lt;= 1'b0;\n            end\n        end\n    end\n\n    // ---------------------------------------------------------------\n    // Single decoder instance, input mux, and latched outputs\n    // ---------------------------------------------------------------\n    logic        sel;           // 0 -&gt; in0 path active, 1 -&gt; in1 path active\n    logic [3:0]  mux_in;        // presented to the decoder\n    logic [6:0]  dec_out;       // raw decoder output (active-low segments)\n\n    // Feed one nibble at a time into the single decoder\n    assign mux_in = (sel == 1'b0) ? in0 : in1;\n\n    // Your provided seven-seg decoder (common-anode) — adjust names if needed.\n    seven_seg_sj u_dec (\n        .value (mux_in),\n        .seg   (dec_out)\n    );\n\n    // Registers to hold each display’s last-decoded segments\n    logic [6:0] seg0_r, seg1_r;\n\n    // On each refresh tick:\n    //  - latch current decoder output into the register corresponding to `sel`\n    //  - then toggle `sel` so the *other* nibble is decoded next period\n    always_ff @(posedge clk_hf or negedge rst_n) begin\n        if (!rst_n) begin\n            sel   &lt;= 1'b0;\n            seg0_r &lt;= 7'h7F;   // all OFF for common-anode (active-low)\n            seg1_r &lt;= 7'h7F;\n        end else if (refresh_tick) begin\n            if (sel == 1'b0) begin\n                seg0_r &lt;= dec_out; // we were decoding in0; capture for seg0\n            end else begin\n                seg1_r &lt;= dec_out; // we were decoding in1; capture for seg1\n            end\n            sel &lt;= ~sel; // switch to decode the other input next\n        end\n    end\n\n    // Drive outputs\n    assign seg0 = seg0_r;\n    assign seg1 = seg1_r;\n\nendmodule\nThis LLM-generated code did synthesize relatively quickly but had one error——that it was instantiating an unknown module seven_seg_sj. This was a mistake on my part because I didn’t add my module into the project. Besides this, the code looks pretty similar to mine. It uses the high speed oscillator and chooses the correct dual display based on the enable. Once again, it does have two 7-bit outputs while I have one, and it also uses syntax I’m not familiar with. But overall, it was efficient code, and was even more similar to mine when I inputted my lab 1 files."
  },
  {
    "objectID": "labs/labs.html",
    "href": "labs/labs.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "List of E155 Labs\nLab 1 - Board Assembly and Testing\nLab 2 - Multiplexed 7-Segment Display\nLab 3 - Keypad Scanner\nLab 4 - Digital Audio\nLab 5 - Interrupts\nLab 6 - The Internet of Things and Serial Peripheral Interface\nLab 7 - The Advanced Encryption Standard (AES)"
  },
  {
    "objectID": "labs/labs.html#labs-overview",
    "href": "labs/labs.html#labs-overview",
    "title": "E155 Portfolio",
    "section": "",
    "text": "List of E155 Labs\nLab 1 - Board Assembly and Testing\nLab 2 - Multiplexed 7-Segment Display\nLab 3 - Keypad Scanner\nLab 4 - Digital Audio\nLab 5 - Interrupts\nLab 6 - The Internet of Things and Serial Peripheral Interface\nLab 7 - The Advanced Encryption Standard (AES)"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, we soldered our E155 protoboard and implemented designs on the FPGA to drive on-board LEDs and a seven segment display. Two of the LEDs outputted combinational logic, and one of them was blinked at a specific frequency using the on-board high-speed oscillator.\n\n\n\nAfter soldering and testing the FPGA, MCU, and the development board for proper functionality, I designed my FPGA to further test the hardware on my board and operate a 7-segment display. The design consisted of the following:\n\n\n\n\n\n\n\n\nSignal Name\nSignal Type\nDescription\n\n\n\n\nclk\ninput\n48 MHz clock on FPGA\n\n\ns[3:0]\ninput\nfour DIP switches (on the board)\n\n\nled[2:0]\noutput\n3 on-board LEDs\n\n\nseg[6:0]\noutput\nthe segments of a common-anode 7-segment display\n\n\n\nThere were two primary aspects to this lab: operate three on-board LEDs (led[0], led[1], and led[2]) and create a 7-segment display.\nThe relationship between the switches (s0, s1, s2, s3) and the first two LEDs (led[0] and led[1]) were provided in the form of truth tables. Upon deriving the combinational logic, it was clear that led[0] was an exclusive or (XOR) of s0 and s1, while led[1] was an AND of s2 and s3. The third LED, led[3], was to be blinked at 2.4Hz. This was done using the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library. This oscillator generated a 48 MHz clock, and a counter was used to divide this down so the blinking frequency could be visualized on led[2]. In order to generate a 2.4 Hz signal that would complete a half cycle, a clock divider module was designed to count every (0.5)* 48 MHz/2.4 Hz, or 10 million ticks.\nThe 7-segment display was designed to display a signle hexadecimal digit specified by a four bit binary input s[3:0]. To do this, a separate SystemVerliog module was written, which contained 16 case statements detailing which segments of the display should be lit to create the hexademical digit corresponding to the dip switch input of s[3:0]. When breadboarding this design, it was important to remember that in the common annode display we were working with, a logic 0 applied to the cathode turned on the segment.\nAfter designing the modules on SystemVerilog and programming the designs to the FPGA, we tested our design. For the LEDs, in order to test led[0] and led[1], we tried the different combination logic using the switches to ensure the proper XOR and AND gate functionality. For led[2], we used an oscilloscope to verify the blink frequency of 2.4 Hz. To test the 7-segment display, we operated the DIP switches to ensure that the four bit binary numbers displayed their corresponding hexadecimal digit with equal brightness in segments, as shown in Figure 1.\n\n\n\nFigure 1. Output of hex digit 5 for a binary input of 4’b0101\n\n\nIn order to enxure that the current draw for each segment in the 7-segment display was within recommended operating conditions, the calculations shown in Figure 2 were done. The absolute maximum current rating is 20 mA, and as the calculations show, we have a 1.3 mA current draw, which is standard for LEDs.\n\n\n\nFigure 2. Calculations for current draw in 7-segment display\n\n\n\n\n\nThe source code for the project can be found in the associated Github repository.\n\n\n\n\n\nFigure 3. Block diagram of the Verilog module\n\n\nThe block diagram shown in Figure 3 demonstrates the overall architecture of the design. The top-level module (top) includes two submodules: the high-speed oscillator block (HSOSC) and the module to operate the 7-segment display. The operation of the LEDs happens in the top-level module as combinational logic.\n\n\n\n\n\n\nFigure 4. Schematic of the physical circuit\n\n\nThe physical layout of the design is shown in Figure 4. The left side of the UPduino shows the inputs, while the right side shows the outputs. The inputs consist of a reset button and four switches. An internal 100 kΩ pullup resistor was used to ensure the active low reset pin was not floating. The outputs consist of the seven LEDs from the 7-segment display, and three LEDs to test the combinational logic and blinking. These LEDs are connected using a 1kΩ current-limiting resistor to ensure the output current did not exceed the maximum output current of the FPGA I/O pins.\n\n\n\n\n\n\nTwo testbenches were written in SystemVerilog, one for the top-level and one for the 7-segment display modules, in order to verify that the designs were working as intended. Using the written test vectors, the testbenches ran all 16 cominations of the DIP switches in order to simulate and test if the led[2:0] and seg[6:0] outputs matched the expected outputs.\nAs shown in the simulation images shown in Figures 5 and 6, all the simulations passed and produced the expected outputs. Therefore, the design met all of the intended design objectives, and performed quickly and reliably. The simulations shown below ran in just a few seconds, and the hardware displayed all the required lights brightly.\n\n\n\nFigure 5. Top-level module QuestaSim simulation\n\n\n\n\n\nFigure 6. 7-segment module QuestaSim simulation\n\n\n\n\n\n\nMy FPGA designs successfully controlled a 7-segment display and LEDs, thus validating the functionality of my soldered protoboard. By blinking one of the LEDs at 2.4 Hz, I also validated the functionality of the on-board high-speed oscillator. In total, I spent 25 hours on this lab.\n\n\n\nUpon typing the following prompt into ChatGPT, the following code, along with the comment, was generated, as shown in Figures 7 and 8:\nLLM Prompt: Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\n\n\n\nFigure 7. Code generated by LLM\n\n\n\n\n\nFigure 8. Comment generated by LLM\n\n\nThe LLM-generated code was synthesized the first time around in Radiant. There were no errors and a few warnings in synthesis, but these warnings only pointed to top-level module declaration. These warnings were not related to the code itself.\nThe logic to blink the 2 Hz LED operated on the same principle: have a set number of toggle cycles, and when the counter reaches this number, reset the counter and blink the LED. The math to blink the LED was also the same: 48MHz divided by two times the desired blink frequency of 2 Hz.\nOne of the first differences I noticed was that there was no reset or reset case within the clock divide in the LLM-generated code. Another between my top-level module and the LLM-generated code is the declaration/usage of the internal high-speed oscillator. The module was declared using the # operator for parameter passing, but had essentially the same arguments as my one line of code. Another syntax that was new to me was the usage of “localparam” to define the variables (such as the number of toggle cycles) fixed within the design. A stylistic difference I noticed is that the calculations for the toggle cycle were included in the code generated by the LLM as variables, whereas I only included the final number of cycles. I liked the LLM’s version, as it was clear to follow the mathematical reasoning behind the number of cycles.\nI would rate the quality of the output pretty highly, as it was able to do the most difficult parts of this code generation quickly and efficiently. It demonstrated how to generate the number of toggles, how to use the internal high-speed oscillator, and how to create the clock divider, which are the main parts of this code. If I were to use an LLM in my workflow next time, I think I would specify SystemVerilog constructs/syntax I was familiar with in order to receive code that is most catered to my understanding."
  },
  {
    "objectID": "labs/lab1/lab1.html#lab-1-fpga-and-mcu-setup-and-testing",
    "href": "labs/lab1/lab1.html#lab-1-fpga-and-mcu-setup-and-testing",
    "title": "E155 Portfolio",
    "section": "",
    "text": "In this lab, we soldered our E155 protoboard and implemented designs on the FPGA to drive on-board LEDs and a seven segment display. Two of the LEDs outputted combinational logic, and one of them was blinked at a specific frequency using the on-board high-speed oscillator.\n\n\n\nAfter soldering and testing the FPGA, MCU, and the development board for proper functionality, I designed my FPGA to further test the hardware on my board and operate a 7-segment display. The design consisted of the following:\n\n\n\n\n\n\n\n\nSignal Name\nSignal Type\nDescription\n\n\n\n\nclk\ninput\n48 MHz clock on FPGA\n\n\ns[3:0]\ninput\nfour DIP switches (on the board)\n\n\nled[2:0]\noutput\n3 on-board LEDs\n\n\nseg[6:0]\noutput\nthe segments of a common-anode 7-segment display\n\n\n\nThere were two primary aspects to this lab: operate three on-board LEDs (led[0], led[1], and led[2]) and create a 7-segment display.\nThe relationship between the switches (s0, s1, s2, s3) and the first two LEDs (led[0] and led[1]) were provided in the form of truth tables. Upon deriving the combinational logic, it was clear that led[0] was an exclusive or (XOR) of s0 and s1, while led[1] was an AND of s2 and s3. The third LED, led[3], was to be blinked at 2.4Hz. This was done using the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library. This oscillator generated a 48 MHz clock, and a counter was used to divide this down so the blinking frequency could be visualized on led[2]. In order to generate a 2.4 Hz signal that would complete a half cycle, a clock divider module was designed to count every (0.5)* 48 MHz/2.4 Hz, or 10 million ticks.\nThe 7-segment display was designed to display a signle hexadecimal digit specified by a four bit binary input s[3:0]. To do this, a separate SystemVerliog module was written, which contained 16 case statements detailing which segments of the display should be lit to create the hexademical digit corresponding to the dip switch input of s[3:0]. When breadboarding this design, it was important to remember that in the common annode display we were working with, a logic 0 applied to the cathode turned on the segment.\nAfter designing the modules on SystemVerilog and programming the designs to the FPGA, we tested our design. For the LEDs, in order to test led[0] and led[1], we tried the different combination logic using the switches to ensure the proper XOR and AND gate functionality. For led[2], we used an oscilloscope to verify the blink frequency of 2.4 Hz. To test the 7-segment display, we operated the DIP switches to ensure that the four bit binary numbers displayed their corresponding hexadecimal digit with equal brightness in segments, as shown in Figure 1.\n\n\n\nFigure 1. Output of hex digit 5 for a binary input of 4’b0101\n\n\nIn order to enxure that the current draw for each segment in the 7-segment display was within recommended operating conditions, the calculations shown in Figure 2 were done. The absolute maximum current rating is 20 mA, and as the calculations show, we have a 1.3 mA current draw, which is standard for LEDs.\n\n\n\nFigure 2. Calculations for current draw in 7-segment display\n\n\n\n\n\nThe source code for the project can be found in the associated Github repository.\n\n\n\n\n\nFigure 3. Block diagram of the Verilog module\n\n\nThe block diagram shown in Figure 3 demonstrates the overall architecture of the design. The top-level module (top) includes two submodules: the high-speed oscillator block (HSOSC) and the module to operate the 7-segment display. The operation of the LEDs happens in the top-level module as combinational logic.\n\n\n\n\n\n\nFigure 4. Schematic of the physical circuit\n\n\nThe physical layout of the design is shown in Figure 4. The left side of the UPduino shows the inputs, while the right side shows the outputs. The inputs consist of a reset button and four switches. An internal 100 kΩ pullup resistor was used to ensure the active low reset pin was not floating. The outputs consist of the seven LEDs from the 7-segment display, and three LEDs to test the combinational logic and blinking. These LEDs are connected using a 1kΩ current-limiting resistor to ensure the output current did not exceed the maximum output current of the FPGA I/O pins.\n\n\n\n\n\n\nTwo testbenches were written in SystemVerilog, one for the top-level and one for the 7-segment display modules, in order to verify that the designs were working as intended. Using the written test vectors, the testbenches ran all 16 cominations of the DIP switches in order to simulate and test if the led[2:0] and seg[6:0] outputs matched the expected outputs.\nAs shown in the simulation images shown in Figures 5 and 6, all the simulations passed and produced the expected outputs. Therefore, the design met all of the intended design objectives, and performed quickly and reliably. The simulations shown below ran in just a few seconds, and the hardware displayed all the required lights brightly.\n\n\n\nFigure 5. Top-level module QuestaSim simulation\n\n\n\n\n\nFigure 6. 7-segment module QuestaSim simulation\n\n\n\n\n\n\nMy FPGA designs successfully controlled a 7-segment display and LEDs, thus validating the functionality of my soldered protoboard. By blinking one of the LEDs at 2.4 Hz, I also validated the functionality of the on-board high-speed oscillator. In total, I spent 25 hours on this lab.\n\n\n\nUpon typing the following prompt into ChatGPT, the following code, along with the comment, was generated, as shown in Figures 7 and 8:\nLLM Prompt: Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\n\n\n\nFigure 7. Code generated by LLM\n\n\n\n\n\nFigure 8. Comment generated by LLM\n\n\nThe LLM-generated code was synthesized the first time around in Radiant. There were no errors and a few warnings in synthesis, but these warnings only pointed to top-level module declaration. These warnings were not related to the code itself.\nThe logic to blink the 2 Hz LED operated on the same principle: have a set number of toggle cycles, and when the counter reaches this number, reset the counter and blink the LED. The math to blink the LED was also the same: 48MHz divided by two times the desired blink frequency of 2 Hz.\nOne of the first differences I noticed was that there was no reset or reset case within the clock divide in the LLM-generated code. Another between my top-level module and the LLM-generated code is the declaration/usage of the internal high-speed oscillator. The module was declared using the # operator for parameter passing, but had essentially the same arguments as my one line of code. Another syntax that was new to me was the usage of “localparam” to define the variables (such as the number of toggle cycles) fixed within the design. A stylistic difference I noticed is that the calculations for the toggle cycle were included in the code generated by the LLM as variables, whereas I only included the final number of cycles. I liked the LLM’s version, as it was clear to follow the mathematical reasoning behind the number of cycles.\nI would rate the quality of the output pretty highly, as it was able to do the most difficult parts of this code generation quickly and efficiently. It demonstrated how to generate the number of toggles, how to use the internal high-speed oscillator, and how to create the clock divider, which are the main parts of this code. If I were to use an LLM in my workflow next time, I think I would specify SystemVerilog constructs/syntax I was familiar with in order to receive code that is most catered to my understanding."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Post #1",
    "section": "",
    "text": "This semester, my personal goal in E-155 is to bridge a gap in my skill set: while I’ve always been drawn to analog circuitry and PCB design, I want to grow more confident in the digital side of hardware. I’m excited by the wide applications of embedded systems, from everyday devices to specialized applications in medicine and beyond, and I see this class as a chance to reframe how I think about hardware and software working together. I also want to get better at debugging with discipline rather than just trial and error. Another goal is to practice designing at the system level, balancing elegance with practicality, and then clearly communicating those decisions in reports and documentation. More broadly, I want to get comfortable with iteration and failure as part of the process, and to use the labs and project to experiment creatively and push myself beyond the bare minimum. After the labs and by the end of the semester, I hope to feel fluent enough in digital design to integrate it with my analog interests, and to carry that confidence into a really cool final project and beyond!"
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "E155 Course Website"
  },
  {
    "objectID": "resources.html#resources",
    "href": "resources.html#resources",
    "title": "E155 Portfolio",
    "section": "",
    "text": "E155 Course Website"
  }
]
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>lab4 – E155 Portfolio</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-c1fac2584b48ed01fb6e278e36375074.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">E155 Portfolio</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-labs" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Labs</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-labs">    
        <li>
    <a class="dropdown-item" href="../../labs/labs.html">
 <span class="dropdown-text">Labs Overview</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../labs/lab1/lab1.html">
 <span class="dropdown-text">Lab 1</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../labs/lab2/lab2.html">
 <span class="dropdown-text">Lab 2</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../labs/lab3/lab3.html">
 <span class="dropdown-text">Lab 3</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../labs/lab4/lab4.html">
 <span class="dropdown-text">Lab 4</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../labs/lab5/lab5.html">
 <span class="dropdown-text">Lab 5</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../labs/lab6/lab6.html">
 <span class="dropdown-text">Lab 6</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-project" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Project</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-project">    
        <li>
    <a class="dropdown-item" href="../../project/proposal.html">
 <span class="dropdown-text">Project Proposal</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../resources.html"> 
<span class="menu-text">Resources</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#lab-4-digital-audio" id="toc-lab-4-digital-audio" class="nav-link active" data-scroll-target="#lab-4-digital-audio">Lab 4: Digital Audio</a>
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#design-and-testing" id="toc-design-and-testing" class="nav-link" data-scroll-target="#design-and-testing">Design and Testing</a></li>
  <li><a href="#technical-documentation" id="toc-technical-documentation" class="nav-link" data-scroll-target="#technical-documentation">Technical Documentation</a></li>
  <li><a href="#results-and-discussion" id="toc-results-and-discussion" class="nav-link" data-scroll-target="#results-and-discussion">Results and Discussion</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  <li><a href="#ai-prototype" id="toc-ai-prototype" class="nav-link" data-scroll-target="#ai-prototype">AI Prototype</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="lab-4-digital-audio" class="level2">
<h2 class="anchored" data-anchor-id="lab-4-digital-audio">Lab 4: Digital Audio</h2>
<section id="introduction" class="level3">
<h3 class="anchored" data-anchor-id="introduction">Introduction</h3>
<p>In this lab, I learned how to use my MCU to play music by using timers. These timers generated square waves by toggling a GPIO pin at a specific frequency for specified durations. This lab also served as an introduction to working with the STM32 microcontroller boards. I gained a lot of experience with reading proper documentation (reference manual and datasheet) to understand clocks, timers, register, I/O, and more. The end result consisted of playing “Fur Elise” and my chosen song of “Hedwig’s Theme” from Harry Potter!</p>
</section>
<section id="design-and-testing" class="level3">
<h3 class="anchored" data-anchor-id="design-and-testing">Design and Testing</h3>
<section id="writing-the-library-in-c" class="level4">
<h4 class="anchored" data-anchor-id="writing-the-library-in-c">Writing the Library in C</h4>
<p>I used the Timer 15 and Timer 16 registers in order to output a square wave signal from the microcontroller. For this lab, we had to read the datasheet carefully and write our own library in C from scratch. One of the reasons I chose Timers 15 and 16 is because they have the same register map. This meant I could take advantage of only having to write one struct in my timer header file. Another reason I chose these timers is that they both have the ability to be configured to a PWM mode and be connected to a GPIO pin in alternate function mode in order to have the desired functionality of producing a square wave output.</p>
<p>After writing my header file, I wrote my timer source code, which consisted of four functions: initTIM to initialize my timer, delay_millis to provide a millisecond delay to set my note durations, initPWM to initialize the PWM mode of Timer 16, and setFreq to set the square wave to the desired frequency. Writing these four functions was the most difficult part of the lab, as they consisted of hours reading the reference manual to understand configuration, registers, and precisely which bits to set in which order to produce the desired functionality.</p>
</section>
<section id="software-and-timing-calculations" class="level4">
<h4 class="anchored" data-anchor-id="software-and-timing-calculations">Software and Timing Calculations</h4>
<p>To go into more details on how the timers work, the timer configured in the PWM mode had the auto reload register (ARR) and the capture/compare register (CCR1) set in order to produce a specific period and duty cycle. The ARR value is set such that when the counter is equal to this value, it resets to 0, meaning this value sets the period of the signal. When the counter is less than the CCR1 value, it outputs a low (0), and when the counter is higher, it outputs a high (1), meaning the CCR1 value sets teh duty cycle. I set the CCR1 value to be half of the ARR value to have a duty cycle of 0.5. For the timer configured to set the delay, I utilized the ARR to control the delay, as it was set depending on the millisecond input.</p>
<p>In this lab, I used a phase-locked-loop (PLL) to set the microcontroller clock at 80 MHz, and to produce lower frequencies, I used prescalers. The timing calculations and theory behind my prescaler values are shown below in Figure 1.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lab4_1.jpeg" class="img-fluid figure-img"></p>
<figcaption>Figure 1. Timing calculations for frequency of sound output</figcaption>
</figure>
</div>
<p>In order to make sure that the minimum and maximum frequency and duration were supported with my chosen prescaler values, I did the calculations shown below in Figure 2.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lab4_2.jpeg" class="img-fluid figure-img"></p>
<figcaption>Figure 2. Max and min duration and frequency calculations</figcaption>
</figure>
</div>
<p>One of the specs for this lab was to produce individual pitches calculated to be accurate within 1% across the frequency range of 220-1000 Hz. Using the derived formula in figure 1 and careful unit conversion, I ran a timing analysis across this frequency range to make sure the spec was met. The calculations used to program the spreadsheet, showing examples of the pitches and durations being correct, as well as the resulting data is shown below in Figure 3 and 4, respectively.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lab4_3.jpeg" class="img-fluid figure-img"></p>
<figcaption>Figure 3. Calculations for spreadsheet and examples</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lab4_4.jpeg" class="img-fluid figure-img"></p>
<figcaption>Figure 4. Pitch accuracy spreadsheet</figcaption>
</figure>
</div>
</section>
<section id="software-testing" class="level4">
<h4 class="anchored" data-anchor-id="software-testing">Software Testing</h4>
<p>In order to test the software’s functionality first, I uploaded the code to my MCU and used an oscilloscope to read the values of the GPIO pin to check that I was seeing the correct duty cycle and frequency. There was a lot of troubleshooting here, as I originlly did not see any square waves. I used Segger’s built in Debug mode to step through my code and ensure that all my registers were getting the value they were supposed to. After debugging and changing the way I configured/enabled things in my code, I started to see the correct frequency square waves in the oscilloscope.</p>
</section>
</section>
<section id="technical-documentation" class="level3">
<h3 class="anchored" data-anchor-id="technical-documentation">Technical Documentation</h3>
<p>The source code for the project can be found in the associated <a href="https://github.com/shreyajampana/e155-lab4">Github repository</a>.</p>
<section id="schematic" class="level4">
<h4 class="anchored" data-anchor-id="schematic">Schematic</h4>
<p>The circuit for this lab was simple. It contained an LM386 audio amplifier to drive the 8 ohm speaker and a potentiometer for volume control. The schematic is shown below in Figure 5.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/lab4_5.jpeg" class="img-fluid figure-img"></p>
<figcaption>Figure 5. Schematic for audio amplifier circuit</figcaption>
</figure>
</div>
</section>
</section>
<section id="results-and-discussion" class="level3">
<h3 class="anchored" data-anchor-id="results-and-discussion">Results and Discussion</h3>
<p>The design met all the intended objectives. The hardware for this lab, which was tested after making sure the software worked properly, worked on the first try. To encode a new song, I found the site music for music from Harry Potter, and transcribed the notes into frequencies using the table from the class website. A video of the final result, including Fur Elise and Hedwig’s Theme from Harry Potter, is shown below.</p>
<div class="quarto-video ratio ratio-16x9"><iframe data-external="1" src="https://www.youtube.com/embed/kGx0vvZtYeE" title="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>
</section>
<section id="conclusion" class="level3">
<h3 class="anchored" data-anchor-id="conclusion">Conclusion</h3>
<p>I was successfully able to use my MCU to play music in this lab! The learning curve was steep, as this was my first time writing libraries in C and using a microcontroller in depth. However, I got really comfortable reading the datasheet and reference manual, and I gained a better understanding of the STM32 overall. In total, I spent 19 hours on this lab.</p>
</section>
<section id="ai-prototype" class="level3">
<h3 class="anchored" data-anchor-id="ai-prototype">AI Prototype</h3>
<p>This was the prompt I entered into ChatGPT: What timers should I use on the STM32L432KC to generate frequencies ranging from 220Hz to 1kHz? What’s the best choice of timer if I want to easily connect it to a GPIO pin? What formulae are relevant, and what registers need to be set to configure them properly?</p>
<p>This is the answer it gave me:</p>
<pre><code>Great question. On the STM32L432KC you’ve got several timers that can do this cleanly.

Which timer(s) to use

Easiest “hook to a GPIO and forget it” (50% square wave):
TIM2 (general-purpose, 32-bit) using Output Compare Toggle mode. It routes to lots of pins (e.g., PA0…PA3 for CH1…CH4 on most L4s), and since it’s 32-bit you’ll never worry about running out of counts.

If you might want PWM duty control now or later:
TIM1 (advanced) or TIM2 / TIM15 / TIM16 / TIM17 in PWM mode. TIM1 has “advanced” features (BDTR/MOE), but TIM2 is simplest and widely pinned out. Pick whichever has a channel available on a pin you’ve broken out; PA8 (TIM1_CH1) and PA0 (TIM2_CH1) are common.
(Exact pin/AF depends on your board; check the “Alternate function mapping” table for the L432KC to pick the cleanest pin.)

Core formulas (you’ll use these every time)

Let f_tim be the timer’s input clock after the prescaler:

f_tim = f_clk / (PSC + 1)

PWM / update frequency (ARR reload):
f_out = f_tim / (ARR + 1)

PWM duty (edge-aligned):
duty = (CCR + 1) / (ARR + 1) → for 50%, set CCR = ARR / 2.

Output-compare TOGGLE (pure 50% square):
The pin toggles each compare event, so period is 2×(CCR+1) ticks →
f_out = f_tim / (2 * (CCR + 1))

These let you hit anything from 220 Hz to 1 kHz by choosing (PSC, ARR) for PWM or (PSC, CCR) for toggle.

Quick worked choices (two common clock setups)

Assume the timer clock (f_clk) is:

16 MHz (HSI default)

PWM at 1 kHz: pick PSC = 15 ⇒ f_tim = 1 MHz. Need ARR = 999 for 1 kHz. 50%: CCR = 500 - 1 = 499 (or just 500 if you’re not using “+1” convention).

PWM at 220 Hz: same PSC = 15 ⇒ f_tim = 1 MHz. ARR ≈ 1,000,000/220 − 1 = 4545 − 1 = 4544. 50%: CCR = 2272.

Toggle at 440 Hz (A4): PSC = 15 ⇒ f_tim = 1 MHz. Need CCR = f_tim/(2*f) − 1 = 1e6/(880) − 1 ≈ 1136 − 1 = 1135.

80 MHz (PLL to 80 MHz, common on L4)

PWM at 1 kHz: PSC = 79 ⇒ f_tim = 1 MHz. ARR = 999.

PWM at 220 Hz: PSC = 79 ⇒ ARR = 4544.

Toggle at 1 kHz: PSC = 79 ⇒ CCR = 1e6/(2*1000) − 1 = 499.

All of these fit in 16-bit easily; you don’t need TIM2’s 32-bit width, but it’s convenient.

Registers you’ll touch
RCC (enable clocks)

GPIO: RCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOxEN;

Timer:

TIM2/TIM6/7/15/16/17 → RCC-&gt;APB1ENR1 or APB2ENR (TIM1/15/16/17 are on APB2).

Example: RCC-&gt;APB1ENR1 |= RCC_APB1ENR1_TIM2EN;
RCC-&gt;APB2ENR |= RCC_APB2ENR_TIM1EN;

GPIO (put the pin in Alternate Function)

MODER: set to AF for your pin (10b).

AFRL/AFRH: set AF# for the chosen timer channel (e.g., AF1 for TIM1/TIM2 on many L4 pins).

Optional: OSPEEDR medium/high, PUPDR none, OTYPER push-pull.

Timer core (common)

PSC – prescaler

ARR – auto-reload (period); set before enabling counter

CR1 – ARPE=1 (preload ARR), CEN=1 to start; DIR=0 for upcount

Optional: EGR |= UG to force an update event so new PSC/ARR latch immediately

PWM mode specifics

CCMRx: set OCxM = 110 (PWM mode 1); OCxPE=1 (preload enable)

CCR x: duty value (0…ARR)

CCER: CCxE=1 (enable channel), choose polarity (CCxP=0 for active high)

TIM1 only (advanced timer): BDTR: set MOE=1 (Main Output Enable) or nothing will come out

Output Compare TOGGLE mode specifics

CCMRx: OCxM = 011 (Toggle), OCxPE=0 (typically no preload), CCR x = half-period − 1 in ticks

CCER: **CCxE=1`

ARR: can be large; in toggle mode you don’t need it to set the frequency (but keep it ≥ CCR)

Minimal LL-style pseudo-sequence
A) TIM2 PWM @ 1 kHz, 50% on PA0 (TIM2_CH1 as an example)
// clocks
RCC-&gt;AHB2ENR  |= RCC_AHB2ENR_GPIOAEN;
RCC-&gt;APB1ENR1 |= RCC_APB1ENR1_TIM2EN;

// PA0 -&gt; AF1 (TIM2_CH1)
GPIOA-&gt;MODER   = (GPIOA-&gt;MODER &amp; ~(3U &lt;&lt; (0*2))) | (2U &lt;&lt; (0*2));
GPIOA-&gt;AFR[0]  = (GPIOA-&gt;AFR[0] &amp; ~(0xF &lt;&lt; (0*4))) | (0x1 &lt;&lt; (0*4)); // AF1
GPIOA-&gt;OSPEEDR = (GPIOA-&gt;OSPEEDR &amp; ~(3U &lt;&lt; (0*2))) | (2U &lt;&lt; (0*2));  // medium/high

// timer base: f_clk=80MHz -&gt; PSC=79 =&gt; f_tim=1MHz
TIM2-&gt;PSC = 79;
TIM2-&gt;ARR = 999;          // 1 kHz
TIM2-&gt;CCR1 = 500;         // ~50%

// PWM mode 1 on CH1
TIM2-&gt;CCMR1 = (TIM2-&gt;CCMR1 &amp; ~TIM_CCMR1_OC1M) | (6U &lt;&lt; TIM_CCMR1_OC1M_Pos);
TIM2-&gt;CCMR1 |= TIM_CCMR1_OC1PE;  // preload
TIM2-&gt;CCER  |= TIM_CCER_CC1E;    // enable output

TIM2-&gt;CR1 |= TIM_CR1_ARPE;       // ARR preload
TIM2-&gt;EGR |= TIM_EGR_UG;         // latch PSC/ARR/CCR
TIM2-&gt;CR1 |= TIM_CR1_CEN;        // go

B) TIM2 TOGGLE @ 440 Hz on PA0 (exact 50% square, set-and-forget)
// clocks &amp; pin same as above...

TIM2-&gt;PSC = 79;            // 80MHz/80 = 1MHz tick
TIM2-&gt;CCR1 = 1135;         // f_out = 1e6 / (2*(1135+1)) ≈ 440 Hz
TIM2-&gt;ARR = 0xFFFF;        // big enough (not critical)

// OC toggle on CH1
TIM2-&gt;CCMR1 = (TIM2-&gt;CCMR1 &amp; ~TIM_CCMR1_OC1M) | (3U &lt;&lt; TIM_CCMR1_OC1M_Pos); // toggle
TIM2-&gt;CCER  |= TIM_CCER_CC1E;

TIM2-&gt;EGR |= TIM_EGR_UG;
TIM2-&gt;CR1 |= TIM_CR1_CEN;

C) TIM1 PWM (remember BDTR/MOE)
RCC-&gt;APB2ENR |= RCC_APB2ENR_TIM1EN;
// ...GPIO to AF for TIM1_CH1 (e.g., PA8/AF1)...
TIM1-&gt;PSC = 79; TIM1-&gt;ARR = 999; TIM1-&gt;CCR1 = 500;
TIM1-&gt;CCMR1 = (TIM1-&gt;CCMR1 &amp; ~TIM_CCMR1_OC1M) | (6U &lt;&lt; TIM_CCMR1_OC1M_Pos);
TIM1-&gt;CCMR1 |= TIM_CCMR1_OC1PE;
TIM1-&gt;CCER  |= TIM_CCER_CC1E;
TIM1-&gt;BDTR  |= TIM_BDTR_MOE;   // **required** for TIM1
TIM1-&gt;CR1   |= TIM_CR1_ARPE;
TIM1-&gt;EGR   |= TIM_EGR_UG;
TIM1-&gt;CR1   |= TIM_CR1_CEN;

Practical picking guidance

Just tones (always 50%)? Use TIM2 + OC Toggle. One register (CCR) sets the frequency; rock-solid 50% duty.

Want variable duty / envelopes / volume via duty? Use PWM mode on TIM2 (simplest routing) or TIM1 (if you need advanced features, dead-time, etc.).

Pin choice: Favour PA0..PA3 (TIM2 CH1..4) or PA8..PA11 (TIM1 CH1..4) because they’re commonly available on L432KC boards. Confirm the AF number for your exact pin in the datasheet’s AF table.

If you tell me your exact pin and your current system clock (16 MHz HSI vs 80 MHz PLL), I can drop in the exact (PSC, ARR, CCR) values for 220 Hz, 261.63 Hz, … up to 1 kHz in whichever mode you prefer.
</code></pre>
<p>It was honestly pretty useful. It walked through why you would want to use certain timers, what kinds of bits you need to enable, and the general formula for the thought process. It gave a more confident, even better answer after inputting the reference manual. It’s good for understanding general process flow, but I think I still wouldn’t trust it for the exact bits because a lot of precision and thought specific to your design is needed for the code.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/shreyajampana\.github\.io\/e155-portflio\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>
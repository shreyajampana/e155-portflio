{"title":"Lab 4: Digital Audio","markdown":{"headingText":"Lab 4: Digital Audio","containsRefs":false,"markdown":"\n### Introduction\nIn this lab, I learned how to use my MCU to play music by using timers. These timers generated square waves by toggling a GPIO pin at a specific frequency for specified durations. This lab also served as an introduction to working with the STM32 microcontroller boards. I gained a lot of experience with reading proper documentation (reference manual and datasheet) to understand clocks, timers, register, I/O, and more. The end result consisted of playing \"Fur Elise\" and my chosen song of \"Hedwig's Theme\" from Harry Potter!\n\n### Design and Testing\n\n#### Writing the Library in C\nI used the Timer 15 and Timer 16 registers in order to output a square wave signal from the microcontroller. For this lab, we had to read the datasheet carefully and write our own library in C from scratch. One of the reasons I chose Timers 15 and 16 is because they have the same register map. This meant I could take advantage of only having to write one struct in my timer header file. Another reason I chose these timers is that they both have the ability to be configured to a PWM mode and be connected to a GPIO pin in alternate function mode in order to have the desired functionality of producing a square wave output. \n\nAfter writing my header file, I wrote my timer source code, which consisted of four functions: initTIM to initialize my timer, delay_millis to provide a millisecond delay to set my note durations, initPWM to initialize the PWM mode of Timer 16, and setFreq to set the square wave to the desired frequency. Writing these four functions was the most difficult part of the lab, as they consisted of hours reading the reference manual to understand configuration, registers, and precisely which bits to set in which order to produce the desired functionality. \n\n#### Software and Timing Calculations\nTo go into more details on how the timers work, the timer configured in the PWM mode had the auto reload register (ARR) and the  capture/compare register (CCR1) set in order to produce a specific period and duty cycle. The ARR value is set such that when the counter is equal to this value, it resets to 0, meaning this value sets the period of the signal. When the counter is less than the CCR1 value, it outputs a low (0), and when the counter is higher, it outputs a high (1), meaning the CCR1 value sets teh duty cycle. I set the CCR1 value to be half of the ARR value to have a duty cycle of 0.5. For the timer configured to set the delay, I utilized the ARR to control the delay, as it was set depending on the millisecond input. \n\nIn this lab, I used a phase-locked-loop (PLL) to set the microcontroller clock at 80 MHz, and to produce lower frequencies, I used prescalers. The timing calculations and theory behind my prescaler values are shown below in Figure 1. \n\n![Figure 1. Timing calculations for frequency of sound output](images/lab4_1.jpeg)\n\nIn order to make sure that the minimum and maximum frequency and duration were supported with my chosen prescaler values, I did the calculations shown below in Figure 2. \n\n![Figure 2. Max and min duration and frequency calculations](images/lab4_2.jpeg)\n\nOne of the specs for this lab was to produce individual pitches calculated to be accurate within 1% across the frequency range of 220-1000 Hz. Using the derived formula in figure 1 and careful unit conversion, I ran a timing analysis across this frequency range to make sure the spec was met. The calculations used to program the spreadsheet, showing examples of the pitches and durations being correct, as well as the resulting data is shown below in Figure 3 and 4, respectively.\n\n![Figure 3. Calculations for spreadsheet and examples](images/lab4_3.jpeg)\n\n![Figure 4. Pitch accuracy spreadsheet](images/lab4_4.jpeg)\n\n#### Software Testing\nIn order to test the software's functionality first, I uploaded the code to my MCU and used an oscilloscope to read the values of the GPIO pin to check that I was seeing the correct duty cycle and frequency. There was a lot of troubleshooting here, as I originlly did not see any square waves. I used Segger's built in Debug mode to step through my code and ensure that all my registers were getting the value they were supposed to. After debugging and changing the way I configured/enabled things in my code, I started to see the correct frequency square waves in the oscilloscope. \n\n### Technical Documentation\n\nThe source code for the project can be found in the associated [Github repository](https://github.com/shreyajampana/e155-lab4).\n\n#### Schematic\nThe circuit for this lab was simple. It contained an LM386 audio amplifier to drive the 8 ohm speaker and a potentiometer for volume control. The schematic is shown below in Figure 5. \n\n![Figure 5. Schematic for audio amplifier circuit](images/lab4_5.jpeg)\n\n### Results and Discussion\nThe design met all the intended objectives. The hardware for this lab, which was tested after making sure the software worked properly, worked on the first try. To encode a new song, I found the site music for music from Harry Potter, and transcribed the notes into frequencies using the table from the class website. A video of the final result, including Fur Elise and Hedwig's Theme from Harry Potter, is shown below. \n\n{{< video https://www.youtube.com/watch?v=kGx0vvZtYeE >}}\n\n### Conclusion\nI was successfully able to use my MCU to play music in this lab! The learning curve was steep, as this was my first time writing libraries in C and using a microcontroller in depth. However, I got really comfortable reading the datasheet and reference manual, and I gained a better understanding of the STM32 overall. In total, I spent 19 hours on this lab.\n\n### AI Prototype\nThis was the prompt I entered into ChatGPT: \nWhat timers should I use on the STM32L432KC to generate frequencies ranging from 220Hz to 1kHz? What’s the best choice of timer if I want to easily connect it to a GPIO pin? What formulae are relevant, and what registers need to be set to configure them properly?\n\nThis is the answer it gave me:\n```\nGreat question. On the STM32L432KC you’ve got several timers that can do this cleanly.\n\nWhich timer(s) to use\n\nEasiest “hook to a GPIO and forget it” (50% square wave):\nTIM2 (general-purpose, 32-bit) using Output Compare Toggle mode. It routes to lots of pins (e.g., PA0…PA3 for CH1…CH4 on most L4s), and since it’s 32-bit you’ll never worry about running out of counts.\n\nIf you might want PWM duty control now or later:\nTIM1 (advanced) or TIM2 / TIM15 / TIM16 / TIM17 in PWM mode. TIM1 has “advanced” features (BDTR/MOE), but TIM2 is simplest and widely pinned out. Pick whichever has a channel available on a pin you’ve broken out; PA8 (TIM1_CH1) and PA0 (TIM2_CH1) are common.\n(Exact pin/AF depends on your board; check the “Alternate function mapping” table for the L432KC to pick the cleanest pin.)\n\nCore formulas (you’ll use these every time)\n\nLet f_tim be the timer’s input clock after the prescaler:\n\nf_tim = f_clk / (PSC + 1)\n\nPWM / update frequency (ARR reload):\nf_out = f_tim / (ARR + 1)\n\nPWM duty (edge-aligned):\nduty = (CCR + 1) / (ARR + 1) → for 50%, set CCR = ARR / 2.\n\nOutput-compare TOGGLE (pure 50% square):\nThe pin toggles each compare event, so period is 2×(CCR+1) ticks →\nf_out = f_tim / (2 * (CCR + 1))\n\nThese let you hit anything from 220 Hz to 1 kHz by choosing (PSC, ARR) for PWM or (PSC, CCR) for toggle.\n\nQuick worked choices (two common clock setups)\n\nAssume the timer clock (f_clk) is:\n\n16 MHz (HSI default)\n\nPWM at 1 kHz: pick PSC = 15 ⇒ f_tim = 1 MHz. Need ARR = 999 for 1 kHz. 50%: CCR = 500 - 1 = 499 (or just 500 if you’re not using “+1” convention).\n\nPWM at 220 Hz: same PSC = 15 ⇒ f_tim = 1 MHz. ARR ≈ 1,000,000/220 − 1 = 4545 − 1 = 4544. 50%: CCR = 2272.\n\nToggle at 440 Hz (A4): PSC = 15 ⇒ f_tim = 1 MHz. Need CCR = f_tim/(2*f) − 1 = 1e6/(880) − 1 ≈ 1136 − 1 = 1135.\n\n80 MHz (PLL to 80 MHz, common on L4)\n\nPWM at 1 kHz: PSC = 79 ⇒ f_tim = 1 MHz. ARR = 999.\n\nPWM at 220 Hz: PSC = 79 ⇒ ARR = 4544.\n\nToggle at 1 kHz: PSC = 79 ⇒ CCR = 1e6/(2*1000) − 1 = 499.\n\nAll of these fit in 16-bit easily; you don’t need TIM2’s 32-bit width, but it’s convenient.\n\nRegisters you’ll touch\nRCC (enable clocks)\n\nGPIO: RCC->AHB2ENR |= RCC_AHB2ENR_GPIOxEN;\n\nTimer:\n\nTIM2/TIM6/7/15/16/17 → RCC->APB1ENR1 or APB2ENR (TIM1/15/16/17 are on APB2).\n\nExample: RCC->APB1ENR1 |= RCC_APB1ENR1_TIM2EN;\nRCC->APB2ENR |= RCC_APB2ENR_TIM1EN;\n\nGPIO (put the pin in Alternate Function)\n\nMODER: set to AF for your pin (10b).\n\nAFRL/AFRH: set AF# for the chosen timer channel (e.g., AF1 for TIM1/TIM2 on many L4 pins).\n\nOptional: OSPEEDR medium/high, PUPDR none, OTYPER push-pull.\n\nTimer core (common)\n\nPSC – prescaler\n\nARR – auto-reload (period); set before enabling counter\n\nCR1 – ARPE=1 (preload ARR), CEN=1 to start; DIR=0 for upcount\n\nOptional: EGR |= UG to force an update event so new PSC/ARR latch immediately\n\nPWM mode specifics\n\nCCMRx: set OCxM = 110 (PWM mode 1); OCxPE=1 (preload enable)\n\nCCR x: duty value (0…ARR)\n\nCCER: CCxE=1 (enable channel), choose polarity (CCxP=0 for active high)\n\nTIM1 only (advanced timer): BDTR: set MOE=1 (Main Output Enable) or nothing will come out\n\nOutput Compare TOGGLE mode specifics\n\nCCMRx: OCxM = 011 (Toggle), OCxPE=0 (typically no preload), CCR x = half-period − 1 in ticks\n\nCCER: **CCxE=1`\n\nARR: can be large; in toggle mode you don’t need it to set the frequency (but keep it ≥ CCR)\n\nMinimal LL-style pseudo-sequence\nA) TIM2 PWM @ 1 kHz, 50% on PA0 (TIM2_CH1 as an example)\n// clocks\nRCC->AHB2ENR  |= RCC_AHB2ENR_GPIOAEN;\nRCC->APB1ENR1 |= RCC_APB1ENR1_TIM2EN;\n\n// PA0 -> AF1 (TIM2_CH1)\nGPIOA->MODER   = (GPIOA->MODER & ~(3U << (0*2))) | (2U << (0*2));\nGPIOA->AFR[0]  = (GPIOA->AFR[0] & ~(0xF << (0*4))) | (0x1 << (0*4)); // AF1\nGPIOA->OSPEEDR = (GPIOA->OSPEEDR & ~(3U << (0*2))) | (2U << (0*2));  // medium/high\n\n// timer base: f_clk=80MHz -> PSC=79 => f_tim=1MHz\nTIM2->PSC = 79;\nTIM2->ARR = 999;          // 1 kHz\nTIM2->CCR1 = 500;         // ~50%\n\n// PWM mode 1 on CH1\nTIM2->CCMR1 = (TIM2->CCMR1 & ~TIM_CCMR1_OC1M) | (6U << TIM_CCMR1_OC1M_Pos);\nTIM2->CCMR1 |= TIM_CCMR1_OC1PE;  // preload\nTIM2->CCER  |= TIM_CCER_CC1E;    // enable output\n\nTIM2->CR1 |= TIM_CR1_ARPE;       // ARR preload\nTIM2->EGR |= TIM_EGR_UG;         // latch PSC/ARR/CCR\nTIM2->CR1 |= TIM_CR1_CEN;        // go\n\nB) TIM2 TOGGLE @ 440 Hz on PA0 (exact 50% square, set-and-forget)\n// clocks & pin same as above...\n\nTIM2->PSC = 79;            // 80MHz/80 = 1MHz tick\nTIM2->CCR1 = 1135;         // f_out = 1e6 / (2*(1135+1)) ≈ 440 Hz\nTIM2->ARR = 0xFFFF;        // big enough (not critical)\n\n// OC toggle on CH1\nTIM2->CCMR1 = (TIM2->CCMR1 & ~TIM_CCMR1_OC1M) | (3U << TIM_CCMR1_OC1M_Pos); // toggle\nTIM2->CCER  |= TIM_CCER_CC1E;\n\nTIM2->EGR |= TIM_EGR_UG;\nTIM2->CR1 |= TIM_CR1_CEN;\n\nC) TIM1 PWM (remember BDTR/MOE)\nRCC->APB2ENR |= RCC_APB2ENR_TIM1EN;\n// ...GPIO to AF for TIM1_CH1 (e.g., PA8/AF1)...\nTIM1->PSC = 79; TIM1->ARR = 999; TIM1->CCR1 = 500;\nTIM1->CCMR1 = (TIM1->CCMR1 & ~TIM_CCMR1_OC1M) | (6U << TIM_CCMR1_OC1M_Pos);\nTIM1->CCMR1 |= TIM_CCMR1_OC1PE;\nTIM1->CCER  |= TIM_CCER_CC1E;\nTIM1->BDTR  |= TIM_BDTR_MOE;   // **required** for TIM1\nTIM1->CR1   |= TIM_CR1_ARPE;\nTIM1->EGR   |= TIM_EGR_UG;\nTIM1->CR1   |= TIM_CR1_CEN;\n\nPractical picking guidance\n\nJust tones (always 50%)? Use TIM2 + OC Toggle. One register (CCR) sets the frequency; rock-solid 50% duty.\n\nWant variable duty / envelopes / volume via duty? Use PWM mode on TIM2 (simplest routing) or TIM1 (if you need advanced features, dead-time, etc.).\n\nPin choice: Favour PA0..PA3 (TIM2 CH1..4) or PA8..PA11 (TIM1 CH1..4) because they’re commonly available on L432KC boards. Confirm the AF number for your exact pin in the datasheet’s AF table.\n\nIf you tell me your exact pin and your current system clock (16 MHz HSI vs 80 MHz PLL), I can drop in the exact (PSC, ARR, CCR) values for 220 Hz, 261.63 Hz, … up to 1 kHz in whichever mode you prefer.\n\n```\n\nIt was honestly pretty useful. It walked through why you would want to use certain timers, what kinds of bits you need to enable, and the general formula for the thought process. It gave a more confident, even better answer after inputting the reference manual. It's good for understanding general process flow, but I think I still wouldn't trust it for the exact bits because a lot of precision and thought specific to your design is needed for the code. ","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"lab4.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.33","theme":["cosmo","brand"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}
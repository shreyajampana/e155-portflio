{"title":"Lab 3: Keypad Scanner","markdown":{"headingText":"Lab 3: Keypad Scanner","containsRefs":false,"markdown":"\n### Introduction\nIn this lab, we learned how to use the FPGA to scan inputs from a 4x4 keypad. The multiplexed display from lab 2 was combined with a keypad to display user inputs. A scanning system was designed to read the inputs from keypad scanner, and a method for switch debouncing was also implemented. This lab required carefuly, thought-outTsynchronous sequential design\n\n### Design and Testing\nOne of the biggest design considerations was the scanner FSM. I went through many iterations, but in order to meet all of the specifications of the lab, ended up going with the following design: \n\n![Figure 1. Scanner FSM](images/lab3_1.jpeg)\n\nAs shown in figure 1, the scanner FSM has one state for each column, and one for each row within each column. Given a row input, the FSM should transition from the column state to the state corresponding to the row input. If no rows are pressed, you transition to the next column and repeat the process. My FSM was originally simpler, but in order to account for edge cases in button pressing, I decided to make each row a distinct state. \n\nThe next big design consideration was debouncer FSM. One important consideration when working with the keypad matrix is switch bouncing. When a button is pressed, the input may take some time to settle. In order to not register the \"bouncing\" as multiple presses, a method for switch debouncing has to be implemented. I did this using another FSM, which interacts with my scanner FSM and the rest of my modules. \n\n![Figure 2. Debouncer FSM](images/lab3_2.jpg)\n\nAs shown in figure 2, the debouncer module has four states. The first state is idle, and as soon as a row press is detected, you transition to the second state, which is where debouncing happens. I implemented the debouncing using a counter. I chose an arbitrary debounce time of 50 ms, as I believed the key would stabilitize after that time. Since the debouncer operates on the slow clock (at 183 Hz), I determined the number of cycles the counter needed to iterate by multiplying the clock frequency by the debouncing time, which gave me a number of ~10. Therefore, as soon as the counter reaches 10, you transition to the next stage, in which a pulse is sent out. You turn the pulse off in the final stage, and go back to the idle state. This pulse allows for regulation of decoding, maintaining it to only happen after the debouncing is complete. \n\nAfter designing the FSMs and all the interacting modules (explained in block diagram section below), I wired up the keypad. Seeing as our design was active high, I used pull down resistors for the rows. The picture of the wired circuit is shown below in figure 3.\n\n![Figure 3. Physical Circuit and Setup](images/lab3_3.jpg)\n\nIn order to test the system, I wrote some test benches for the more crucial modules and tested the keypad physically for all edge cases. \n\n### Technical Documentation\n\nThe source code for the project can be found in the associated [Github repository](https://github.com/shreyajampana/e155-lab3).\n\n#### Block Diagram\n\nThe block diagram for my system is shown below in figure 4. \n\n![Figure 4. System block diagram](images/lab3_4.jpeg)\n\nThe high speed oscillator lives in the top level module, and a slowClock module after it divides the high speed 48MHz clock into a slower 183Hz clock, which is used by the rest of the system. Following this, a scanner module takes in the row input and powers the column. It also sends out the 8-bit keyValue, which contains information about the row and column pressed. This module also outputs whether or not a row is pressed, which is used by the debouncer to debounce the press. The debouncer module outputs a pulse once debouncing is complete. Once the segDriver module receives a pulse, it takes the keyValue and decodes it into a four bit input. This module also shifts the old digit to the left, and puts the new digit on the right. These are sent to the switcher, which sends power to the seven segment (using enables) at the same frequency. The seven segment module then dipays the numbers. \n\n#### Schematic\n\nThe schematic for the system is shown below in figure 5. It includes the FPGA, the dual seven segment, and the keypad. \n\n![Figure 5. System Schematic](images/lab3_5.jpg)\n\n### Results and Discussion\n\nThe design meets all of the proficiency specs. It registers key presses, and moves old key presses to the left and puts new key presses on the right. All the LEDs are equally bright. The design also doesn't lock up when multiple keys are pressed.\n\nThroughout the lab, there were multiple bugs I resolved. I spent a long time finalizing the design of the FSMs and figuring out how to implement the debouncing logic. After quickly writing up the System Verilog, I uploaded my code and noticed that there were two 0s being displayed but no presses were being registered. This was the biggest bug, and was solved with a lot of simulation, checking the code to decode keyValue, and dealing with clock issues. \n\nI originally had a smaller FSM, but changed it to account for every row case so that when one key is pressed, and a second is also pressed in the same column at the same time, when you let go of the original key, the second key registers. I still have some issues that I am debugging. For example, for the two rightmost columns, when I press one key and press another, it registers the press even though the other is held down. This only happens for the two rightmost columns. I also was not able to implement a synchronizer successfully. \n\n### Conclusion\n\nDespite the small issues discussed above, my FPGA design was successfully able to scan inputs from a 4x4 keypad and debounce all the keys. In total, I spent about 60 hours on this lab. \n\n### AI Prototype\n\nFor this week's AI prototype, I tested two prompts. Here was prompt A: \n\nTarget device: Lattice iCE40 UP5K FPGA with internal high-speed oscillator (~20 MHz).\n\nWrite synthesizable SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7‑segment display. Implement: A clock divider that derives a scan clock on the order of 100–200 Hz from the internal oscillator. A keypad scanning controller that iterates one active‑low column at a time and samples active‑low rows, registering at most one key per press (debounce‑by‑design), ignoring additional presses while any key is held, and allowing a new registration only after release. A top level that updates two hex digits (older and most recent) when a new key is registered and drives a time‑multiplexed two‑digit 7‑segment display without visible flicker and with balanced brightness. Use idiomatic SystemVerilog (e.g., logic, always_ff, enumerated states for FSMs). Provide clean module boundaries and keep all state synchronous. Include brief comments explaining the design choices.\n\nHere was the code it produced: \n\nCode: \n\n```systemverilog\n// Generates a single-cycle tick at a programmable rate from a faster clk.\n// Example: With 20 MHz clk, DIV=100_000 -> 200 Hz tick.\nmodule clock_divider_tick #(\n    parameter int unsigned DIV = 100_000  // cycles per tick\n) (\n    input  logic clk,\n    input  logic reset_n,   // active-low synchronous reset\n    output logic tick       // 1-cycle pulse every DIV cycles\n);\n    localparam int W = $clog2(DIV);\n    logic [W-1:0] cnt;\n\n    always_ff @(posedge clk) begin\n        if (!reset_n) begin\n            cnt  <= '0;\n            tick <= 1'b0;\n        end else begin\n            if (cnt == DIV-1) begin\n                cnt  <= '0;\n                tick <= 1'b1;\n            end else begin\n                cnt  <= cnt + 1'b1;\n                tick <= 1'b0;\n            end\n        end\n    end\nendmodule\n\n\n// Two-flop synchronizer (vector-capable)\nmodule sync2 #(\n    parameter int W = 1\n) (\n    input  logic        clk,\n    input  logic        reset_n,\n    input  logic [W-1:0] d_async,\n    output logic [W-1:0] q_sync\n);\n    logic [W-1:0] s1;\n\n    always_ff @(posedge clk) begin\n        if (!reset_n) begin\n            s1     <= '1;     // rows are pulled-up; safe default high (no key)\n            q_sync <= '1;\n        end else begin\n            s1     <= d_async;\n            q_sync <= s1;\n        end\n    end\nendmodule\n\n\n// 4x4 matrix scanner (active-LOW rows/cols).\n// Debounce-by-design: registers at most one key per press. While any key\n// is held (across scan frames), further presses are ignored until release.\nmodule keypad_scanner_4x4 #(\n    // If your hardware uses different polarities, adjust here.\n    parameter bit ROW_ACTIVE_LOW = 1,\n    parameter bit COL_ACTIVE_LOW = 1\n) (\n    input  logic       clk,          // system clock (~20 MHz)\n    input  logic       reset_n,      // active-low sync reset\n    input  logic       scan_tick,    // ~100–200 Hz\n    input  logic [3:0] rows_in_sync, // synchronized rows\n    output logic [3:0] cols_out,     // driven to select 1 col at a time\n    output logic [3:0] key_code,     // hex 0..F per keypad mapping\n    output logic       key_pulse     // 1-cycle pulse when a new key is registered\n);\n    // FSM cycles columns; on each scan_tick select next column and sample rows.\n    typedef enum logic [1:0] {S_COL0, S_COL1, S_COL2, S_COL3} col_state_e;\n    col_state_e state, state_n;\n\n    logic [3:0] col_sel;   // one-hot (bit=1 means \"selected\" column)\n    logic [3:0] rows_smpl; // sampled (normalized active-high \"pressed\")\n    logic       any_pressed;\n    logic       latched_busy; // set after registering a key, cleared on full release\n\n    // Column drive: one column active at a time\n    always_comb begin\n        unique case (state)\n            S_COL0: col_sel = 4'b0001;\n            S_COL1: col_sel = 4'b0010;\n            S_COL2: col_sel = 4'b0100;\n            default: col_sel = 4'b1000;\n        endcase\n    end\n\n    // Active-LOW/active-HIGH drive for columns\n    always_comb begin\n        if (COL_ACTIVE_LOW) begin\n            // Selected column driven LOW (0), others HIGH (1)\n            cols_out = ~col_sel;\n        end else begin\n            cols_out = col_sel;\n        end\n    end\n\n    // Normalize rows: rows_norm=1 means \"pressed in current column\"\n    logic [3:0] rows_norm;\n    always_comb begin\n        if (ROW_ACTIVE_LOW) rows_norm = ~rows_in_sync;\n        else                rows_norm =  rows_in_sync;\n    end\n\n    // Sample rows on each scan tick (after column has been stable a full frame)\n    always_ff @(posedge clk) begin\n        if (!reset_n) rows_smpl <= '0;\n        else if (scan_tick)     rows_smpl <= rows_norm;\n    end\n    assign any_pressed = |rows_smpl;\n\n    // Next column on scan_tick\n    always_comb begin\n        state_n = state;\n        if (scan_tick) begin\n            unique case (state)\n                S_COL0: state_n = S_COL1;\n                S_COL1: state_n = S_COL2;\n                S_COL2: state_n = S_COL3;\n                default: state_n = S_COL0;\n            endcase\n        end\n    end\n    always_ff @(posedge clk) begin\n        if (!reset_n) state <= S_COL0;\n        else          state <= state_n;\n    end\n\n    // Register at most one key per continuous press:\n    // When not busy and exactly one row asserted, emit key_pulse and capture code.\n    function automatic logic is_onehot4(input logic [3:0] v);\n        return (v != 4'b0000) && ((v & (v - 1'b1)) == 4'b0000);\n    endfunction\n\n    // Encode row/col to hex (0..F). Mapping below is typical calculator style:\n    //   Col0   Col1   Col2   Col3\n    // R0  1      2      3      A\n    // R1  4      5      6      B\n    // R2  7      8      9      C\n    // R3  E      0      F      D\n    function automatic logic [3:0] encode_hex(\n        input logic [3:0] row_onehot,\n        input logic [3:0] col_onehot\n    );\n        int r, c;\n        begin\n            // onehot -> index\n            r = (row_onehot[0]) ? 0 :\n                (row_onehot[1]) ? 1 :\n                (row_onehot[2]) ? 2 : 3;\n            c = (col_onehot[0]) ? 0 :\n                (col_onehot[1]) ? 1 :\n                (col_onehot[2]) ? 2 : 3;\n            // lookup\n            unique case ({r[1:0], c[1:0]})\n                4'(0),4'(0): encode_hex = 4'h1; // r0 c0\n                default: begin end\n            endcase\n        end\n    endfunction\n\n    // The above would be clunky—use a compact LUT instead:\n    // Index = {row_idx[1:0], col_idx[1:0]}\n    function automatic logic [3:0] lut_hex(input int r, input int c);\n        logic [3:0] table [0:15];\n        begin\n            // Fill table\n            // r=0: 1,2,3,A\n            table[ 0] = 4'h1; table[ 1] = 4'h2; table[ 2] = 4'h3; table[ 3] = 4'hA;\n            // r=1: 4,5,6,B\n            table[ 4] = 4'h4; table[ 5] = 4'h5; table[ 6] = 4'h6; table[ 7] = 4'hB;\n            // r=2: 7,8,9,C\n            table[ 8] = 4'h7; table[ 9] = 4'h8; table[10] = 4'h9; table[11] = 4'hC;\n            // r=3: E,0,F,D\n            table[12] = 4'hE; table[13] = 4'h0; table[14] = 4'hF; table[15] = 4'hD;\n            lut_hex = table[(r<<2)|c];\n        end\n    endfunction\n\n    function automatic int onehot_to_idx(input logic [3:0] v);\n        begin\n            case (1'b1)\n                v[0]: onehot_to_idx = 0;\n                v[1]: onehot_to_idx = 1;\n                v[2]: onehot_to_idx = 2;\n                default: onehot_to_idx = 3;\n            endcase\n        end\n    endfunction\n\n    // Busy latch and key pulse generation\n    always_ff @(posedge clk) begin\n        if (!reset_n) begin\n            latched_busy <= 1'b0;\n            key_pulse    <= 1'b0;\n            key_code     <= 4'h0;\n        end else begin\n            key_pulse <= 1'b0; // default\n\n            if (!latched_busy) begin\n                // Only accept a new key when exactly one row is asserted\n                if (scan_tick && is_onehot4(rows_smpl)) begin\n                    int r = onehot_to_idx(rows_smpl);\n                    int c = onehot_to_idx(col_sel);\n                    key_code  <= lut_hex(r, c);\n                    key_pulse <= 1'b1;   // one-cycle pulse on system clk\n                    latched_busy <= 1'b1;\n                end\n            end else begin\n                // Wait for full release (no rows asserted across columns)\n                if (!any_pressed) begin\n                    // Note: any_pressed reflects sampled rows for the current column;\n                    // With a frame-by-frame scan at ~200 Hz, \"release observed\" is sufficient.\n                    latched_busy <= 1'b0;\n                end\n            end\n        end\n    end\nendmodule\n\n// Hex nibble to 7-seg segments (a..g), active-LOW output by default.\nmodule hex7seg #(\n    parameter bit ACTIVE_LOW_SEG = 1\n) (\n    input  logic [3:0] hex,\n    output logic [6:0] seg  // {a,b,c,d,e,f,g}\n);\n    logic [6:0] seg_h; // active-high internal truth table\n\n    always_comb begin\n        unique case (hex)\n            4'h0: seg_h = 7'b1111110;\n            4'h1: seg_h = 7'b0110000;\n            4'h2: seg_h = 7'b1101101;\n            4'h3: seg_h = 7'b1111001;\n            4'h4: seg_h = 7'b0110011;\n            4'h5: seg_h = 7'b1011011;\n            4'h6: seg_h = 7'b1011111;\n            4'h7: seg_h = 7'b1110000;\n            4'h8: seg_h = 7'b1111111;\n            4'h9: seg_h = 7'b1111011;\n            4'hA: seg_h = 7'b1110111;\n            4'hB: seg_h = 7'b0011111; // lower-case b\n            4'hC: seg_h = 7'b1001110;\n            4'hD: seg_h = 7'b0111101; // lower-case d\n            4'hE: seg_h = 7'b1001111;\n            default: seg_h = 7'b1000111; // F\n        endcase\n        seg = (ACTIVE_LOW_SEG) ? ~seg_h : seg_h;\n    end\nendmodule\n\n\n// Two-digit 7-seg time-multiplexer with balanced brightness.\n// refresh_tick should be ~2 kHz (so each digit ~1 kHz).\nmodule sevenseg_mux2 #(\n    parameter bit ACTIVE_LOW_SEG = 1,\n    parameter bit ACTIVE_LOW_DIG = 1\n) (\n    input  logic       clk,\n    input  logic       reset_n,\n    input  logic       refresh_tick,    // toggles active digit\n    input  logic [3:0] hex0,            // right (least recent) or \"newest\"\n    input  logic [3:0] hex1,            // left (older)\n    output logic [6:0] seg,             // a..g (dp omitted; add if needed)\n    output logic [1:0] dig_en           // [1]=left, [0]=right\n);\n    logic sel; // 0: show right, 1: show left\n    logic [3:0] nibble;\n    logic [6:0] seg_int;\n    logic [1:0] dig_h;  // active-high internal enables\n\n    always_ff @(posedge clk) begin\n        if (!reset_n) sel <= 1'b0;\n        else if (refresh_tick) sel <= ~sel;\n    end\n\n    always_comb begin\n        nibble = (sel) ? hex1 : hex0;\n        dig_h  = (sel) ? 2'b10 : 2'b01; // sel=1 -> left on; sel=0 -> right on\n    end\n\n    hex7seg #(.ACTIVE_LOW_SEG(ACTIVE_LOW_SEG)) u_hex (\n        .hex (nibble),\n        .seg (seg_int)\n    );\n\n    // Outputs with desired polarities\n    always_comb begin\n        seg   = seg_int;\n        dig_en = (ACTIVE_LOW_DIG) ? ~dig_h : dig_h;\n    end\nendmodule\n\n\n// Top-level: scans keypad and shows last two hex keys (hex1=older, hex0=most recent)\n// on a dual 7-seg display with time-multiplexing.\nmodule top_keypad_7seg #(\n    // Clocking (assume ~20 MHz HSOSC)\n    parameter int unsigned F_CLK_HZ     = 20_000_000,\n    parameter int unsigned SCAN_HZ      = 200,     // keypad scan frame rate\n    parameter int unsigned REFRESH_HZ   = 2_000,   // 2 kHz digit toggle (~1 kHz per digit)\n    // IO polarity\n    parameter bit ROW_ACTIVE_LOW = 1,\n    parameter bit COL_ACTIVE_LOW = 1,\n    parameter bit SEG_ACTIVE_LOW = 1,\n    parameter bit DIG_ACTIVE_LOW = 1\n) (\n    input  logic        clk,           // connect to HSOSC (~20 MHz)\n    input  logic        reset_n,       // active-low synchronous reset\n    // Keypad IO\n    input  logic [3:0]  rows_in,       // keypad rows (with external pull-ups or IO pull-ups)\n    output logic [3:0]  cols_out,      // keypad cols\n    // 7-seg IO\n    output logic [6:0]  seg,           // segments a..g (dp omitted)\n    output logic [1:0]  dig_en         // digit enables [1]=left, [0]=right\n);\n    // --- Ticks ---\n    localparam int unsigned DIV_SCAN    = (F_CLK_HZ / SCAN_HZ);\n    localparam int unsigned DIV_REFRESH = (F_CLK_HZ / REFRESH_HZ);\n\n    logic tick_scan, tick_refresh;\n\n    clock_divider_tick #(.DIV(DIV_SCAN)) u_div_scan (\n        .clk     (clk),\n        .reset_n (reset_n),\n        .tick    (tick_scan)\n    );\n\n    clock_divider_tick #(.DIV(DIV_REFRESH)) u_div_ref (\n        .clk     (clk),\n        .reset_n (reset_n),\n        .tick    (tick_refresh)\n    );\n\n    // --- Synchronize keypad rows ---\n    logic [3:0] rows_sync;\n    sync2 #(.W(4)) u_sync_rows (\n        .clk     (clk),\n        .reset_n (reset_n),\n        .d_async (rows_in),\n        .q_sync  (rows_sync)\n    );\n\n    // --- Scanner ---\n    logic [3:0] key_nibble;\n    logic       key_pulse;\n\n    keypad_scanner_4x4 #(\n        .ROW_ACTIVE_LOW (ROW_ACTIVE_LOW),\n        .COL_ACTIVE_LOW (COL_ACTIVE_LOW)\n    ) u_scan (\n        .clk         (clk),\n        .reset_n     (reset_n),\n        .scan_tick   (tick_scan),\n        .rows_in_sync(rows_sync),\n        .cols_out    (cols_out),\n        .key_code    (key_nibble),\n        .key_pulse   (key_pulse)\n    );\n\n    // --- Last two keys history ---\n    // hex0 = most recent, hex1 = older\n    logic [3:0] hex0, hex1;\n\n    always_ff @(posedge clk) begin\n        if (!reset_n) begin\n            hex0 <= 4'h0;\n            hex1 <= 4'h0;\n        end else if (key_pulse) begin\n            hex1 <= hex0;\n            hex0 <= key_nibble;\n        end\n    end\n\n    // --- 7-seg MUX ---\n    sevenseg_mux2 #(\n        .ACTIVE_LOW_SEG (SEG_ACTIVE_LOW),\n        .ACTIVE_LOW_DIG (DIG_ACTIVE_LOW)\n    ) u_mux (\n        .clk          (clk),\n        .reset_n      (reset_n),\n        .refresh_tick (tick_refresh),\n        .hex0         (hex0),  // show most recent on right\n        .hex1         (hex1),  // older on left\n        .seg          (seg),\n        .dig_en       (dig_en)\n    );\nendmodule\n\n```\n\nThis is the code AI generated. It gave me a syntax error, and when I tried to give the error to AI, it told me that I have to declare the return type differently. I didn't fully understand the error or the code, because it used high-level functions. \n\nPrompt B had three modular prompts: one for the one-shot registration (to debounce by design), one for keypad scanner controller, and one for integrate and display. Here is the code it produced:\n\n```systemverilog\n\n//------------------------------------------------------------------------------\n// Key One-Shot Registrar for 4x4 Keypad Scanners\n// - Assert new_key_pulse for 1 clk when a *new, debounced* press is detected\n// - Latch key_code_out at that instant\n// - Block further registrations until *full, debounced* release\n// - Debounce windows expressed in \"samples\" (e.g., column-scan ticks)\n//------------------------------------------------------------------------------\nmodule key_one_shot #(\n    // Number of *consecutive* samples required to confirm a press/release.\n    // Choose small integers given a scan rate of ~100–600 Hz.\n    parameter int PRESS_STABLE_SAMPLES   = 2,\n    parameter int RELEASE_STABLE_SAMPLES = 2\n)(\n    input  logic       clk,\n    input  logic       rst,           // synchronous active-high reset\n\n    // Drive this with your keypad scanner's sampling cadence\n    // (e.g., once per full matrix read or per-column step).\n    input  logic       sample_tick,\n\n    // Current instantaneous keypad state (already synchronized to clk):\n    input  logic       key_down,      // 1 if *any* key is presently detected\n    input  logic [3:0] key_code_in,   // code for the currently-detected key\n\n    // Registration outputs:\n    output logic       new_key_pulse, // 1 clk pulse on *new* debounced press\n    output logic [3:0] key_code_out,  // latched code for that new press\n    output logic       busy           // 1 while a key is debounced/held\n);\n\n    // ============================ State machine =============================\n    typedef enum logic [1:0] {\n        S_IDLE            = 2'd0,  // no key; waiting for a candidate press\n        S_DEBOUNCE_PRESS  = 2'd1,  // verifying stable press of one code\n        S_HELD            = 2'd2,  // press registered; ignore until release\n        S_DEBOUNCE_RELEASE= 2'd3   // verifying stable release (no key)\n    } state_e;\n\n    state_e state, state_n;\n\n    // Candidate key being evaluated during press debounce\n    logic [3:0] cand_code, cand_code_n;\n\n    // Counters for press / release stability (count sample_tick edges)\n    localparam int PW = (PRESS_STABLE_SAMPLES   > 1) ? $clog2(PRESS_STABLE_SAMPLES  ) : 1;\n    localparam int RW = (RELEASE_STABLE_SAMPLES > 1) ? $clog2(RELEASE_STABLE_SAMPLES) : 1;\n\n    logic [PW-1:0] press_cnt,   press_cnt_n;\n    logic [RW-1:0] release_cnt, release_cnt_n;\n\n    // Outputs (registered)\n    logic       new_key_pulse_n;\n    logic [3:0] key_code_out_n;\n    logic       busy_n;\n\n    // ============================== Next-state ==============================\n    always_comb begin\n        // Defaults: hold state/regs, clear pulse\n        state_n         = state;\n        cand_code_n     = cand_code;\n        press_cnt_n     = press_cnt;\n        release_cnt_n   = release_cnt;\n        new_key_pulse_n = 1'b0;\n        key_code_out_n  = key_code_out;\n        busy_n          = 1'b0;\n\n        unique case (state)\n            // -------- No key; watch for a candidate press --------\n            S_IDLE: begin\n                if (key_down && sample_tick) begin\n                    // Start debouncing a specific code\n                    cand_code_n = key_code_in;\n                    press_cnt_n = (PRESS_STABLE_SAMPLES > 1) ? '0 : press_cnt; // not used if 1\n                    state_n     = (PRESS_STABLE_SAMPLES > 1) ? S_DEBOUNCE_PRESS : S_HELD;\n                    if (PRESS_STABLE_SAMPLES == 1) begin\n                        // Immediate registration (edge users may set this)\n                        new_key_pulse_n = 1'b1;\n                        key_code_out_n  = key_code_in;\n                    end\n                end\n            end\n\n            // -------- Require N consecutive samples of same code --------\n            S_DEBOUNCE_PRESS: begin\n                busy_n = 1'b1;\n                if (sample_tick) begin\n                    if (!key_down) begin\n                        // Bounce back to idle if key vanished\n                        state_n     = S_IDLE;\n                        press_cnt_n = '0;\n                    end else if (key_code_in != cand_code) begin\n                        // Different code appeared during debounce -> restart with new candidate\n                        cand_code_n = key_code_in;\n                        press_cnt_n = '0;\n                    end else begin\n                        // Same code still present -> advance count\n                        if (press_cnt == PRESS_STABLE_SAMPLES-1) begin\n                            // Confirmed: register once and move to HELD\n                            new_key_pulse_n = 1'b1;\n                            key_code_out_n  = cand_code;\n                            state_n         = S_HELD;\n                        end else begin\n                            press_cnt_n = press_cnt + 1'b1;\n                        end\n                    end\n                end\n            end\n\n            // -------- Key is considered down; ignore further presses --------\n            S_HELD: begin\n                busy_n = 1'b1;\n                if (sample_tick && !key_down) begin\n                    // Start verifying stable release\n                    release_cnt_n = (RELEASE_STABLE_SAMPLES > 1) ? '0 : release_cnt;\n                    state_n       = (RELEASE_STABLE_SAMPLES > 1) ? S_DEBOUNCE_RELEASE : S_IDLE;\n                end\n            end\n\n            // -------- Require N consecutive samples of \"no key\" --------\n            S_DEBOUNCE_RELEASE: begin\n                busy_n = 1'b1;\n                if (sample_tick) begin\n                    if (key_down) begin\n                        // Key returned (bounce) -> still held\n                        state_n       = S_HELD;\n                        release_cnt_n = '0;\n                    end else begin\n                        if (release_cnt == RELEASE_STABLE_SAMPLES-1) begin\n                            state_n       = S_IDLE;\n                            release_cnt_n = '0;\n                        end else begin\n                            release_cnt_n = release_cnt + 1'b1;\n                        end\n                    end\n                end\n            end\n\n            default: begin\n                state_n = S_IDLE;\n            end\n        endcase\n    end\n\n    // =============================== Registers ==============================\n    always_ff @(posedge clk) begin\n        if (rst) begin\n            state         <= S_IDLE;\n            cand_code     <= '0;\n            press_cnt     <= '0;\n            release_cnt   <= '0;\n            new_key_pulse <= 1'b0;\n            key_code_out  <= '0;\n            busy          <= 1'b0;\n        end else begin\n            state         <= state_n;\n            cand_code     <= cand_code_n;\n            press_cnt     <= press_cnt_n;\n            release_cnt   <= release_cnt_n;\n            new_key_pulse <= new_key_pulse_n; // 1-cycle pulse\n            key_code_out  <= key_code_out_n;\n            busy          <= busy_n;\n        end\n    end\n\nendmodule\n\n\n\n//------------------------------------------------------------------------------\n// 4x4 Keypad Column Scanner (active-low columns, active-low rows)\n// - Cycles columns using a provided scan_tick (derived from a divided clock).\n// - Samples rows after driving a column (DRIVE -> SAMPLE).\n// - Debounces both press and release, reports ONE stable key while held.\n// - key_code_out remains constant and key_down=1 while the held key stays pressed.\n//------------------------------------------------------------------------------\nmodule keypad_scan_4x4 #(\n    // Debounce intervals expressed in *column visits* (samples).\n    // Choose small values with a scan_tick ~100–600 Hz (per column).\n    parameter int PRESS_STABLE_SAMPLES   = 2,\n    parameter int RELEASE_STABLE_SAMPLES = 2\n)(\n    input  logic       clk,\n    input  logic       rst,          // synchronous active-high reset\n\n    // Advance the scanner one micro-step (DRIVE -> SAMPLE -> next column -> ...).\n    // Typical: scan_tick at ~150–600 Hz (per column).\n    input  logic       scan_tick,\n\n    // Matrix I/O (active-low)\n    input  logic [3:0] rows_n,       // from keypad rows (external pull-ups recommended)\n    output logic [3:0] cols_n,       // to keypad columns (drive ONE low at a time)\n\n    // Outputs\n    output logic       key_down,     // 1 while a debounced key is held\n    output logic [3:0] key_code_out  // stable hex code for the held key\n);\n\n    // ----------------------------- Utilities ------------------------------\n    // Encode the first active-low row (priority 0>1>2>3)\n    function automatic logic [1:0] encode_row(input logic [3:0] r_n);\n        if (!r_n[0])      return 2'd0;\n        else if (!r_n[1]) return 2'd1;\n        else if (!r_n[2]) return 2'd2;\n        else              return 2'd3;\n    endfunction\n\n    // LUT: (row, col) -> hex (1..D, with *→E, 0→0, #→F)\n    function automatic logic [3:0] lut_hex(input logic [1:0] r, input logic [1:0] c);\n        unique case ({r,c})\n            // row 0\n            {2'd0,2'd0}: return 4'h1; {2'd0,2'd1}: return 4'h2; {2'd0,2'd2}: return 4'h3; {2'd0,2'd3}: return 4'hA;\n            // row 1\n            {2'd1,2'd0}: return 4'h4; {2'd1,2'd1}: return 4'h5; {2'd1,2'd2}: return 4'h6; {2'd1,2'd3}: return 4'hB;\n            // row 2\n            {2'd2,2'd0}: return 4'h7; {2'd2,2'd1}: return 4'h8; {2'd2,2'd2}: return 4'h9; {2'd2,2'd3}: return 4'hC;\n            // row 3\n            {2'd3,2'd0}: return 4'hE; // '*'\n            {2'd3,2'd1}: return 4'h0; // '0'\n            {2'd3,2'd2}: return 4'hF; // '#'\n            {2'd3,2'd3}: return 4'hD; // 'D'\n            default:                  return 4'h0;\n        endcase\n    endfunction\n\n    // --------------------- Row synchronizers (active-low) ------------------\n    logic [3:0] rows_meta, rows_sync_n;\n    always_ff @(posedge clk) begin\n        rows_meta   <= rows_n;\n        rows_sync_n <= rows_meta;\n    end\n\n    // ------------------------- Column sequencer ---------------------------\n    typedef enum logic [1:0] { PH_DRIVE=2'd0, PH_SAMPLE=2'd1 } phase_e;\n    phase_e phase, phase_n;\n\n    logic [1:0] col_idx, col_idx_n;\n\n    // Drive exactly one column low (others high)\n    always_comb begin\n        cols_n = 4'b1111;\n        cols_n[col_idx] = 1'b0;\n    end\n\n    // ----------------------------- Scanner FSM ----------------------------\n    typedef enum logic [1:0] {\n        S_IDLE = 2'd0,          // no key held; searching\n        S_DEB_PRESS = 2'd1,     // verifying stable press of candidate (row,col)\n        S_HELD = 2'd2           // key held; verify release\n    } state_e;\n    state_e state, state_n;\n\n    // Candidate / held key (row/col indices)\n    logic [1:0] cand_row, cand_col, cand_row_n, cand_col_n;\n    logic [1:0] held_row, held_col, held_row_n, held_col_n;\n\n    // Debounce counters (count column visits when relevant)\n    localparam int PW = (PRESS_STABLE_SAMPLES   > 1) ? $clog2(PRESS_STABLE_SAMPLES  ) : 1;\n    localparam int RW = (RELEASE_STABLE_SAMPLES > 1) ? $clog2(RELEASE_STABLE_SAMPLES) : 1;\n\n    logic [PW-1:0] press_cnt,   press_cnt_n;\n    logic [RW-1:0] release_cnt, release_cnt_n;\n\n    // Registered outputs\n    logic       key_down_n;\n    logic [3:0] key_code_out_n;\n\n    // Helper: any row active during SAMPLE\n    logic any_row_active;\n    assign any_row_active = (rows_sync_n != 4'b1111);\n\n    // ---------------------------- Next-state ------------------------------\n    always_comb begin\n        // Hold defaults\n        phase_n        = phase;\n        col_idx_n      = col_idx;\n\n        state_n        = state;\n        cand_row_n     = cand_row;\n        cand_col_n     = cand_col;\n        held_row_n     = held_row;\n        held_col_n     = held_col;\n\n        press_cnt_n    = press_cnt;\n        release_cnt_n  = release_cnt;\n\n        key_down_n     = key_down;\n        key_code_out_n = key_code_out;\n\n        // Phase machine: DRIVE -> SAMPLE on tick; after SAMPLE, advance column.\n        if (scan_tick) begin\n            unique case (phase)\n                PH_DRIVE:  phase_n = PH_SAMPLE;\n                PH_SAMPLE: begin\n                    phase_n   = PH_DRIVE;\n                    col_idx_n = col_idx + 2'd1;\n                end\n                default: phase_n = PH_DRIVE;\n            endcase\n        end\n\n        // Scanner behavior only acts in SAMPLE phase (rows valid after DRIVE)\n        unique case (state)\n            // ------------------------- No key held -------------------------\n            S_IDLE: begin\n                key_down_n = 1'b0;\n                if (phase == PH_SAMPLE && scan_tick) begin\n                    if (any_row_active) begin\n                        cand_row_n  = encode_row(rows_sync_n);\n                        cand_col_n  = col_idx;\n                        press_cnt_n = (PRESS_STABLE_SAMPLES > 1) ? '0 : press_cnt;\n\n                        if (PRESS_STABLE_SAMPLES == 1) begin\n                            // Immediate acceptance\n                            held_row_n     = cand_row_n;\n                            held_col_n     = cand_col_n;\n                            key_code_out_n = lut_hex(cand_row_n, cand_col_n);\n                            key_down_n     = 1'b1;\n                            state_n        = S_HELD;\n                        end else begin\n                            state_n = S_DEB_PRESS;\n                        end\n                    end\n                end\n            end\n\n            // --------- Require N visits to the SAME (row,col) candidate ----\n            S_DEB_PRESS: begin\n                key_down_n = 1'b0;\n                if (phase == PH_SAMPLE && scan_tick) begin\n                    if (!any_row_active) begin\n                        // Key disappeared -> abandon\n                        press_cnt_n = '0;\n                        state_n     = S_IDLE;\n                    end else begin\n                        logic [1:0] this_row = encode_row(rows_sync_n);\n                        if (this_row == cand_row && col_idx == cand_col) begin\n                            // Same candidate observed again\n                            if (press_cnt == PRESS_STABLE_SAMPLES-1) begin\n                                held_row_n     = cand_row;\n                                held_col_n     = cand_col;\n                                key_code_out_n = lut_hex(cand_row, cand_col);\n                                key_down_n     = 1'b1;\n                                state_n        = S_HELD;\n                            end else begin\n                                press_cnt_n = press_cnt + 1'b1;\n                            end\n                        end else begin\n                            // Different key (or different column) -> restart candidate\n                            cand_row_n  = this_row;\n                            cand_col_n  = col_idx;\n                            press_cnt_n = '0;\n                        end\n                    end\n                end\n            end\n\n            // ------------------------ Key is held --------------------------\n            S_HELD: begin\n                key_down_n = 1'b1;\n                if (phase == PH_SAMPLE && scan_tick) begin\n                    // Only evaluate release when we are sampling the held column\n                    if (col_idx == held_col) begin\n                        if (rows_sync_n[held_row] == 1'b1) begin\n                            // The held row is HIGH (inactive) on its column -> count release\n                            if (RELEASE_STABLE_SAMPLES == 1) begin\n                                key_down_n    = 1'b0;\n                                release_cnt_n = '0;\n                                state_n       = S_IDLE;\n                            end else if (release_cnt == RELEASE_STABLE_SAMPLES-1) {\n                                key_down_n    = 1'b0;\n                                release_cnt_n = '0;\n                                state_n       = S_IDLE;\n                            end else begin\n                                release_cnt_n = release_cnt + 1'b1;\n                            end\n                        end else begin\n                            // Still pressed\n                            release_cnt_n = '0;\n                        end\n                    end\n                end\n            end\n\n            default: state_n = S_IDLE;\n        endcase\n    end\n\n    // ------------------------------ Registers -----------------------------\n    always_ff @(posedge clk) begin\n        if (rst) begin\n            phase         <= PH_DRIVE;\n            col_idx       <= 2'd0;\n\n            state         <= S_IDLE;\n            cand_row      <= '0;\n            cand_col      <= '0;\n            held_row      <= '0;\n            held_col      <= '0;\n\n            press_cnt     <= '0;\n            release_cnt   <= '0;\n\n            key_down      <= 1'b0;\n            key_code_out  <= 4'h0;\n        end else begin\n            phase         <= phase_n;\n            col_idx       <= col_idx_n;\n\n            state         <= state_n;\n            cand_row      <= cand_row_n;\n            cand_col      <= cand_col_n;\n            held_row      <= held_row_n;\n            held_col      <= held_col_n;\n\n            press_cnt     <= press_cnt_n;\n            release_cnt   <= release_cnt_n;\n\n            key_down      <= key_down_n;\n            key_code_out  <= key_code_out_n;\n        end\n    end\n\nendmodule\n\n//------------------------------------------------------------------------------\n// Top: 4x4 Keypad -> Dual 7-seg (last two keys)\n// Target: Lattice iCE40 UP5K (internal HFOSC as root clock)\n//------------------------------------------------------------------------------\n\n// ------------------------------ Tick Divider -------------------------------\nmodule ce_divider #(\n    parameter int DIVISOR = 20_000  // Fclk / DIVISOR = enable rate (Hz if Fclk in Hz)\n) (\n    input  logic clk,\n    input  logic rst,     // synchronous active-high\n    output logic ce       // 1-cycle clock-enable pulse\n);\n    localparam int W = (DIVISOR <= 1) ? 1 : $clog2(DIVISOR);\n    logic [W-1:0] cnt;\n\n    always_ff @(posedge clk) begin\n        if (rst) begin\n            cnt <= '0;\n            ce  <= 1'b0;\n        end else begin\n            if (cnt == DIVISOR-1) begin\n                cnt <= '0;\n                ce  <= 1'b1;\n            end else begin\n                cnt <= cnt + 1'b1;\n                ce  <= 1'b0;\n            end\n        end\n    end\nendmodule\n\n// ------------------------------ Top-level ----------------------------------\nmodule top_keypad_two7seg #(\n    // Nominal HFOSC frequency (adjust if you measure differently)\n    parameter int F_HZ                 = 20_000_000,\n\n    // Display timing: 2 kHz total refresh -> 1 kHz per digit (no flicker)\n    parameter int REFRESH_HZ_TOTAL     = 2_000,\n\n    // Keypad scan: column step rate (per column). 200 Hz is safe/balanced.\n    parameter int SCAN_HZ_PER_COLUMN   = 200,\n\n    // Display polarity (set to 0 if your board is active-high)\n    parameter bit SEG_ACTIVE_LOW       = 1,  // segments a..g\n    parameter bit DIGIT_ACTIVE_LOW     = 1   // digit enables [left,right]\n) (\n    input  logic       rst_n,         // active-low reset\n    // Keypad matrix (active-low)\n    input  logic [3:0] rows_n,        // from keypad (pull-ups recommended)\n    output logic [3:0] cols_n,        // to keypad (one low at a time)\n    // 7-segment outputs\n    output logic [6:0] seg,           // a..g\n    output logic [1:0] dig_en         // [0]=left, [1]=right\n);\n    // ----------------------- Clock: iCE40 HFOSC -----------------------\n    logic clk;\n    SB_HFOSC #(.CLKHF_DIV(\"0b00\")) u_hfosc (  // see note below on freq\n        .CLKHFEN(1'b1),\n        .CLKHFPU(1'b1),\n        .CLKHF  (clk)\n    );\n    logic rst = ~rst_n;\n\n    // NOTE: HFOSC exact frequency depends on CLKHF_DIV; if your build yields\n    // ~24/48 MHz, set F_HZ accordingly or tweak divisors below.\n\n    // ------------------------ Clock-Enable ticks -----------------------\n    localparam int REFRESH_DIV  = (F_HZ / REFRESH_HZ_TOTAL);\n    localparam int SCAN_DIV     = (F_HZ / SCAN_HZ_PER_COLUMN);\n\n    logic refresh_tick, scan_tick;\n    ce_divider #(.DIVISOR(REFRESH_DIV)) u_refdiv (.clk(clk), .rst(rst), .ce(refresh_tick));\n    ce_divider #(.DIVISOR(SCAN_DIV   )) u_scndiv (.clk(clk), .rst(rst), .ce(scan_tick));\n\n    // --------------------- Keypad scan + one-shot ----------------------\n    logic       scan_key_down;\n    logic [3:0] scan_key_code;\n\n    // Scanner: cycles columns on scan_tick, debounces/holds one key\n    keypad_scan_4x4 #(\n        .PRESS_STABLE_SAMPLES  (2),\n        .RELEASE_STABLE_SAMPLES(2)\n    ) u_scan (\n        .clk         (clk),\n        .rst         (rst),\n        .scan_tick   (scan_tick),\n        .rows_n      (rows_n),\n        .cols_n      (cols_n),\n        .key_down    (scan_key_down),\n        .key_code_out(scan_key_code)\n    );\n\n    // One-shot: generate 1-cycle pulse when a new key is registered\n    // Scanner already debounces, so set samples=1 here (edge detect on held state)\n    logic       new_key_pulse;\n    logic [3:0] new_key_code;\n\n    key_one_shot #(\n        .PRESS_STABLE_SAMPLES  (1),\n        .RELEASE_STABLE_SAMPLES(1)\n    ) u_oneshot (\n        .clk          (clk),\n        .rst          (rst),\n        .sample_tick  (scan_tick),     // align with scanner cadence\n        .key_down     (scan_key_down),\n        .key_code_in  (scan_key_code),\n        .new_key_pulse(new_key_pulse),\n        .key_code_out (new_key_code),\n        .busy         (/* unused */)\n    );\n\n    // --------------------- Two-digit key history -----------------------\n    // Shift only on *new* key registration:\n    //   left  <- previous right (older)\n    //   right <- new key       (most recent)\n    logic [3:0] hex_left, hex_right;\n\n    always_ff @(posedge clk) begin\n        if (rst) begin\n            hex_left  <= 4'h0;\n            hex_right <= 4'h0;\n        end else if (new_key_pulse) begin\n            hex_left  <= hex_right;\n            hex_right <= new_key_code;\n        end\n    end\n\n    // --------------------- 7-seg decode (assumed provided) --------------\n    // sevenSegment: hex[3:0] -> seg[6:0] (a..g). Assume active-low segments.\n    logic [6:0] seg_left, seg_right;\n    sevenSegment u_dec_left  (.hex(hex_left ), .seg(seg_left ));\n    sevenSegment u_dec_right (.hex(hex_right), .seg(seg_right));\n\n    // --------------------- Time-multiplex display -----------------------\n    // Toggle selected digit at REFRESH_HZ_TOTAL -> 1 kHz per digit\n    logic sel; // 0 = left, 1 = right\n\n    always_ff @(posedge clk) begin\n        if (rst) sel <= 1'b0;\n        else if (refresh_tick) sel <= ~sel;\n    end\n\n    // Segment mux\n    logic [6:0] seg_mux = (sel == 1'b0) ? seg_left : seg_right;\n\n    // Apply polarities (segments and digit enables)\n    always_comb begin\n        // segments\n        seg = SEG_ACTIVE_LOW ? seg_mux : ~seg_mux;\n\n        // digit enables: one on, one off\n        logic [1:0] en_raw;\n        // Active-low encoding for common-anode:\n        // sel=0 -> left on (0), right off (1) => 2'b10 (dig_en[0]=left, [1]=right)\n        // sel=1 -> left off (1), right on (0) => 2'b01\n        en_raw = (sel == 1'b0) ? 2'b10 : 2'b01;\n\n        dig_en = DIGIT_ACTIVE_LOW ? en_raw : ~en_raw;\n    end\n\nendmodule\n\n```\n\nThe second prompt also had syntax errors, which when I fed back into AI, it told me what could possible cause them. The descriptions were good, but it was still a bit hard to parse through because I didn't understand the a lot of the syntax used in the AI code. Still, it was interesting (and a little dishreatening) to see it generate all the code and logic which took me many hours to come up with. \n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"lab3.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.33","theme":["cosmo","brand"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}
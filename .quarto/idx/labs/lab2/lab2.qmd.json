{"title":"Lab 2: Multiplexed 7-Segment Display","markdown":{"headingText":"Lab 2: Multiplexed 7-Segment Display","containsRefs":false,"markdown":"\n### Introduction\nIn this lab, time multiplexing was used to efficiently drive two seven-segment displays with a single set of FPGA I/O pins. The sum of both numbers were displayed on five separate LEDs. Additionally, transistors were used to drive large currents from the FPGA pins. \n\n### Design and Testing\nThe design of the time multiplexing scheme was one of the main components of this lab. Time multiplexing is a technique that is used to share a common expensive hardware resource for several purposes at different times. In this lab, time multiplexing was used to drive a single seven-segment decoder module to run both halves of a dual display. \n\nIn terms of wiring, this is done by connecting a single GPIO pin on the FPGA to the same segment (e.g. segment e) on both the seven-segment displays. However, in order to control which half of the dual display is active, the common anode of only one display at a time is turned ON. The power to these two displays are controlled by two separate GPIO pins, which are toggled at a certain speed in order for two distinct numbers to appear simultaneously on each display. Due to the anode requiring more current than the FPGA output pin can drive, a 2N3906 PNP transistor was used to limit the base current and not draw too much from the FPGA pin. Both of the dual displays are controlled by four bit DIP switches, and the sum of both numbers is displayed as a five bit number on five separate LEDs. The hardware layout, with the breadboard and wiring as described above, is shown in Figure 1.\n\n![Figure 1. Wiring of the dual seven-segment display, LEDs, and transistor circuits](images/lab2_1.jpeg)\n\nThe wiring and breadboard layout was intuitively done to enable easy debugging and be visually appealing. In order to justify resistor choices, calcuations were done, as shown in Figure 2, to ensure proper brightness of the five individual LEDs and that the current draw/sink on all the FPGA pins was below the currents specified in the recommended operating conditions. \n\n![Figure 2. Calculations to justify chosen resistor values for the dual seven-segment display, the five individual LEDs, and the PNP transistor](images/lab2_2.jpeg)\n\nFrom a software standpoint, important decisions were made in order to split up the required tasks of the lab into respective modules. A top level module was used to instantiate the on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library, which was the 48 MHz clock that was divided and used throughout the system. The top level module also contained the combinational logic for the five individual LEDs, as they were simple and therefore did not require a separate module. \n\nOne of the most important design considerations was the speed at which the two displays were toggled. This was done using a clock divider and 32-bit counter, where choosing different bits of the counter in the clock division allowed for different switching speeds. After testing, it was determined that the 18th bit of the counter produced a toggling speed that ensured that both hexadecimal digits lit up simultaneously without visible oscillation and without the digits bleeding into each other. At this speed, the clock divider enabled power to each of the displays in the dual display and the four bit inputs were sent one at a time to the seven segment module. \n\nIn order to verify the software, three testbenches were written with one for each module——top level, seven-segment, and multiplexer. The seven-segment testbench checked that the correct segments displayed with the corresponding four bit inpupts. The top level testbench checked that the combinational logic for the five LEDs functioned as properly. The multiplexer module checked that the input to the seven segment display was the correct four bit input corresponding to which display was enabled. The testbenches also checked the toggling of the enable signals. The waveforms are shown in the Results and Discussion section. In order to test the hardware, all switches and their summing combinational logic was tested on the breadboard. A picture from one of these tests is shown below in Figure 3. \n\n![Figure 3. Image from testing displaying functioning hardware. The hex digit \"b\" is displayed on the left, and \"0\" is displayed on the right, with their sum equalling 11 and being displayed on the five individual LEDs.](images/lab2_3.jpg)\n\n### Technical Documentation\nThe source code for the project can be found in the associated [Github repository](https://github.com/shreyajampana/e155-lab2).\n\n#### Block Diagram\n![Figure 4. Block diagram of the Verilog module](images/lab2_4.jpeg)\n\nThe block diagram shown in Figure 4 demonstrates the overall architecture of the design. The top-level module includes three submodules: the high-speed oscillator block (HSOSC), the seven-segment module to operate the 7-segment display, and the multiplexer module to operate the correct switching/toggling of the dual displays. \n\n#### Schematic\n\n![Figure 5. Schematic of the physical circuit](images/lab2_5.jpeg)\n\nThe physical layout of the design is shown in Figure 5. The left side of the UPduino shows the inputs, which are the reset and two sets of four-input DIP switches with an internal 100 kΩ pullup resistor to ensure the active low reset pin was not floating. The right side shows the outputs, which are the GPIO pins connecting the transistors to power, the two enables, the seven segments, and the five LEDs. All of the LEDs and transistors are connected to current-limiting resistors, the calculations for which are shown above in Figure 2. \n\n### Results and Discussion\n\n#### Testbench Simulation\nThree testbenches were written in SystemVerilog, one for each of the modules (top level, multiplexer, and seven-segment), in order to show that the combinational logic works and that the enables toggle and  produce the correct, corresponding display.\n\nAs shown in the simulation images below, all the simulations passed and produced the expected outputs. Figures 6 and 7 show the simulation waveforms for the top level module. Figure 6 shows that the led variable is the correct sum of the 8-bit counter input. Figure 7 shows that when zoomed out, the enable toggles and tests the other cases. Figure 8 shows that s (input to the seven-segment module) gets the correct four bit input during the correct enable. In the waveforms, it is visible that the value of four bits of s_counter (the input) match the value of s one clock cycle later. This makes sense because s is an output of the multiplexer module, and thus displays its value one clock cycle later. Similar to the top level, zooming out shows that the enable switches as expected to test all the other cases. Figure 10 shows the seven-segment waveforms also producing the expected outputs for the segment values on the display.  \n\n![Figure 6. Top-level module QuestaSim simulation showing correct combinational logic](images/lab2_top_sim.png)\n\n![Figure 7. Zoomed-out view of top-level module QuestaSim simulation showing the enables switching](images/lab2_top_sim2.png)\n\n![Figure 8. Multiplexer module QuestaSim simulation showing the seven-segment getting the correct input](images/lab2_mux_sim.png)\n\n![Figure 9. Zoomed-out view of multiplexer module QuestaSim simulation showing the enables switching](images/lab2_mux_sim2.png)\n\n![Figure 10. Seven-segment module QuestaSim simulation](images/lab1_6.png)\n\nTherefore, the design met all of the intended design objectives, and performed quickly and reliably. The simulations shown below ran in a few seconds, and the hardware displayed all the required LEDs brightly.\n\n### Conclusion\n\nMy FPGA designs successfully controlled a time multiplexing scheme to drive two 7-segment displays with a single set of FPGA I/O pins. A transistor to drive large currents from the FPGA pins was also successfully implemented. Additionally, I gained a lot of experience with building testbenches and modular Verilog systems. \n\nIn total, I spent 21 hours on this lab.\n\n### AI Prototype\n\nUpon typing the following prompt into ChatGPT, the following code was generated: \n\nPrompt: Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.\n\nCode: \n\n```systemverilog\n// -----------------------------------------------------------------------------\n// Common–anode 7-segment decoder (active LOW segments)\n// seg_n order = {a,b,c,d,e,f,g}\n// -----------------------------------------------------------------------------\nmodule sevenseg_ca_decode (\n  input  logic [3:0] x,\n  output logic [6:0] seg_n\n);\n  always_comb begin\n    unique case (x)\n      4'h0: seg_n = 7'b0000001;\n      4'h1: seg_n = 7'b1001111;\n      4'h2: seg_n = 7'b0010010;\n      4'h3: seg_n = 7'b0000110;\n      4'h4: seg_n = 7'b1001100;\n      4'h5: seg_n = 7'b0100100;\n      4'h6: seg_n = 7'b0100000;\n      4'h7: seg_n = 7'b0001111;\n      4'h8: seg_n = 7'b0000000;\n      4'h9: seg_n = 7'b0000100;\n      4'hA: seg_n = 7'b0001000;\n      4'hB: seg_n = 7'b1100000; // 'b' as 11\n      4'hC: seg_n = 7'b0110001;\n      4'hD: seg_n = 7'b1000010; // 'd' as 13\n      4'hE: seg_n = 7'b0110000;\n      4'hF: seg_n = 7'b0111000;\n      default: seg_n = 7'b1111111; // all OFF\n    endcase\n  end\nendmodule\n\n\n// -----------------------------------------------------------------------------\n// Two-channel time-multiplexer using a single decoder instance\n//  - Alternates between in0 and in1 at a programmable rate\n//  - Latches each decoded pattern into seg0_n/seg1_n registers\n//  - Outputs are stable between refresh ticks (no comb fanout from muxed input)\n// -----------------------------------------------------------------------------\nmodule sevenseg_twoch_tmux #(\n  // Adjust these to set the update rate.\n  // Example: at 25 MHz, DIV=125_000 gives a 200 Hz tick (each channel ~100 Hz).\n  parameter int unsigned DIV = 125_000\n) (\n  input  logic        clk,\n  input  logic        rst_n,\n\n  input  logic [3:0]  in0,\n  input  logic [3:0]  in1,\n\n  output logic [6:0]  seg0_n,  // decoded output for in0 (active LOW)\n  output logic [6:0]  seg1_n   // decoded output for in1 (active LOW)\n);\n\n  // Clock divider to make a refresh \"tick\"\n  logic [$clog2(DIV)-1:0] div_cnt;\n  logic                   tick;\n\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      div_cnt <= '0;\n      tick    <= 1'b0;\n    end else if (div_cnt == DIV-1) begin\n      div_cnt <= '0;\n      tick    <= 1'b1;\n    end else begin\n      div_cnt <= div_cnt + 1'b1;\n      tick    <= 1'b0;\n    end\n  end\n\n  // Channel select toggles each tick\n  logic sel;  // 0 -> service in0, 1 -> service in1\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) sel <= 1'b0;\n    else if (tick) sel <= ~sel;\n  end\n\n  // Single decoder instance, input multiplexed\n  logic [3:0] muxed_in;\n  logic [6:0] dec_out_n;\n\n  assign muxed_in = sel ? in1 : in0;\n\n  sevenseg_ca_decode u_dec (\n    .x     (muxed_in),\n    .seg_n (dec_out_n)\n  );\n\n  // Register each channel's pattern when it is serviced\n  // This removes glitches and gives each output a steady value\n  always_ff @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      seg0_n <= 7'h7F;  // all off\n      seg1_n <= 7'h7F;\n    end else if (tick) begin\n      if (sel)  seg1_n <= dec_out_n; // just decoded in1\n      else      seg0_n <= dec_out_n; // just decoded in0\n    end\n  end\n\nendmodule\n\n```\n\nThe LLM-generated code was synthesized the first time around in Radiant. It did take a longer time to synthesize than code that I've written, but there were no errors. \n\nThe hierarchy of the code it generated was different than mine, as it only had two modules, and mine had three. The seven segment module it wrote was pretty identical to my seven segment module, but the top level in the LLM-generated code (which included my multiplexer module functionality as well) was quite different. One of the main differences was that it didn't use the on-board high speed oscillator for the clock and instead generated and used a new clock divider. It used a variable called \"DIV,\" which is told us to adjust to set the update or switching rate. The LLM-generated code also had two signals for enabling that performed the multiplexing, but it had two seven bit outputs instead of one. The generated code was pretty different than mine in terms of syntax, hierarchy, and implementation, but it was interesting to see that it does the same function (more or less) and compiles without errors. \n\nNext, I started a new conversation in ChatGPT and uploaded the following prompt along with my lab 1 files (all source files) as context to get the LLM-generated code shown below. \n\nPrompt: Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.\n\nCode:\n\n```systemverilog\n// dual_sevenseg_mux.sv\n// Time-multiplex a single 7-seg decoder across two 4-bit inputs and\n// drive two independent 7-bit (common-anode) segment buses.\n\nmodule dual_sevenseg_mux #(\n    // Internal oscillator nominal frequency (UP5K HFOSC ~48 MHz)\n    parameter int unsigned CLK_HZ      = 48_000_000,\n    // Per-digit refresh rate (how often each digit is updated)\n    parameter int unsigned REFRESH_HZ  = 1_000\n)(\n    input  logic        rst_n,          // active-low async reset (tie high if unused)\n\n    input  logic [3:0]  in0,            // nibble for \"left\" display\n    input  logic [3:0]  in1,            // nibble for \"right\" display\n\n    output logic [6:0]  seg0,           // segments for display 0 (common anode: active-low segments)\n    output logic [6:0]  seg1            // segments for display 1\n);\n\n    // ----------------------------------------------------------------\n    // Internal high-speed oscillator (Lattice iCE40 UP family primitive)\n    // ----------------------------------------------------------------\n    logic clk_hf;\n    HSOSC hf_osc (\n        .CLKHFPU (1'b1),   // power up\n        .CLKHFEN (1'b1),   // enable\n        .CLKHF   (clk_hf)  // ~48 MHz clock out\n    );\n\n    // ---------------------------------------------------------------\n    // Refresh tick generator (sets the multiplexing cadence)\n    // Each digit is updated at REFRESH_HZ, so the decoder input\n    // switches at 2*REFRESH_HZ overall.\n    // ---------------------------------------------------------------\n    localparam int unsigned TICKS_PER_REFRESH = CLK_HZ / REFRESH_HZ;\n    localparam int unsigned CNTW = $clog2(TICKS_PER_REFRESH);\n\n    logic [CNTW-1:0] tick_cnt;\n    logic            refresh_tick;\n\n    always_ff @(posedge clk_hf or negedge rst_n) begin\n        if (!rst_n) begin\n            tick_cnt     <= '0;\n            refresh_tick <= 1'b0;\n        end else begin\n            if (tick_cnt == TICKS_PER_REFRESH-1) begin\n                tick_cnt     <= '0;\n                refresh_tick <= 1'b1;\n            end else begin\n                tick_cnt     <= tick_cnt + 1'b1;\n                refresh_tick <= 1'b0;\n            end\n        end\n    end\n\n    // ---------------------------------------------------------------\n    // Single decoder instance, input mux, and latched outputs\n    // ---------------------------------------------------------------\n    logic        sel;           // 0 -> in0 path active, 1 -> in1 path active\n    logic [3:0]  mux_in;        // presented to the decoder\n    logic [6:0]  dec_out;       // raw decoder output (active-low segments)\n\n    // Feed one nibble at a time into the single decoder\n    assign mux_in = (sel == 1'b0) ? in0 : in1;\n\n    // Your provided seven-seg decoder (common-anode) — adjust names if needed.\n    seven_seg_sj u_dec (\n        .value (mux_in),\n        .seg   (dec_out)\n    );\n\n    // Registers to hold each display’s last-decoded segments\n    logic [6:0] seg0_r, seg1_r;\n\n    // On each refresh tick:\n    //  - latch current decoder output into the register corresponding to `sel`\n    //  - then toggle `sel` so the *other* nibble is decoded next period\n    always_ff @(posedge clk_hf or negedge rst_n) begin\n        if (!rst_n) begin\n            sel   <= 1'b0;\n            seg0_r <= 7'h7F;   // all OFF for common-anode (active-low)\n            seg1_r <= 7'h7F;\n        end else if (refresh_tick) begin\n            if (sel == 1'b0) begin\n                seg0_r <= dec_out; // we were decoding in0; capture for seg0\n            end else begin\n                seg1_r <= dec_out; // we were decoding in1; capture for seg1\n            end\n            sel <= ~sel; // switch to decode the other input next\n        end\n    end\n\n    // Drive outputs\n    assign seg0 = seg0_r;\n    assign seg1 = seg1_r;\n\nendmodule\n```\nThis LLM-generated code did synthesize relatively quickly but had one error—that it was instantiating an unknown module seven_seg_sj. This was a mistake on my part because I didn't add my module into the project. Besides this, the code looks pretty similar to mine. It uses the high speed oscillator and chooses the correct dual display based on the enable. Once again, it does have two 7-bit outputs while I have one, and it also uses syntax I'm not familiar with. But overall, it was efficient code, and was even more similar to mine when I inputted my lab 1 files. \n\n\n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"lab2.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.33","theme":["cosmo","brand"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}
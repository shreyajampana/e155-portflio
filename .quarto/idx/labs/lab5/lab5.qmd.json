{"title":"Lab 5: Interrupts","markdown":{"headingText":"Lab 5: Interrupts","containsRefs":false,"markdown":"\n### Introduction\nIn this lab, we used our MCU to determine the speed of a motor by reading from a quadrature encoder. Lab 4 helped me get familiarized with the microcontroller and working with documentation, and this time, we tackled another aspect of microcontrollers: interrupts. Using these, I was able to process real-time, fast changes and record accurate measurements. \n\n### Design and Testing\n\n#### Quadrature Encoder Background\nAn encoder is a sensor that converts physical motion into electrical signals. A quadrature encoder is a common type of encoder that is used to measure the relative or absolute angle of a motor. They do this with the use of a patterned disk that is attached to the motor and spins with the motor. As shown in Figure 1 below, two stationary digital sensors 90 degrees out of phase are placed to produce two square waves that are 90 degrees out of phase with each other. The encoders used in this lab use magnets and hall effect sensors to produce the square waves. Using this theory and understanding, I designed my system to take full advantage of both signals to get the highest resolution measurement of the speed of the motor. \n\n![Figure 1. Diagram of quadrature encoder [Avnet Silica]](images/lab5_1.jpeg)\n\n#### Interrupt Design\nIn order to check the signals from the encoder and measure the speed of the motor, I used interrupts instead of polling. Polling involves continuously checking the status of the GPIO pins to detect whether or not the encoder output changed. This means the speed of taking a measurement is dependent on the time it takes all the commmands in the while loop to execute. This is problematic because if the code in the main loop is executing of a delay is being executed, you could miss the signal coming from the GPIO pin. This can cause timing issues and lead to inaccurate motor speeds being recorded due to sampling not happening fast/accurately enough. This problem can be overrided by using interrupts. Interrupts are event-driven instead of time-driven. This means that when the interrupt goes high, the CPU jumps to that address and the main/current execution context is paused as the interrupt is executed. After it's done, it returns back to the main code and continues where it left off. By doing this, interrupts give immediate attention to signal changes and ensure that all measurements are registered and correspond exactly to encoder changes. Some math to back up this understanding is shown below in Figure 2. \n\n![Figure 2. Interrupt vs. Polling Calculations](images/lab5_2.jpeg)\n\nIn order to achieve the highest resolution measurement, I used all edges of the encoder pulses. I did this by using two interrupts, one for Encoder A and one for Encoder B. Each encoder checked for the following four cases: clockwise rising edge, counter-clockwise rising edge, clockwise falling edge, and counter-clockwise falling edge. A counter was also used, which is explained more in the next section. The main steps of the program and the function calls are shown below in the flowchart in Figure 3. \n\n![Figure 3. Lab 5 Program Flowchart](images/lab5_3.jpeg)\n\n#### Software and Calculations\nThe interrupt design, described above, was the main portion of the software. Another important part was incorporating the counter into the interrupt and using that to calculate velocity. As mentioned above, each interrupt had four cases. In each case, if the motion was clockwise, the counter incremented. If the motion was counter-clockwise, the counter decreased. A graphical illustration of this using the signals from the encoder are shown below in Figure 4. \n\n![Figure 4. Encoder signals edges for CW and CCW rotation](images/lab5_4.jpeg)\n\nThe following equation was used to determine the speed of the motor based on the counter: velocity = counter / (PPR * 4). \n\n\n#### Verification\nIn order to make sure the measured speed matches the true motor speed and direction, I calculated the theoretical speed of the motor, hooked my motor up to the oscilloscope, and checked this against the values that my code output. From the datasheet, we know that at 12 V and 408 PPR, the speed of the motor should be 2.5 revolutions per second. Connecting the motor to the oscilloscope, I saw the following output, as shown in Figure 5. \n\n![Figure 5. Motor encoder signals at 12 V](images/lab5_5.jpg)\n\nAs shown on the oscilloscope screen, the output signal has a period of 848us. Calculations are shown below in Figure 6 to derive the speed of the motor using this value. \n\n![Figure 6. Speed of motor from oscilloscope](images/lab5_6.jpeg)\n\nAt this same voltage, the following speed of motor was output from my code, with each measurement being taken one second apart. \n\n![Figure 7. Speed of motor from code](images/lab5_7.jpeg) \n\nAll of these calculations are close to each other. The variation between the speed of the motor from the oscilloscope and that from the code is very small, and could be due to the motor speed itself fluctuating and not spinning at the same frequency. Also, signal capture on the oscilloscope can't be verified, so it's hard to determine if I'm capturing at the same rate on both the oscilloscope and on my console. Give this, I'm happy with the small variation and error rate between expected and measured. \n\n### Technical Documentation\nThe source code for the project can be found in the associated [Github repository](https://github.com/shreyajampana/e155-lab5).\n\n#### Schematic\nThe circuit from this lab was very simple, as shown in the schematic below in Figure 8. It only consisted of connecting the motor encoder to the two MCU GPIO pins and a variable DC voltage +/- Vs being applied to the positive terminal of the motor from a power supply.\n\n![Figure 8. Lab 5 Schematic](images/lab5_8.jpeg)\n\n### Results and Discussion\nThe design met all the intended objectives. After becoming comfortable with how to use the datasheet and reference manual for the MCU, this lab went by much smoother on the software end. The biggest point of confusion was understanding interrupts conceptually, but after that was done, the lab went by pretty smoothly. The final results are shown in the video below, with speed being output once per second on the console. \n\n{{< video https://youtu.be/2aJs_RmUtGY >}}\n\n### Conclusion\nI gained even more experience with my MCU in this lab. Learning more about interrupts also taught me how to properly read and process fast changes in order to make the most accurate measurements. In total, this lab took me 9 hours to complete.  \n\n### AI Prototype\nThis was the prompt for ChatGPT for this lab: \nWrite me interrupt handlers to interface with a quadrature encoder. I’m using the STM32L432KC, what pins should I connect the encoder to in order to allow it to easily trigger the interrupts?\n\nThis was its response and code:\n\n![AI](images/lab5_9.jpg)\n![AI](images/lab5_10.jpg)\n\n```\n// quadrature_exti.c\n#include \"stm32l4xx_hal.h\"\n\n// === User options ===\n#define QUAD_REVERSE 0   // set to 1 to invert direction if needed\n\nvolatile int32_t g_encoder_pos = 0;   // 4x counts\nvolatile uint32_t g_last_edge_us = 0; // optional: for simple deglitching if desired\n\n// Forward decls\nstatic void MX_GPIO_Quad_Init(void);\n\n// Call this from your main init\nvoid Quad_Init(void) {\n    MX_GPIO_Quad_Init();\n}\n\n// --- GPIO + EXTI init for PA0/PA1 (A/B), optional PA2 (Z) ---\nstatic void MX_GPIO_Quad_Init(void)\n{\n    __HAL_RCC_GPIOA_CLK_ENABLE();\n    __HAL_RCC_SYSCFG_CLK_ENABLE();\n\n    GPIO_InitTypeDef gi = {0};\n\n    // Configure PA0 (A) and PA1 (B) as inputs with pull-ups and EXTI on both edges\n    gi.Mode  = GPIO_MODE_IT_RISING_FALLING;\n    gi.Pull  = GPIO_PULLUP;            // or PULLDOWN to match your encoder; many encoders are open-collector -> use PULLUP\n    gi.Speed = GPIO_SPEED_FREQ_HIGH;\n\n    gi.Pin   = GPIO_PIN_0; HAL_GPIO_Init(GPIOA, &gi);  // A\n    gi.Pin   = GPIO_PIN_1; HAL_GPIO_Init(GPIOA, &gi);  // B\n\n    // Optional index Z on PA2\n    // gi.Pin   = GPIO_PIN_2; HAL_GPIO_Init(GPIOA, &gi);\n\n    // NVIC: each line has its own IRQ, keeps ISRs short\n    HAL_NVIC_SetPriority(EXTI0_IRQn, 3, 0);\n    HAL_NVIC_EnableIRQ(EXTI0_IRQn);\n\n    HAL_NVIC_SetPriority(EXTI1_IRQn, 3, 0);\n    HAL_NVIC_EnableIRQ(EXTI1_IRQn);\n\n    // Optional EXTI2 for index\n    // HAL_NVIC_SetPriority(EXTI2_IRQn, 3, 0);\n    // HAL_NVIC_EnableIRQ(EXTI2_IRQn);\n}\n\n// --- Direction logic helpers ---\n// If A changed: dir = (A == B) ? -1 : +1\n// If B changed: dir = (A == B) ? +1 : -1\n// (This matches a common quadrature phase; flip with QUAD_REVERSE if it’s backward.)\n\nstatic inline void quad_on_A_edge(void)\n{\n    uint8_t A = (uint8_t)HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0);\n    uint8_t B = (uint8_t)HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_1);\n    int step = (A == B) ? -1 : +1;\n#if QUAD_REVERSE\n    step = -step;\n#endif\n    g_encoder_pos += step;\n}\n\nstatic inline void quad_on_B_edge(void)\n{\n    uint8_t A = (uint8_t)HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0);\n    uint8_t B = (uint8_t)HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_1);\n    int step = (A == B) ? +1 : -1;\n#if QUAD_REVERSE\n    step = -step;\n#endif\n    g_encoder_pos += step;\n}\n\n// --- ISRs ---\nvoid EXTI0_IRQHandler(void)  // A on PA0\n{\n    if (__HAL_GPIO_EXTI_GET_IT(GPIO_PIN_0) != 0u) {\n        __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_0);\n        quad_on_A_edge();\n    }\n}\n\nvoid EXTI1_IRQHandler(void)  // B on PA1\n{\n    if (__HAL_GPIO_EXTI_GET_IT(GPIO_PIN_1) != 0u) {\n        __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_1);\n        quad_on_B_edge();\n    }\n}\n\n// Optional: index Z zeroing, both edges or rising only as you prefer\n// void EXTI2_IRQHandler(void)\n// {\n//     if (__HAL_GPIO_EXTI_GET_IT(GPIO_PIN_2) != 0u) {\n//         __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_2);\n//         g_encoder_pos = 0;  // or latch index, etc.\n//     }\n// }\n```\n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"lab5.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.33","theme":["cosmo","brand"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}